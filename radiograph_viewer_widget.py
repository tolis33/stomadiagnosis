import sys
import os
import re
import uuid
import shutil
import json
import subprocess
import tempfile
import hashlib
import math
import zipfile
from pathlib import Path
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QFileDialog, 
    QGraphicsView, QGraphicsScene, QListWidget, QListWidgetItem, QMessageBox,
    QProgressBar, QGraphicsRectItem, QGraphicsTextItem, QTextEdit, QSplitter,
    QMenu, QGraphicsPixmapItem, QInputDialog, QLabel, QGraphicsPathItem, QSlider,
    QDialog, QCheckBox, QDialogButtonBox, QGraphicsEllipseItem, QGraphicsItem, QGraphicsPolygonItem, QComboBox, QLineEdit, QTabWidget, QCompleter, QScrollArea, QGridLayout, QToolBar, QSizePolicy, QStyle, QTableWidget, QTableWidgetItem, QRadioButton, QButtonGroup,
    QApplication, QGraphicsLineItem, QGraphicsSimpleTextItem
)
from PyQt6.QtGui import QPixmap, QWheelEvent, QImage, QColor, QPen, QBrush, QFont, QTextCursor, QPainterPath, QPainter, QAction, QDesktopServices, QPainterPathStroker, QPolygonF, QDrag, QCursor
from PyQt6.QtCore import Qt, QPointF, QThread, QTimer, QRectF, QPoint, pyqtSignal, QUrl, QEvent, QSize, QMimeData, QObject
from PyQt6.QtSql import QSqlDatabase, QSqlQuery
from datetime import datetime
import pydicom
import numpy as np
from PIL import Image
try:
    import cv2
except Exception:
    cv2 = None
import copy
import functools
import io
import time
import wave
import difflib
import unicodedata
import base64
import ctypes
import ctypes.wintypes
import urllib.request
import urllib.error
import urllib.parse
import getpass
from app.ai.analysis_worker import AnalysisWorker
from app.ai.feedback_manager import FeedbackManager
from app.ai.training_worker import TrainingWorker
from app.ai.toothcls_training_worker import ToothClsTrainingWorker
from app.ai.toothdet_training_worker import ToothDetTrainingWorker
from app.ai.annotation_sync import sync_annotations_to_training
from app.ai.anatomical_zones import AnatomicalZoneManager
from app.ai.dataset_tools import create_val_split_if_missing, create_toothdet_splits_if_missing
from app.ai.auto_training import analysis_to_training_json, dataset_quality_check, dataset_quality_check_toothdet, choose_training_params, parse_yolo_results_csv, version_trained_model, write_training_report
from app.ai.reanalysis_verifier import build_report, write_report
from app.core.app_prefs import AppPrefs
from app.core.model_registry import register_model, get_current_model
from app.ai.holdout_manager import ensure_holdout_config
try:
    from app.core.tts_worker import TTSWorker
except ImportError:
    TTSWorker = None

class _DATA_BLOB(ctypes.Structure):
    _fields_ = [("cbData", ctypes.wintypes.DWORD), ("pbData", ctypes.POINTER(ctypes.c_byte))]

def _dpapi_protect_bytes(raw: bytes) -> bytes:
    if os.name != "nt":
        raise RuntimeError("DPAPI διαθέσιμο μόνο σε Windows.")
    if raw is None:
        raw = b""
    in_blob = _DATA_BLOB()
    in_blob.cbData = len(raw)
    in_blob.pbData = ctypes.cast(ctypes.create_string_buffer(raw, len(raw)), ctypes.POINTER(ctypes.c_byte))
    out_blob = _DATA_BLOB()
    if not ctypes.windll.crypt32.CryptProtectData(ctypes.byref(in_blob), None, None, None, None, 0, ctypes.byref(out_blob)):
        raise RuntimeError("CryptProtectData απέτυχε.")
    try:
        return ctypes.string_at(out_blob.pbData, out_blob.cbData)
    finally:
        try:
            ctypes.windll.kernel32.LocalFree(out_blob.pbData)
        except Exception as e:
            logging.error(f"DPAPI Error: {e}")
            pass

def _worker_load_gray_uint8_for_path(file_path: str):
    p = str(file_path or "").strip()
    if not p or not os.path.exists(p):
        return None
    try:
        if p.lower().endswith(".dcm"):
            ds = pydicom.dcmread(p)
            arr = ds.pixel_array
            try:
                if getattr(ds, "PhotometricInterpretation", None) == "MONOCHROME1":
                    arr = np.amax(arr) - arr
            except Exception:
                pass
            arr = arr.astype(np.float32, copy=False)
            mx = float(np.max(arr)) if arr.size else 0.0
            if mx <= 0.0:
                return None
            out = np.clip((arr / mx) * 255.0, 0.0, 255.0).astype(np.uint8)
            return out
        img = Image.open(p).convert("L")
        return np.array(img, dtype=np.uint8)
    except Exception as e:
        logging.debug(f"Warning getting shape: {e}")
        return None

def _worker_compute_prev_to_current_affine(prev_gray: np.ndarray, cur_gray: np.ndarray):
    if cv2 is None:
        return None
    if prev_gray is None or cur_gray is None:
        return None
    if prev_gray.ndim != 2 or cur_gray.ndim != 2:
        return None
    try:
        prev_h, prev_w = prev_gray.shape[:2]
        cur_h, cur_w = cur_gray.shape[:2]
    except Exception:
        return None
    if prev_w <= 0 or prev_h <= 0 or cur_w <= 0 or cur_h <= 0:
        return None

    def _resize(img: np.ndarray, max_dim: int = 900):
        h, w = img.shape[:2]
        s = 1.0
        d = float(max(h, w))
        if d > float(max_dim) and d > 0:
            s = float(max_dim) / d
        if s < 0.999:
            nw = max(32, int(round(w * s)))
            nh = max(32, int(round(h * s)))
            try:
                out = cv2.resize(img, (nw, nh), interpolation=cv2.INTER_AREA)
            except Exception:
                out = img
                s = 1.0
            return out, float(s)
        return img, float(s)

    prev_s, s_prev = _resize(prev_gray)
    cur_s, s_cur = _resize(cur_gray)
    try:
        prev_f = prev_s.astype(np.float32) / 255.0
        cur_f = cur_s.astype(np.float32) / 255.0
    except Exception:
        return None
    warp = np.eye(2, 3, dtype=np.float32)
    try:
        criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 60, 1e-6)
        cv2.findTransformECC(cur_f, prev_f, warp, cv2.MOTION_AFFINE, criteria)
    except Exception:
        return None

    try:
        M = np.eye(3, dtype=np.float64)
        M[:2, :] = warp.astype(np.float64)
        S_prev = np.eye(3, dtype=np.float64)
        S_cur_inv = np.eye(3, dtype=np.float64)
        S_prev[0, 0] = float(s_prev)
        S_prev[1, 1] = float(s_prev)
        S_cur_inv[0, 0] = 1.0 / float(s_cur)
        S_cur_inv[1, 1] = 1.0 / float(s_cur)
        full = S_cur_inv @ M @ S_prev
        return full[:2, :]
    except Exception:
        return None

def _worker_build_change_overlay_pixmap(prev_gray: np.ndarray, cur_gray: np.ndarray, M, percentile: float, alpha: float):
    if prev_gray is None or cur_gray is None:
        return None, None
    try:
        ch, cw = cur_gray.shape[:2]
    except Exception:
        return None, None
    if cw <= 0 or ch <= 0:
        return None, None

    prev_warp = None
    if cv2 is not None and M is not None:
        try:
            prev_warp = cv2.warpAffine(prev_gray, M.astype(np.float32), (int(cw), int(ch)), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)
        except Exception as e:
            logging.debug(f"Warning warping affine: {e}")
            prev_warp = None
    if prev_warp is None:
        try:
            prev_warp = np.array(Image.fromarray(prev_gray).resize((int(cw), int(ch))), dtype=np.uint8)
        except Exception:
            return None, None

    try:
        if cv2 is not None:
            diff = cv2.absdiff(cur_gray, prev_warp)
            diff = cv2.GaussianBlur(diff, (0, 0), 2.0)
        else:
            diff = np.abs(cur_gray.astype(np.int16) - prev_warp.astype(np.int16)).astype(np.uint8)
    except Exception:
        return None, None

    try:
        pctl = float(percentile)
        pctl = max(50.0, min(99.5, pctl))
        thr = float(np.percentile(diff, pctl))
    except Exception:
        thr = 30.0

    try:
        maxv = float(np.max(diff)) if diff.size else 0.0
    except Exception:
        maxv = 0.0
    if maxv <= thr + 1.0:
        return None, None

    try:
        heat = (diff.astype(np.float32) - float(thr)) / float(maxv - thr)
        heat = np.clip(heat, 0.0, 1.0)
        heat_u8 = (heat * 255.0).astype(np.uint8)
    except Exception:
        return None, None

    try:
        if cv2 is not None:
            col = cv2.applyColorMap(heat_u8, cv2.COLORMAP_JET)
            rgb = cv2.cvtColor(col, cv2.COLOR_BGR2RGB)
        else:
            r = heat_u8
            g = np.clip((heat_u8.astype(np.int16) * 2), 0, 255).astype(np.uint8)
            b = (255 - heat_u8)
            rgb = np.dstack([r, g, b]).astype(np.uint8)
    except Exception:
        return None, None

    try:
        base_alpha = float(alpha)
        base_alpha = max(0.05, min(0.95, base_alpha))
        a = (heat * (base_alpha * 255.0)).astype(np.uint8)
        rgba = np.dstack([rgb, a]).astype(np.uint8)
        fmt = QImage.Format.Format_RGBA8888 if hasattr(QImage.Format, "Format_RGBA8888") else QImage.Format.Format_ARGB32
        qimg = QImage(rgba.data, int(cw), int(ch), int(4 * cw), fmt).copy()
        return qimg, heat
    except Exception:
        return None, None

class ChangeOverlayWorker(QThread):
    finished_signal = pyqtSignal(object, object, str)

    def __init__(self, prev_path, cur_path, percentile, alpha, cache_key):
        super().__init__()
        self.prev_path = prev_path
        self.cur_path = cur_path
        self.percentile = percentile
        self.alpha = alpha
        self.cache_key = cache_key

    def run(self):
        try:
            prev_gray = _worker_load_gray_uint8_for_path(self.prev_path)
            cur_gray = _worker_load_gray_uint8_for_path(self.cur_path)
            
            if prev_gray is None or cur_gray is None:
                self.finished_signal.emit(None, None, self.cache_key)
                return

            M = _worker_compute_prev_to_current_affine(prev_gray, cur_gray)
            qimg, heat = _worker_build_change_overlay_pixmap(prev_gray, cur_gray, M, self.percentile, self.alpha)
            
            self.finished_signal.emit(qimg, heat, self.cache_key)
        except Exception as e:
            print(f"Change Overlay Worker Error: {e}")
            self.finished_signal.emit(None, None, self.cache_key)

def _dpapi_unprotect_bytes(raw: bytes) -> bytes:
    if os.name != "nt":
        raise RuntimeError("DPAPI διαθέσιμο μόνο σε Windows.")
    if raw is None:
        raw = b""
    in_blob = _DATA_BLOB()
    in_blob.cbData = len(raw)
    in_blob.pbData = ctypes.cast(ctypes.create_string_buffer(raw, len(raw)), ctypes.POINTER(ctypes.c_byte))
    out_blob = _DATA_BLOB()
    if not ctypes.windll.crypt32.CryptUnprotectData(ctypes.byref(in_blob), None, None, None, None, 0, ctypes.byref(out_blob)):
        raise RuntimeError("CryptUnprotectData απέτυχε.")
    try:
        return ctypes.string_at(out_blob.pbData, out_blob.cbData)
    finally:
        try:
            ctypes.windll.kernel32.LocalFree(out_blob.pbData)
        except Exception as e:
            logging.error(f"DPAPI Error: {e}")
            pass

def _dpapi_encrypt_text_to_b64(text: str) -> str:
    s = str(text or "")
    if not s:
        return ""
    enc = _dpapi_protect_bytes(s.encode("utf-8"))
    return base64.b64encode(enc).decode("ascii")

def _dpapi_decrypt_b64_to_text(b64: str) -> str:
    s = str(b64 or "").strip()
    if not s:
        return ""
    raw = base64.b64decode(s.encode("ascii"))
    dec = _dpapi_unprotect_bytes(raw)
    return dec.decode("utf-8", errors="replace")

def _fmt_ts_for_name() -> str:
    try:
        return datetime.now().strftime("%Y%m%d_%H%M%S")
    except Exception:
        return "now"

class PropertySelectionDialog(QDialog):
    def __init__(self, property_key, parent=None, title="Διαχείριση"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.property_key = property_key
        self.settings_dir = Path("data/settings")
        self.settings_dir.mkdir(parents=True, exist_ok=True)
        self.settings_file = self.settings_dir / f"{self.property_key}.json"
        
        self.layout = QVBoxLayout(self)
        
        self.list_widget = QListWidget()
        self.layout.addWidget(self.list_widget)
        
        self.load_properties()
        
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Προσθήκη")
        add_btn.clicked.connect(self.add_property)
        remove_btn = QPushButton("Αφαίρεση")
        remove_btn.clicked.connect(self.remove_property)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(remove_btn)
        self.layout.addLayout(btn_layout)
        
        bbox = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        bbox.accepted.connect(self.save_properties)
        bbox.rejected.connect(self.reject)
        self.layout.addWidget(bbox)

    def load_properties(self):
        self.list_widget.clear()
        if self.settings_file.exists():
            try:
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    props = json.load(f)
                    for p in props:
                        self.list_widget.addItem(p)
            except Exception:
                pass
        else:
            # Default values if no file exists
            defaults = []
            if self.property_key == "custom_statuses":
                defaults = ["Τερηδόνα", "Σφράγισμα", "Απονεύρωση", "Εμφύτευμα", "Γέφυρα", "Στεφάνη"]
            elif self.property_key == "other_properties":
                defaults = ["Επείγον", "Παρακολούθηση", "Χειρουργείο"]
            
            for d in defaults:
                self.list_widget.addItem(d)

    def add_property(self):
        text, ok = QInputDialog.getText(self, "Προσθήκη", "Νέα ιδιότητα:")
        if ok and text:
            self.list_widget.addItem(text)

    def remove_property(self):
        row = self.list_widget.currentRow()
        if row >= 0:
            self.list_widget.takeItem(row)

    def save_properties(self):
        props = []
        for i in range(self.list_widget.count()):
            props.append(self.list_widget.item(i).text())
        
        try:
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(props, f, indent=4, ensure_ascii=False)
            self.accept()
        except Exception as e:
            QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία αποθήκευσης: {e}")

class PostAnalysisConfirmDialog(QDialog):
    def __init__(self, parent=None, title: str = "Επιβεβαίωση", message: str = ""):
        super().__init__(parent)
        self.setWindowTitle(str(title or "Επιβεβαίωση"))
        self._choice = None

        layout = QVBoxLayout(self)
        msg_lbl = QLabel(str(message or ""))
        msg_lbl.setWordWrap(True)
        layout.addWidget(msg_lbl)

        group = QButtonGroup(self)
        self.yes_rb = QRadioButton("Ναι")
        self.no_rb = QRadioButton("Όχι")
        group.addButton(self.yes_rb)
        group.addButton(self.no_rb)
        self.yes_rb.setChecked(True)

        layout.addWidget(self.yes_rb)
        layout.addWidget(self.no_rb)

        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        btns.accepted.connect(self._accept_choice)
        btns.rejected.connect(self.reject)
        layout.addWidget(btns)

    def _accept_choice(self):
        try:
            self._choice = True if self.yes_rb.isChecked() else False
        except Exception:
            self._choice = None
        self.accept()

    def get_choice(self):
        return self._choice

class AnalysisTextDialog(QDialog):
    def __init__(self, parent=None, title: str = "Κείμενο Ανάλυσης"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(640, 720)
        layout = QVBoxLayout(self)
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        layout.addWidget(self.text_edit, 1)

        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        btns.rejected.connect(self.reject)
        btns.accepted.connect(self.accept)
        layout.addWidget(btns)

    def set_text(self, text: str):
        try:
            self.text_edit.setPlainText(str(text or ""))
        except Exception:
            pass

class ToothDetailsDialog(QDialog):
    def __init__(self, parent=None, fdi=None, statuses=None, notes="", mode="edit", is_bypassed=False, implant=None, show_grid_bypass=False):
        super().__init__(parent)
        self.setWindowTitle("Λεπτομέρειες Δοντιού" if mode == "edit" else "Προσθήκη Δοντιού")
        self.resize(400, 560)
        self.mode = mode
        self.show_grid_bypass = show_grid_bypass
        
        layout = QVBoxLayout(self)
        
        # 1. Tooth ID & Info
        info_group = QVBoxLayout()
        
        # FDI Input
        fdi_layout = QHBoxLayout()
        fdi_layout.addWidget(QLabel("Αναγνωριστικό (FDI):"))
        
        # Create combo for valid FDI numbers
        self.fdi_combo = QComboBox()
        self.fdi_combo.setEditable(True)
        # Populate with standard FDI numbers
        valid_fdis = []
        for q in range(1, 5):
            for t in range(1, 9):
                valid_fdis.append(f"{q}{t}")
        # Add deciduous? Maybe later.
        self.fdi_combo.addItems(valid_fdis)
        
        if fdi:
            self.fdi_combo.setCurrentText(str(fdi))
            
        self.fdi_combo.currentTextChanged.connect(self.update_info)
        fdi_layout.addWidget(self.fdi_combo)
        info_group.addLayout(fdi_layout)

        # Read-only Info
        self.pos_label = QLabel("Θέση: -")
        self.type_label = QLabel("Τύπος: -")
        info_group.addWidget(self.pos_label)
        info_group.addWidget(self.type_label)
        
        layout.addLayout(info_group)
        layout.addWidget(QSplitter(Qt.Orientation.Horizontal)) # Separator
        
        # 2. Statuses
        layout.addWidget(QLabel("Κατάσταση:"))
        self.status_list = QListWidget()
        
        # Get available statuses from parent if possible
        available_statuses = []
        if parent and hasattr(parent, "get_available_statuses"):
            available_statuses = parent.get_available_statuses()
        else:
            available_statuses = ["Τερηδόνα", "Σφράγισμα", "Απονεύρωση", "Εμφύτευμα", "Γέφυρα", "Στεφάνη", "Εγκλεισμός", "Ριζικό Υπόλειμμα", "Ελλείπον", "Υγιές"]
            
        current_statuses = statuses or []
        
        for status in available_statuses:
            item = QListWidgetItem(status)
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(Qt.CheckState.Checked if status in current_statuses else Qt.CheckState.Unchecked)
            self.status_list.addItem(item)
            
        layout.addWidget(self.status_list)

        implant_state = implant if isinstance(implant, dict) else {}
        try:
            implant_present = bool(implant_state.get("present"))
        except Exception:
            implant_present = False
        try:
            implant_type = str(implant_state.get("type") or "")
        except Exception:
            implant_type = ""
        try:
            if not implant_present and any(str(s).strip() == "Εμφύτευμα" for s in (statuses or [])):
                implant_present = True
        except Exception:
            pass

        layout.addWidget(QLabel("Εμφύτευμα:"))
        self.implant_cb = QCheckBox("Παρόν")
        self.implant_cb.setChecked(bool(implant_present))
        layout.addWidget(self.implant_cb)
        self.implant_type_edit = QLineEdit()
        self.implant_type_edit.setPlaceholderText("Τύπος/Σημείωση (προαιρετικό)")
        self.implant_type_edit.setText(str(implant_type or ""))
        self.implant_type_edit.setEnabled(bool(implant_present))
        try:
            self.implant_cb.toggled.connect(lambda v: self.implant_type_edit.setEnabled(bool(v)))
        except Exception:
            pass
        layout.addWidget(self.implant_type_edit)
        
        # 3. Notes
        layout.addWidget(QLabel("Σχόλια / Σημειώσεις:"))
        self.notes_edit = QTextEdit()
        self.notes_edit.setPlainText(notes or "")
        self.notes_edit.setMaximumHeight(100)
        layout.addWidget(self.notes_edit)
        
        # 4. Timestamp (Read-only update)
        self.timestamp = datetime.now()
        layout.addWidget(QLabel(f"Ημερομηνία Ενημέρωσης: {self.timestamp.strftime('%d/%m/%Y %H:%M')}"))
        
        if self.show_grid_bypass:
             self.bypass_grid_cb = QCheckBox("Παράκαμψη Αυτόματης Ταξινόμησης (Grid)")
             self.bypass_grid_cb.setToolTip("Αν επιλεγεί, το σύστημα δεν θα προσπαθήσει να επαναϋπολογίσει το FDI αυτού του δοντιού με βάση τη θέση του.")
             if is_bypassed:
                 self.bypass_grid_cb.setChecked(True)
             layout.addWidget(self.bypass_grid_cb)
        
        # Buttons
        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        btns.accepted.connect(self.validate_and_accept)
        btns.rejected.connect(self.reject)
        layout.addWidget(btns)
        
        self.update_info(self.fdi_combo.currentText())

    def update_info(self, fdi_text):
        pos, type_ = self.get_tooth_info(fdi_text)
        self.pos_label.setText(f"Θέση: {pos}")
        self.type_label.setText(f"Τύπος: {type_}")

    def get_tooth_info(self, fdi_str):
        if not fdi_str or not fdi_str.isdigit():
            return "-", "-"
        try:
            fdi = int(fdi_str)
            quadrant = fdi // 10
            tooth = fdi % 10
            
            if quadrant == 1: pos = "Άνω Δεξιά"
            elif quadrant == 2: pos = "Άνω Αριστερά"
            elif quadrant == 3: pos = "Κάτω Αριστερά"
            elif quadrant == 4: pos = "Κάτω Δεξιά"
            else: pos = "-"
            
            if tooth in [1, 2]: type_ = "Τομείς (Κεντρικός/Πλάγιος)"
            elif tooth == 3: type_ = "Κυνόδοντας"
            elif tooth in [4, 5]: type_ = "Προγόμφιος"
            elif tooth in [6, 7, 8]: type_ = "Γομφίος"
            else: type_ = "-"
            
            return pos, type_
        except:
            return "-", "-"

    def validate_and_accept(self):
        fdi = self.fdi_combo.currentText()
        if not fdi.isdigit() or len(fdi) != 2:
            QMessageBox.warning(self, "Μη έγκυρο FDI", "Παρακαλώ εισάγετε έναν έγκυρο διψήφιο αριθμό δοντιού (FDI).")
            return
            
        # Optional: Check if FDI is within valid ranges (11-18, 21-28, 31-38, 41-48, etc)
        # Allowing loose validation for now
        
        self.accept()

    def get_data(self):
        statuses = []
        for i in range(self.status_list.count()):
            item = self.status_list.item(i)
            if item.checkState() == Qt.CheckState.Checked:
                statuses.append(item.text())

        implant_present = False
        implant_type = ""
        try:
            implant_present = bool(self.implant_cb.isChecked())
        except Exception:
            implant_present = False
        try:
            implant_type = str(self.implant_type_edit.text() or "").strip()
        except Exception:
            implant_type = ""
        if implant_present and "Εμφύτευμα" not in statuses:
            statuses.append("Εμφύτευμα")
        if (not implant_present) and ("Εμφύτευμα" in statuses):
            statuses = [s for s in statuses if str(s).strip() != "Εμφύτευμα"]
        
        bypass_val = False
        try:
             if self.show_grid_bypass and hasattr(self, "bypass_grid_cb"):
                 bypass_val = self.bypass_grid_cb.isChecked()
        except:
             pass

        return {
            "fdi": self.fdi_combo.currentText(),
            "statuses": statuses,
            "notes": self.notes_edit.toPlainText(),
            "timestamp": self.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
            "implant": {"present": bool(implant_present), "type": implant_type},
            "updated_by": str(getpass.getuser() or "").strip() or None,
            "bypass_grid": bypass_val,
        }

class EditableRectItem(QGraphicsRectItem):
    def __init__(self, *args, **kwargs):
        self.on_change_callback = kwargs.pop('on_change_callback', None)
        x = kwargs.pop('x', None)
        y = kwargs.pop('y', None)
        w = kwargs.pop('w', None)
        h = kwargs.pop('h', None)
        if x is not None and y is not None and w is not None and h is not None:
            super().__init__(x, y, w, h, *args, **kwargs)
        else:
            super().__init__(*args, **kwargs)

        self.setBrush(QColor(0, 0, 0, 0)) 
        self.setPen(QPen(Qt.PenStyle.NoPen)) 
        self.setZValue(100) # Ensure teeth are always on top of other items (lines, zones)
        self.setFlag(QGraphicsRectItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsRectItem.GraphicsItemFlag.ItemIsSelectable, True)
        self.setFlag(QGraphicsRectItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.text_item = None 
        self.is_moving_linked = False
        self._status_badge = None
        self._notes = ""
        self._last_updated = ""
        self._last_updated_by = ""
        self._implant = {"present": False, "type": ""}
        self.label_offset = None
        self.label_offset_user = False
        self._bypass_grid = False
        self.ghost_item = None

    def get_bypass_grid(self):
        return getattr(self, "_bypass_grid", False)

    def set_bypass_grid(self, val):
        self._bypass_grid = bool(val)

    def get_notes(self):
        return self._notes

    def set_notes(self, notes):
        self._notes = notes

    def get_last_updated(self):
        return self._last_updated

    def set_last_updated(self, timestamp):
        self._last_updated = timestamp

    def get_last_updated_by(self):
        return self._last_updated_by

    def set_last_updated_by(self, user_id):
        self._last_updated_by = str(user_id or "").strip()

    def get_implant(self):
        v = getattr(self, "_implant", None)
        return v if isinstance(v, dict) else {"present": False, "type": ""}

    def set_implant(self, implant):
        if not isinstance(implant, dict):
            implant = {}
        try:
            present = bool(implant.get("present"))
        except Exception:
            present = False
        try:
            it = str(implant.get("type") or "")
        except Exception:
            it = ""
        self._implant = {"present": bool(present), "type": str(it)}

    def itemChange(self, change, value):
        if change == QGraphicsRectItem.GraphicsItemChange.ItemPositionChange:
            if self.scene() and self.text_item and not self.is_moving_linked:
                self.text_item.is_moving_linked = True
                new_pos = value
                old_pos = self.pos()
                delta = new_pos - old_pos
                self.text_item.setPos(self.text_item.pos() + delta)
                self.text_item.is_moving_linked = False
            # Do NOT call callback here to avoid recreating items during drag
        return super().itemChange(change, value)

    def mousePressEvent(self, event):
        # Store start position to detect movement
        self._drag_start_pos = self.pos()
        
        # --- Ghost Creation Logic (Start) ---
        if self.scene() and self.text_item and not self.ghost_item:
            try:
                # Create ghost only if we don't have one
                # This represents the ORIGINAL position before user started moving it
                ghost = QGraphicsTextItem(self.text_item.toPlainText())
                ghost.setFont(self.text_item.font())
                # Use the same color as the text but semi-transparent (ghostly)
                # White is often invisible on X-rays (bones are white).
                # We use the text color (usually Red) or a high-contrast fallback.
                orig_color = self.text_item.defaultTextColor()
                if orig_color.lightness() > 200: # If too bright (white), force a darker contrast color for ghost
                     ghost_color = QColor(255, 0, 0) # Red
                else:
                     ghost_color = QColor(orig_color)
                
                ghost_color.setAlpha(180) # More visible (was 140)
                ghost.setDefaultTextColor(ghost_color) 
                ghost.setPos(self.text_item.scenePos())
                ghost.setScale(self.text_item.scale())
                # Ensure it's behind the moving item but visible
                ghost.setZValue(self.text_item.zValue() - 0.1) 
                ghost.setOpacity(0.6)
                self.scene().addItem(ghost)
                self.ghost_item = ghost
            except Exception as e:
                print(f"Ghost creation failed: {e}")
        # --- Ghost Creation Logic (End) ---

        try:
            viewer = self._get_viewer_widget()
            if viewer is not None:
                viewer._trace_log(
                    "rect_drag_start",
                    {
                        "fdi": self.get_label_text(),
                        "pos": [float(self.pos().x()), float(self.pos().y())],
                    },
                )
        except Exception:
            pass
        
        # Visual feedback for dragging
        self.setPen(QPen(QColor("cyan"), 2, Qt.PenStyle.DashLine))
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        # Restore visual feedback
        self.setPen(QPen(Qt.PenStyle.NoPen))
        super().mouseReleaseEvent(event)
        
        # Check if moved significantly (> 0.1 pixels to ignore micro-shifts)
        if hasattr(self, '_drag_start_pos'):
            diff = self.pos() - self._drag_start_pos
            if diff.manhattanLength() > 0.1:
                try:
                    viewer = self._get_viewer_widget()
                    if viewer is not None:
                        viewer._trace_log(
                            "rect_moved",
                            {
                                "fdi": self.get_label_text(),
                                "from": [float(self._drag_start_pos.x()), float(self._drag_start_pos.y())],
                                "to": [float(self.pos().x()), float(self.pos().y())],
                                "delta": [float(diff.x()), float(diff.y())],
                            },
                        )
                except Exception:
                    pass
                try:
                    viewer = self._get_viewer_widget()
                    if viewer and bool(getattr(viewer, "snap_annotations_to_grid_on_drop", True)) and hasattr(viewer, "_snap_rect_item_to_grid_slot"):
                        viewer._snap_rect_item_to_grid_slot(self)
                except Exception:
                    pass
        
        # Trigger recalculation on drop
        if self.on_change_callback:
            self.on_change_callback()

    def mouseDoubleClickEvent(self, event):
        self.open_details_dialog()
        super().mouseDoubleClickEvent(event)

    def open_details_dialog(self):
        viewer = self._get_viewer_widget()
        label_text = self.get_label_text()
        statuses = self.get_statuses()
        notes = self.get_notes()
        is_bypassed = self.get_bypass_grid()

        dialog = ToothDetailsDialog(viewer, fdi=label_text, statuses=statuses, notes=notes, mode="edit", implant=self.get_implant(), is_bypassed=is_bypassed, show_grid_bypass=True)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            
            # Update FDI Label if changed
            if data["fdi"] != label_text and self.text_item:
                self.text_item.setPlainText(data["fdi"])
                # Trigger recalculate if needed? 
                # Actually, changing text usually triggers callback if set.
                # But here we set it directly.
                if self.on_change_callback:
                    self.on_change_callback()

            # Update Statuses
            self.set_statuses(data["statuses"])
            
            # Update Notes & Timestamp & Bypass
            self.set_notes(data["notes"])
            self.set_last_updated(data["timestamp"])
            self.set_bypass_grid(data.get("bypass_grid", False))
            try:
                self.set_last_updated_by(data.get("updated_by"))
            except Exception:
                pass
            
            try:
                self.set_implant(data.get("implant"))
            except Exception:
                pass
            
            QMessageBox.information(viewer, "Επιτυχία", "Οι πληροφορίες του δοντιού ενημερώθηκαν επιτυχώς.")
 
    def contextMenuEvent(self, event):
        menu = QMenu()
        
        details_action = menu.addAction("Λεπτομέρειες / Επεξεργασία...")
        menu.addSeparator()
        
        status_menu = menu.addMenu("Κατάσταση")
        bulk_menu = menu.addMenu("Μαζική Επεξεργασία")

        current_statuses = self.data(Qt.ItemDataRole.UserRole) or []
        if not isinstance(current_statuses, list):
            current_statuses = []

        viewer_widget = self._get_viewer_widget()

        grouped = None
        if viewer_widget and hasattr(viewer_widget, "get_available_statuses_grouped"):
            try:
                grouped = viewer_widget.get_available_statuses_grouped()
            except Exception:
                grouped = None

        if not grouped:
            statuses = ["Τερηδόνα", "Σφράγισμα", "Απονεύρωση", "Εμφύτευμα", "Γέφυρα", "Στεφάνη", "Εγκλεισμός", "Ριζικό Υπόλειμμα", "Ελλείπον"]
            settings_file = Path("data/settings/custom_statuses.json")
            if settings_file.exists():
                try:
                    with open(settings_file, 'r', encoding='utf-8') as f:
                        loaded = json.load(f)
                        if loaded:
                            statuses = list(dict.fromkeys([*loaded, *statuses]))
                except Exception:
                    pass
            grouped = {"Όλα": statuses}

        for group_name, statuses in grouped.items():
            target_menu = status_menu if group_name == "Όλα" else status_menu.addMenu(group_name)
            for status in statuses:
                action = target_menu.addAction(status)
                action.setCheckable(True)
                if status in current_statuses:
                    action.setChecked(True)
                action.triggered.connect(functools.partial(self._toggle_status_and_refresh, status))

        apply_to_similar_action = bulk_menu.addAction("Εφαρμογή σε Παρόμοια")
        edit_similar_action = bulk_menu.addAction("Μαζική Επεξεργασία Παρόμοιων…")
        edit_selected_action = bulk_menu.addAction("Μαζική Επεξεργασία Επιλεγμένων…")
        clear_statuses_action = bulk_menu.addAction("Καθαρισμός Καταστάσεων")
            
        delete_action = menu.addAction("Διαγραφή")
        action = menu.exec(event.screenPos())
        
        if action == details_action:
            self.open_details_dialog()
        elif action == apply_to_similar_action:
            if viewer_widget and hasattr(viewer_widget, "apply_statuses_to_similar"):
                viewer_widget.apply_statuses_to_similar(self, self.get_statuses())
        elif action == edit_similar_action:
            if viewer_widget and hasattr(viewer_widget, "open_bulk_status_editor_for_similar"):
                viewer_widget.open_bulk_status_editor_for_similar(self)
        elif action == edit_selected_action:
            if viewer_widget and hasattr(viewer_widget, "open_bulk_status_editor_for_selected"):
                viewer_widget.open_bulk_status_editor_for_selected()
        elif action == clear_statuses_action:
            targets = [self]
            try:
                if viewer_widget and getattr(viewer_widget, "scene", None):
                    selected = [i for i in viewer_widget.scene.selectedItems() if isinstance(i, EditableRectItem)]
                    if selected and self in selected:
                        targets = selected
            except Exception:
                pass
            ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            for t in targets:
                try:
                    t.set_statuses([])
                    t.set_last_updated(ts)
                except Exception:
                    pass
        elif action == delete_action:
            scene = self.scene()
            if scene:
                if self.text_item and self.text_item.scene() == scene:
                    scene.removeItem(self.text_item)
                scene.removeItem(self)
                
                # Notify viewer to update results efficiently
                viewer_widget = self._get_viewer_widget()
                if viewer_widget and hasattr(viewer_widget, "debounced_recalculate_fdi"):
                    viewer_widget.debounced_recalculate_fdi()
                elif viewer_widget and hasattr(viewer_widget, "recalculate_fdi"):
                    # Fallback if debounced method not available
                    viewer_widget.recalculate_fdi()

    def _get_viewer_widget(self):
        scene = self.scene()
        if not scene:
            return None
        views = scene.views()
        if not views:
            return None
        view = views[0]
        return getattr(view, "viewer_widget", None)

    def get_label_text(self):
        if self.text_item and hasattr(self.text_item, "toPlainText"):
            try:
                return str(self.text_item.toPlainText()).strip()
            except Exception:
                return None
        return None

    def get_statuses(self):
        statuses = self.data(Qt.ItemDataRole.UserRole) or []
        if not isinstance(statuses, list):
            return []
        return [str(s) for s in statuses if str(s).strip()]

    def set_statuses(self, statuses, notify=True):
        try:
            prev_statuses = self.get_statuses()
        except Exception:
            prev_statuses = []
        if not isinstance(statuses, list):
            statuses = []
        statuses = [str(s) for s in statuses if str(s).strip()]
        self.setData(Qt.ItemDataRole.UserRole, statuses)
        self.setToolTip(", ".join(statuses))
        self._apply_status_visuals()
        if notify:
            viewer_widget = self._get_viewer_widget()
            try:
                if viewer_widget is not None:
                    viewer_widget._trace_log(
                        "statuses_changed",
                        {"fdi": self.get_label_text(), "from": list(prev_statuses or []), "to": list(statuses or [])},
                    )
            except Exception:
                pass
            try:
                ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                self.set_last_updated(ts)
            except Exception:
                pass
            try:
                if viewer_widget and hasattr(viewer_widget, "_get_current_user_id"):
                    self.set_last_updated_by(viewer_widget._get_current_user_id())
            except Exception:
                pass
            try:
                if any(str(s).strip() == "Εμφύτευμα" for s in statuses):
                    cur = self.get_implant()
                    if not bool((cur or {}).get("present")):
                        self.set_implant({"present": True, "type": str((cur or {}).get("type") or "")})
            except Exception:
                pass
            if viewer_widget and hasattr(viewer_widget, "on_annotation_modified"):
                viewer_widget.on_annotation_modified()

    def _toggle_status_and_refresh(self, status):
        status = str(status).strip()
        if not status:
            return
        current = self.get_statuses()
        if status in current:
            current = [s for s in current if s != status]
        else:
            current.append(status)
        self.set_statuses(current)

    def _apply_status_visuals(self):
        viewer_widget = self._get_viewer_widget()
        if viewer_widget and hasattr(viewer_widget, "apply_status_visuals_to_rect"):
            viewer_widget.apply_status_visuals_to_rect(self)
            return

        statuses = self.get_statuses()
        if statuses:
            pen = QPen(QColor("yellow"), 2)
            pen.setCosmetic(True)
            self.setPen(pen)
            self.setBrush(QBrush(QColor(255, 255, 0, 30)))
        else:
            self.setBrush(QColor(0, 0, 0, 0))

class EditableTextItem(QGraphicsTextItem):
    def __init__(self, text, rect_item=None, on_change_callback=None, *args, **kwargs):
        super().__init__(text, *args, **kwargs)
        self.rect_item = rect_item
        self.on_change_callback = on_change_callback
        if self.rect_item:
            self.rect_item.text_item = self
        self.setFlag(QGraphicsTextItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsTextItem.GraphicsItemFlag.ItemIsSelectable, True)
        self.setFlag(QGraphicsTextItem.GraphicsItemFlag.ItemIsFocusable, True)
        self.setFlag(QGraphicsTextItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        self.is_moving_linked = False
        
        self.setDefaultTextColor(QColor("red"))
        font = self.font()
        font.setBold(True)
        font.setPointSize(8)
        self.setFont(font)

    def itemChange(self, change, value):
        if change == QGraphicsTextItem.GraphicsItemChange.ItemPositionChange:
            if self.scene() and self.rect_item and not self.is_moving_linked:
                try:
                    r = self.rect_item.rect()
                    box_tl = self.rect_item.scenePos() + QPointF(float(r.x()), float(r.y()))
                    self.rect_item.label_offset = QPointF(float(value.x() - box_tl.x()), float(value.y() - box_tl.y()))
                    self.rect_item.label_offset_user = True
                except Exception:
                    pass
        return super().itemChange(change, value)

    def mousePressEvent(self, event):
        self._drag_start_pos = self.pos()
        
        # --- Ghost Creation Logic (New) ---
        try:
            target_holder = self.rect_item if self.rect_item else self
            if self.scene() and not getattr(target_holder, 'ghost_item', None):
                ghost = QGraphicsTextItem(self.toPlainText())
                ghost.setFont(self.font())
                
                orig_color = self.defaultTextColor()
                # Force high visibility color (Red) for ghosts to ensure contrast on X-rays
                ghost_color = QColor(255, 0, 0)
                
                ghost_color.setAlpha(220) # Higher opacity
                ghost.setDefaultTextColor(ghost_color) 
                ghost.setPos(self.scenePos())
                ghost.setScale(self.scale())
                ghost.setZValue(self.zValue() - 0.1) 
                ghost.setOpacity(0.85) # Higher opacity
                
                self.scene().addItem(ghost)
                target_holder.ghost_item = ghost
                
                # Log ghost creation for trace analysis
                if hasattr(self.rect_item, "_get_viewer_widget"):
                    v = self.rect_item._get_viewer_widget()
                    if v:
                        v._trace_log("ghost_created", {
                            "fdi": self.toPlainText(),
                            "pos": [self.scenePos().x(), self.scenePos().y()]
                        })

        except Exception as e:
            print(f"Text ghost creation failed: {e}")
        # ----------------------------------

        try:
            viewer = None
            if self.rect_item is not None and hasattr(self.rect_item, "_get_viewer_widget"):
                viewer = self.rect_item._get_viewer_widget()
            if viewer is not None:
                viewer._trace_log(
                    "label_drag_start",
                    {
                        "fdi": self.rect_item.get_label_text() if self.rect_item is not None else None,
                        "pos": [float(self.pos().x()), float(self.pos().y())],
                    },
                )
        except Exception:
            pass
        self.setDefaultTextColor(QColor("cyan"))
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        # We don't want to revert to red if we have a custom color set
        # self.setDefaultTextColor(QColor("red")) 
        super().mouseReleaseEvent(event)
        try:
            if hasattr(self, "_drag_start_pos") and self.rect_item:
                diff = self.pos() - self._drag_start_pos
                if diff.manhattanLength() > 0.01:
                    try:
                        viewer = None
                        if self.rect_item is not None and hasattr(self.rect_item, "_get_viewer_widget"):
                            viewer = self.rect_item._get_viewer_widget()
                        if viewer is not None:
                            viewer._trace_log(
                                "label_moved",
                                {
                                    "fdi": self.rect_item.get_label_text() if self.rect_item is not None else None,
                                    "from": [float(self._drag_start_pos.x()), float(self._drag_start_pos.y())],
                                    "to": [float(self.pos().x()), float(self.pos().y())],
                                    "delta": [float(diff.x()), float(diff.y())],
                                },
                            )
                    except Exception:
                        pass
                    r = self.rect_item.rect()
                    box_tl = self.rect_item.scenePos() + QPointF(float(r.x()), float(r.y()))
                    self.rect_item.label_offset = QPointF(float(self.pos().x() - box_tl.x()), float(self.pos().y() - box_tl.y()))
                    self.rect_item.label_offset_user = True
        except Exception:
            pass

        if self.on_change_callback:
            self.on_change_callback()

    def mouseDoubleClickEvent(self, event):
        if self.rect_item and hasattr(self.rect_item, "open_details_dialog"):
            self.rect_item.open_details_dialog()
            return
            
        if self.textInteractionFlags() == Qt.TextInteractionFlag.NoTextInteraction:
            try:
                self._edit_original_text = str(self.toPlainText())
            except Exception:
                self._edit_original_text = None
            self.setTextInteractionFlags(Qt.TextInteractionFlag.TextEditorInteraction)
            self.setFocus(Qt.FocusReason.MouseFocusReason)
            super().mouseDoubleClickEvent(event)
        else:
            super().mouseDoubleClickEvent(event)

    def focusOutEvent(self, event):
        self.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        cursor = self.textCursor()
        cursor.clearSelection()
        self.setTextCursor(cursor)
        try:
            original = getattr(self, "_edit_original_text", None)
            current = str(self.toPlainText())
            if original is not None and current != original:
                if self.rect_item and hasattr(self.rect_item, "set_last_updated"):
                    self.rect_item.set_last_updated(datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        except Exception:
            pass
        if self.on_change_callback:
            self.on_change_callback()
        super().focusOutEvent(event)

    def contextMenuEvent(self, event):
        menu = QMenu()
        delete_action = menu.addAction("Διαγραφή")
        action = menu.exec(event.screenPos())
        if action == delete_action:
            scene = self.scene()
            if scene:
                scene.removeItem(self)
                if self.rect_item and self.rect_item.scene() == scene:
                    scene.removeItem(self.rect_item)


class ScanCuspDot(QGraphicsEllipseItem):
    def __init__(self, radius=6.0, viewer_widget=None):
        super().__init__(-float(radius), -float(radius), float(radius) * 2.0, float(radius) * 2.0)
        self._radius = float(radius)
        self._viewer_widget = viewer_widget
        self.setBrush(QBrush(QColor(220, 20, 60, 220)))
        self.setPen(QPen(QColor(255, 255, 255, 200), 1))
        self.setZValue(10001)
        self.setFlag(QGraphicsEllipseItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsEllipseItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.setCursor(Qt.CursorShape.SizeVerCursor)

    def itemChange(self, change, value):
        if change == QGraphicsEllipseItem.GraphicsItemChange.ItemPositionChange:
            try:
                vw = self._viewer_widget
                if vw is None:
                    return value
                x_lock = None
                try:
                    ln = getattr(vw, "_scan_line_L", None)
                    if ln is not None and ln.scene() == vw.scene:
                        x_lock = float(ln.line().x1())
                except Exception:
                    x_lock = None
                if x_lock is None:
                    x_lock = float(value.x())
                y = float(value.y())
                try:
                    top = float(getattr(vw, "_scan_top", y))
                    bottom = float(getattr(vw, "_scan_bottom", y))
                    y = min(max(y, top), bottom)
                except Exception:
                    pass
                return QPointF(float(x_lock), float(y))
            except Exception:
                return value
        return super().itemChange(change, value)

    def mousePressEvent(self, event):
        try:
            if event is not None and event.button() == Qt.MouseButton.LeftButton:
                vw = self._viewer_widget
                if vw is not None and bool(getattr(vw, "_manual_scan_active", False)) and (not bool(getattr(vw, "_manual_scan_paused", False))):
                    try:
                        if hasattr(vw, "_scan_timer") and vw._scan_timer and vw._scan_timer.isActive():
                            vw._scan_timer.stop()
                    except Exception:
                        pass
                    try:
                        vw._manual_scan_paused = True
                    except Exception:
                        pass
                    try:
                        vw.zoning_scan_button.setText("Συνέχεια")
                    except Exception:
                        pass
        except Exception:
            pass
        return super().mousePressEvent(event)

# JawSeparatorCurve removed as per user request (deprecated Spee curve)


class ZoneSeparatorLine(QGraphicsPathItem):
    """
    Horizontal line to separate anatomical zones (Upper/Middle/Lower).
    """
    def __init__(self, width, y_pos, label="Zone", color=Qt.GlobalColor.yellow, on_change_callback=None):
        super().__init__()
        self.width = width
        self.label = label
        self.on_change_callback = on_change_callback
        
        pen = QPen(QColor(color))
        pen.setWidth(3)
        pen.setStyle(Qt.PenStyle.DashLine)
        pen.setCosmetic(True)
        self.setPen(pen)
        
        self.setPos(0, y_pos)
        self.setFlag(QGraphicsPathItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsPathItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.setCursor(Qt.CursorShape.SizeVerCursor)
        
        # Add Text Label
        self.text_item = QGraphicsTextItem(label, self)
        self.text_item.setDefaultTextColor(QColor(color))
        font = QFont("Arial", 10, QFont.Weight.Bold)
        self.text_item.setFont(font)
        self.text_item.setPos(10, -20)
        
        self.update_path()
        
    def update_path(self):
        path = QPainterPath()
        path.moveTo(0, 0)
        path.lineTo(self.width, 0)
        self.setPath(path)
        
    def itemChange(self, change, value):
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange and self.scene():
            # Constrain to vertical movement
            return QPointF(0, value.y())
        return super().itemChange(change, value)
        
    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        if self.on_change_callback:
            try:
                self.on_change_callback()
            except Exception:
                pass

class DraggableButtonRow(QWidget):
    def __init__(self, viewer_widget, key: str, parent=None):
        super().__init__(parent)
        self.viewer_widget = viewer_widget
        self.key = str(key or "").strip() or "default"
        self.setAcceptDrops(True)
        self._drag_src = None
        self._drag_start_pos = None
        self._drag_start_global = None
        self._drag_active = False
        self._last_order_names = None
        self._signals_blocked_widget = None

    def eventFilter(self, obj, event):
        try:
            try:
                et = event.type()
            except Exception:
                et = None
            if et in (QEvent.Type.DragEnter, QEvent.Type.DragMove, QEvent.Type.Drop):
                try:
                    if event.mimeData().hasFormat("application/x-radiograph-toolbar-widget"):
                        if et == QEvent.Type.DragEnter:
                            self.dragEnterEvent(event)
                        elif et == QEvent.Type.DragMove:
                            self.dragMoveEvent(event)
                        else:
                            self.dropEvent(event)
                        return True
                except Exception:
                    pass

            reorder_mode = False
            try:
                reorder_mode = bool(getattr(self.viewer_widget, "toolbar_reorder_enabled", False))
            except Exception:
                reorder_mode = False
            if not reorder_mode:
                return super().eventFilter(obj, event)

            mods = Qt.KeyboardModifier.NoModifier
            try:
                mods = event.modifiers()
            except Exception:
                mods = Qt.KeyboardModifier.NoModifier

            if reorder_mode:
                is_drag_press = (event.button() == Qt.MouseButton.LeftButton) or (event.button() == Qt.MouseButton.RightButton)
            else:
                is_drag_press = (event.button() == Qt.MouseButton.RightButton) or (event.button() == Qt.MouseButton.LeftButton and (mods & Qt.KeyboardModifier.AltModifier))

            if event.type() == QEvent.Type.MouseButtonPress and is_drag_press:
                try:
                    ok = isinstance(obj, QWidget) and (obj is not self) and self.isAncestorOf(obj)
                except Exception:
                    ok = False
                if ok:
                    src = obj
                    try:
                        while isinstance(getattr(src, "parent", None)(), QWidget) and src.parent() is not self and self.isAncestorOf(src.parent()):
                            src = src.parent()
                    except Exception:
                        src = obj
                    self._drag_src = src
                    self._drag_start_pos = event.pos()
                    try:
                        self._drag_start_global = QCursor.pos()
                    except Exception:
                        self._drag_start_global = None
                    self._drag_active = False
                    return False

            if reorder_mode and (event.buttons() & Qt.MouseButton.LeftButton):
                is_drag_move = True
            else:
                is_drag_move = (event.buttons() & Qt.MouseButton.RightButton) or ((event.buttons() & Qt.MouseButton.LeftButton) and (mods & Qt.KeyboardModifier.AltModifier))
            if event.type() == QEvent.Type.MouseMove and is_drag_move:
                if self._drag_src is not None and self._drag_start_pos is not None:
                    try:
                        start_g = self._drag_start_global
                        cur_g = QCursor.pos()
                        dist = abs(int(cur_g.x()) - int(start_g.x())) + abs(int(cur_g.y()) - int(start_g.y())) if start_g is not None else (event.pos() - self._drag_start_pos).manhattanLength()
                    except Exception:
                        dist = (event.pos() - self._drag_start_pos).manhattanLength()
                    if dist < 8:
                        return False
                    if not bool(self._drag_active):
                        self._drag_active = True
                        try:
                            self.grabMouse()
                        except Exception:
                            pass
                    try:
                        if self._signals_blocked_widget is None and isinstance(self._drag_src, QWidget):
                            self._signals_blocked_widget = self._drag_src
                            try:
                                self._signals_blocked_widget.blockSignals(True)
                            except Exception:
                                pass
                            try:
                                if hasattr(self._signals_blocked_widget, "setDown"):
                                    self._signals_blocked_widget.setDown(False)
                            except Exception:
                                pass
                    except Exception:
                        pass
                    try:
                        self._reorder_live()
                    except Exception:
                        pass
                    try:
                        event.accept()
                    except Exception:
                        pass
                    return True
            if reorder_mode:
                is_drag_release = (event.button() == Qt.MouseButton.LeftButton) or (event.button() == Qt.MouseButton.RightButton)
            else:
                is_drag_release = (event.button() == Qt.MouseButton.RightButton) or (event.button() == Qt.MouseButton.LeftButton and (mods & Qt.KeyboardModifier.AltModifier))
            if event.type() == QEvent.Type.MouseButtonRelease and is_drag_release:
                try:
                    if bool(self._drag_active):
                        self._commit_reorder()
                        try:
                            self.releaseMouse()
                        except Exception:
                            pass
                        try:
                            if self._signals_blocked_widget is not None:
                                try:
                                    if hasattr(self._signals_blocked_widget, "setDown"):
                                        self._signals_blocked_widget.setDown(False)
                                except Exception:
                                    pass
                                try:
                                    self._signals_blocked_widget.blockSignals(False)
                                except Exception:
                                    pass
                        finally:
                            self._signals_blocked_widget = None
                        event.accept()
                        return True
                except Exception:
                    pass
                self._drag_src = None
                self._drag_start_pos = None
                self._drag_start_global = None
                self._drag_active = False
                try:
                    if self._signals_blocked_widget is not None:
                        try:
                            if hasattr(self._signals_blocked_widget, "setDown"):
                                self._signals_blocked_widget.setDown(False)
                        except Exception:
                            pass
                        try:
                            self._signals_blocked_widget.blockSignals(False)
                        except Exception:
                            pass
                finally:
                    self._signals_blocked_widget = None
        except Exception:
            pass
        return super().eventFilter(obj, event)

    def mouseMoveEvent(self, event):
        try:
            if bool(getattr(self, "_drag_active", False)):
                try:
                    self._reorder_live()
                except Exception:
                    pass
                try:
                    event.accept()
                except Exception:
                    pass
                return
        except Exception:
            pass
        return super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        try:
            if bool(getattr(self, "_drag_active", False)):
                try:
                    self._commit_reorder()
                except Exception:
                    pass
                try:
                    self.releaseMouse()
                except Exception:
                    pass
                try:
                    event.accept()
                except Exception:
                    pass
                return
        except Exception:
            pass
        return super().mouseReleaseEvent(event)

    def _current_order_widgets(self):
        lay = self.layout()
        if lay is None:
            return []
        out = []
        for i in range(lay.count()):
            it = lay.itemAt(i)
            if it is None:
                continue
            w = it.widget()
            if w is not None:
                out.append(w)
        return out

    def _rebuild_layout(self, widgets):
        lay = self.layout()
        if lay is None:
            return
        try:
            while lay.count():
                it = lay.takeAt(0)
                if it is None:
                    continue
                w = it.widget()
                if w is not None:
                    w.setParent(self)
        except Exception:
            pass
        for w in widgets:
            try:
                w.setParent(self)
            except Exception:
                pass
            lay.addWidget(w)
        lay.addStretch(1)

    def _global_x(self):
        try:
            return float(QCursor.pos().x())
        except Exception:
            return 0.0

    def _reorder_live(self):
        dragged = self._drag_src
        if dragged is None:
            return
        widgets = self._current_order_widgets()
        if not widgets or dragged not in widgets:
            return
        others = [w for w in widgets if w is not dragged]
        gx = self._global_x()
        insert_idx = len(others)
        for i, w in enumerate(others):
            try:
                cx = float(w.mapToGlobal(w.rect().center()).x())
            except Exception:
                continue
            if gx < cx:
                insert_idx = i
                break
        new_order = list(others)
        new_order.insert(insert_idx, dragged)
        if new_order == widgets:
            return
        self._rebuild_layout(new_order)

    def _commit_reorder(self):
        try:
            widgets = self._current_order_widgets()
            names = [str(w.objectName() or "").strip() for w in widgets if str(w.objectName() or "").strip()]
            self._last_order_names = names
            if self.viewer_widget and hasattr(self.viewer_widget, "_on_button_row_reordered"):
                self.viewer_widget._on_button_row_reordered(self.key, names)
        except Exception:
            pass
        self._drag_src = None
        self._drag_start_pos = None
        self._drag_active = False

    def register_widget(self, w: QWidget):
        try:
            if w is None:
                return
            w.setParent(self)
            try:
                w.setAcceptDrops(True)
            except Exception:
                pass
            w.installEventFilter(self)
        except Exception:
            pass

    def apply_saved_order(self, order_names):
        lay = self.layout()
        if lay is None:
            return
        widgets = []
        for i in range(lay.count()):
            it = lay.itemAt(i)
            if it is None:
                continue
            ww = it.widget()
            if ww is not None:
                widgets.append(ww)
        if not widgets:
            return

        name_map = {}
        for w in widgets:
            try:
                nm = str(w.objectName() or "").strip()
            except Exception:
                nm = ""
            if nm:
                name_map[nm] = w

        ordered = []
        if isinstance(order_names, list):
            for nm in order_names:
                nm = str(nm or "").strip()
                if nm and nm in name_map and name_map[nm] not in ordered:
                    ordered.append(name_map[nm])

        for w in widgets:
            if w not in ordered:
                ordered.append(w)

        try:
            while lay.count():
                it = lay.takeAt(0)
                if it is None:
                    continue
                ww = it.widget()
                if ww is not None:
                    ww.setParent(self)
        except Exception:
            pass

        for w in ordered:
            try:
                w.setAcceptDrops(True)
            except Exception:
                pass
            try:
                w.installEventFilter(self)
            except Exception:
                pass
            lay.addWidget(w)
        lay.addStretch(1)

    def _start_drag(self, w: QWidget):
        try:
            nm = str(w.objectName() or "").strip()
            if not nm:
                return
            return
        except Exception:
            pass

    def dragEnterEvent(self, event):
        try:
            if event.mimeData().hasFormat("application/x-radiograph-toolbar-widget"):
                event.acceptProposedAction()
                return
        except Exception:
            pass
        event.ignore()

    def dragMoveEvent(self, event):
        try:
            if event.mimeData().hasFormat("application/x-radiograph-toolbar-widget"):
                event.acceptProposedAction()
                return
        except Exception:
            pass
        event.ignore()

    def dropEvent(self, event):
        try:
            if not event.mimeData().hasFormat("application/x-radiograph-toolbar-widget"):
                event.ignore()
                return
            nm = bytes(event.mimeData().data("application/x-radiograph-toolbar-widget")).decode("utf-8", errors="ignore").strip()
            if not nm:
                event.ignore()
                return
            lay = self.layout()
            if lay is None:
                event.ignore()
                return
            widgets = []
            dragged = None
            for i in range(lay.count()):
                it = lay.itemAt(i)
                if it is None:
                    continue
                ww = it.widget()
                if ww is None:
                    continue
                widgets.append(ww)
                if str(ww.objectName() or "").strip() == nm:
                    dragged = ww
            if dragged is None:
                event.ignore()
                return
            others = [w for w in widgets if w is not dragged]
            insert_idx = len(others)
            try:
                gx = int(QCursor.pos().x())
                for i, w in enumerate(others):
                    try:
                        cx = int(w.mapToGlobal(w.rect().center()).x())
                    except Exception:
                        continue
                    if gx < cx:
                        insert_idx = i
                        break
            except Exception:
                pass
            new_order = list(others)
            new_order.insert(insert_idx, dragged)
            try:
                while lay.count():
                    it = lay.takeAt(0)
                    if it is None:
                        continue
                    ww = it.widget()
                    if ww is not None:
                        ww.setParent(self)
            except Exception:
                pass
            for w in new_order:
                lay.addWidget(w)
            lay.addStretch(1)
            try:
                if self.viewer_widget and hasattr(self.viewer_widget, "_on_button_row_reordered"):
                    self.viewer_widget._on_button_row_reordered(self.key, [str(w.objectName() or "").strip() for w in new_order if str(w.objectName() or "").strip()])
            except Exception:
                pass
            try:
                event.setDropAction(Qt.DropAction.MoveAction)
            except Exception:
                pass
            event.acceptProposedAction()
        except Exception:
            event.ignore()

class _DragDropForwarder(QObject):
    def __init__(self, target: DraggableButtonRow, parent=None):
        super().__init__(parent)
        self._target = target

    def eventFilter(self, obj, event):
        try:
            et = event.type()
        except Exception:
            return False
        if et == QEvent.Type.DragEnter:
            try:
                self._target.dragEnterEvent(event)
                return True
            except Exception:
                return False
        if et == QEvent.Type.DragMove:
            try:
                self._target.dragMoveEvent(event)
                return True
            except Exception:
                return False
        if et == QEvent.Type.Drop:
            try:
                self._target.dropEvent(event)
                return True
            except Exception:
                return False
        return False

class ToolbarLayoutDialog(QDialog):
    def __init__(self, viewer_widget, parent=None):
        super().__init__(parent)
        self.viewer_widget = viewer_widget
        self.setWindowTitle("Διάταξη Κουμπιών")
        try:
            self.resize(520, 560)
        except Exception:
            pass

        lay = QVBoxLayout(self)

        top = QHBoxLayout()
        top.addWidget(QLabel("Tab:"))
        self.key_combo = QComboBox()
        self._key_items = [
            ("view", "Βασικά"),
            ("grid", "Πλέγμα"),
            ("tools", "Εργαλεία"),
            ("comm", "Συνομιλία"),
            ("ai", "AI"),
        ]
        for k, label in self._key_items:
            self.key_combo.addItem(label, k)
        top.addWidget(self.key_combo, 1)
        lay.addLayout(top)

        self.list_widget = QListWidget()
        lay.addWidget(self.list_widget, 1)

        btn_row = QHBoxLayout()
        self.up_btn = QPushButton("Πάνω")
        self.down_btn = QPushButton("Κάτω")
        self.reset_btn = QPushButton("Επαναφορά Προεπιλογής")
        btn_row.addWidget(self.up_btn)
        btn_row.addWidget(self.down_btn)
        btn_row.addStretch(1)
        btn_row.addWidget(self.reset_btn)
        lay.addLayout(btn_row)

        bbox = QDialogButtonBox(QDialogButtonBox.StandardButton.Apply | QDialogButtonBox.StandardButton.Close)
        lay.addWidget(bbox)

        self.key_combo.currentIndexChanged.connect(lambda *_: self._reload())
        self.up_btn.clicked.connect(self._move_up)
        self.down_btn.clicked.connect(self._move_down)
        self.reset_btn.clicked.connect(self._reset_default)
        bbox.button(QDialogButtonBox.StandardButton.Apply).clicked.connect(self._apply)
        bbox.rejected.connect(self.reject)

        self._reload()

    def _current_key(self) -> str:
        try:
            return str(self.key_combo.currentData() or "").strip() or "view"
        except Exception:
            return "view"

    def _row_for_key(self, key: str):
        try:
            rows = getattr(self.viewer_widget, "_toolbar_rows", None)
            if isinstance(rows, dict) and key in rows:
                return rows.get(key)
        except Exception:
            pass
        return None

    def _display_name_for_widget(self, w: QWidget) -> str:
        try:
            if hasattr(w, "text"):
                t = str(w.text() or "").strip()
                if t:
                    return t
        except Exception:
            pass
        try:
            return str(w.objectName() or "").strip()
        except Exception:
            return ""

    def _reload(self):
        self.list_widget.clear()
        key = self._current_key()
        row = self._row_for_key(key)
        if row is None:
            return
        try:
            self.viewer_widget._auto_assign_toolbar_object_names()
        except Exception:
            pass
        widgets = []
        try:
            widgets = row._current_order_widgets()
        except Exception:
            widgets = []
        for w in widgets:
            try:
                nm = str(w.objectName() or "").strip()
            except Exception:
                nm = ""
            if not nm:
                continue
            item = QListWidgetItem(self._display_name_for_widget(w))
            item.setData(Qt.ItemDataRole.UserRole, nm)
            self.list_widget.addItem(item)

    def _selected_row(self) -> int:
        try:
            r = int(self.list_widget.currentRow())
            return r
        except Exception:
            return -1

    def _swap(self, a: int, b: int):
        if a == b:
            return
        if a < 0 or b < 0:
            return
        if a >= self.list_widget.count() or b >= self.list_widget.count():
            return
        ia = self.list_widget.takeItem(a)
        ib = self.list_widget.takeItem(b - 1 if b > a else b)
        if b > a:
            self.list_widget.insertItem(a, ib)
            self.list_widget.insertItem(b, ia)
        else:
            self.list_widget.insertItem(b, ia)
            self.list_widget.insertItem(a, ib)
        self.list_widget.setCurrentRow(b)

    def _move_up(self):
        r = self._selected_row()
        if r <= 0:
            return
        self._swap(r, r - 1)

    def _move_down(self):
        r = self._selected_row()
        if r < 0 or r >= self.list_widget.count() - 1:
            return
        self._swap(r, r + 1)

    def _apply(self):
        key = self._current_key()
        row = self._row_for_key(key)
        if row is None:
            return
        order = []
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            if it is None:
                continue
            try:
                nm = str(it.data(Qt.ItemDataRole.UserRole) or "").strip()
            except Exception:
                nm = ""
            if nm:
                order.append(nm)
        try:
            row.apply_saved_order(order)
        except Exception:
            pass
        try:
            self.viewer_widget._on_button_row_reordered(key, order)
        except Exception:
            pass

    def _reset_default(self):
        key = self._current_key()
        try:
            defaults = getattr(self.viewer_widget, "_default_button_order", None)
            if isinstance(defaults, dict) and key in defaults:
                order = defaults.get(key) or []
            else:
                order = []
        except Exception:
            order = []
        if order:
            self.list_widget.clear()
            for nm in order:
                nm = str(nm or "").strip()
                if not nm:
                    continue
                item = QListWidgetItem(nm)
                item.setData(Qt.ItemDataRole.UserRole, nm)
                self.list_widget.addItem(item)
            self._apply()
        self._reload()

class ScreenLayoutDialog(QDialog):
    def __init__(self, viewer_widget, parent=None):
        super().__init__(parent)
        self.viewer_widget = viewer_widget
        self.setWindowTitle("Διάταξη Οθόνης")
        try:
            self.resize(520, 240)
        except Exception:
            pass

        lay = QVBoxLayout(self)

        row = QHBoxLayout()
        row.addWidget(QLabel("Θέση εργαλειοθήκης:"))
        self.tools_loc_combo = QComboBox()
        self.tools_loc_combo.addItem("Πάνω από την εικόνα", "top")
        self.tools_loc_combo.addItem("Κάτω (σταθερά)", "bottom")
        try:
            cur = str(getattr(self.viewer_widget, "tools_location", "top") or "top")
            idx = self.tools_loc_combo.findData(cur)
            if idx >= 0:
                self.tools_loc_combo.setCurrentIndex(idx)
        except Exception:
            pass
        row.addWidget(self.tools_loc_combo, 1)
        lay.addLayout(row)

        bbox = QDialogButtonBox(QDialogButtonBox.StandardButton.Apply | QDialogButtonBox.StandardButton.Close)
        lay.addWidget(bbox)
        bbox.button(QDialogButtonBox.StandardButton.Apply).clicked.connect(self._apply)
        bbox.rejected.connect(self.reject)

    def _apply(self):
        try:
            loc = str(self.tools_loc_combo.currentData() or "").strip() or "top"
        except Exception:
            loc = "top"
        try:
            self.viewer_widget.tools_location = loc
        except Exception:
            pass
        try:
            self.viewer_widget._apply_tools_location()
        except Exception:
            pass
        try:
            self.viewer_widget._save_viewer_prefs()
        except Exception:
            pass

class CalibrationHandle(QGraphicsEllipseItem):
    def __init__(self, parent, x, y):
        super().__init__(-11, -11, 22, 22, parent)
        self.setPos(x, y)
        self.setBrush(QBrush(QColor("yellow")))
        self.setPen(QPen(QColor("black")))
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.setZValue(40) # Ensure handle is always on top
        self.setAcceptHoverEvents(True)
        self._base_brush = QBrush(self.brush())
        self._base_pen = QPen(self.pen())
        self._base_scale = float(self.scale())
        self._base_z = float(self.zValue())
        
    def itemChange(self, change, value):
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange and self.parentItem():
            try:
                line = self.parentItem()
                new_pos = QPointF(value)
                try:
                    axis = str(getattr(line, "axis_type", "any") or "any")
                except Exception:
                    axis = "any"
                try:
                    vw = getattr(line, "viewer_widget", None)
                except Exception:
                    vw = None

                if axis == "x":
                    try:
                        new_pos.setY(float(self.pos().y()))
                    except Exception:
                        pass
                elif axis == "y":
                    try:
                        new_pos.setX(float(self.pos().x()))
                    except Exception:
                        pass

                try:
                    pi = getattr(vw, "pixmap_item", None) if vw is not None else None
                    if pi is not None and pi.scene() is not None:
                        bounds = pi.mapToScene(pi.boundingRect()).boundingRect()
                        sp = line.mapToScene(new_pos)
                        cx = min(max(float(sp.x()), float(bounds.left())), float(bounds.right()))
                        cy = min(max(float(sp.y()), float(bounds.top())), float(bounds.bottom()))
                        new_pos = line.mapFromScene(QPointF(cx, cy))
                except Exception:
                    pass

                try:
                    line.update_path()
                except Exception:
                    pass
                return new_pos
            except Exception:
                try:
                    self.parentItem().update_path()
                except Exception:
                    pass
        return super().itemChange(change, value)
    
    def hoverEnterEvent(self, event):
        try:
            self.setZValue(max(self._base_z, 70.0))
            self.setScale(self._base_scale * 1.25)
            self.setBrush(QBrush(QColor("#ffb000")))
            self.setPen(QPen(QColor("black"), 2))
        except Exception:
            pass
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        try:
            self.setScale(float(getattr(self, "_base_scale", 1.0)))
            if hasattr(self, "_base_brush"):
                self.setBrush(QBrush(self._base_brush))
            if hasattr(self, "_base_pen"):
                self.setPen(QPen(self._base_pen))
            self.setZValue(float(getattr(self, "_base_z", 40.0)))
        except Exception:
            pass
        super().hoverLeaveEvent(event)

class CalibrationLine(QGraphicsPathItem):
    def __init__(self, x1, y1, x2, y2, on_calibrated=None, axis_type='any', on_change_callback=None, viewer_widget=None, **kwargs):
        super().__init__()
        try:
            legacy_axis = kwargs.get("axis", None)
            if legacy_axis is not None and str(axis_type or "any").strip().lower() in ("any", ""):
                axis_type = legacy_axis
        except Exception:
            pass
        self.on_calibrated = on_calibrated
        self.axis_type = axis_type
        self.on_change_callback = on_change_callback
        self.viewer_widget = viewer_widget
        self.mm_length = None
        self.pixel_ratio = 1.0 # mm per pixel
        
        self.setPos(x1, y1)
        self.setZValue(30) # High Z-value to be on top of separators and image
        
        self.h1 = CalibrationHandle(self, 0, 0)
        self.h2 = CalibrationHandle(self, x2-x1, y2-y1)
        
        color = "yellow"
        try:
            if str(axis_type or "").strip().lower() == 'x':
                color = "#FF0000"
            if str(axis_type or "").strip().lower() == 'y':
                color = "#FF00FF"
        except Exception:
            pass
        try:
            if "color" in kwargs and kwargs.get("color") is not None:
                color = kwargs.get("color")
        except Exception:
            pass
        
        pen = QPen(QColor(color))
        pen.setWidth(2)
        pen.setCosmetic(True)
        self.setPen(pen)
        self.setAcceptHoverEvents(True)
        self._base_pen = QPen(self.pen())
        self._base_z = float(self.zValue())
        
        self.setFlag(QGraphicsPathItem.GraphicsItemFlag.ItemIsSelectable, True)
        self.setFlag(QGraphicsPathItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsPathItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        
        self.text_item = QGraphicsTextItem("", self)
        self.text_item.setDefaultTextColor(QColor(color))
        font = QFont()
        font.setBold(True)
        font.setPointSize(10)
        self.text_item.setFont(font)
        try:
            label = kwargs.get("label", None)
            if label is not None:
                self.setToolTip(str(label))
        except Exception:
            pass
        
        self.update_path()

    def itemChange(self, change, value):
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange:
            try:
                new_pos = QPointF(value)
                old_pos = QPointF(self.pos())
                try:
                    axis = str(getattr(self, "axis_type", "any") or "any").lower().strip()
                except Exception:
                    axis = "any"
                if axis == "x":
                    try:
                        new_pos.setX(float(old_pos.x()))
                    except Exception:
                        pass
                elif axis == "y":
                    try:
                        new_pos.setY(float(old_pos.y()))
                    except Exception:
                        pass

                bounds = None
                try:
                    vw = getattr(self, "viewer_widget", None)
                    pi = getattr(vw, "pixmap_item", None) if vw is not None else None
                    if pi is not None and pi.scene() is not None:
                        bounds = pi.mapToScene(pi.boundingRect()).boundingRect()
                except Exception:
                    bounds = None
                if bounds is not None:
                    delta = new_pos - old_pos
                    try:
                        p1 = self.mapToScene(self.h1.pos()) + delta
                        p2 = self.mapToScene(self.h2.pos()) + delta
                        min_x = min(float(p1.x()), float(p2.x()))
                        max_x = max(float(p1.x()), float(p2.x()))
                        min_y = min(float(p1.y()), float(p2.y()))
                        max_y = max(float(p1.y()), float(p2.y()))
                        dx = float(delta.x())
                        dy = float(delta.y())
                        if min_x < float(bounds.left()):
                            dx += float(bounds.left()) - min_x
                        if max_x > float(bounds.right()):
                            dx -= max_x - float(bounds.right())
                        if min_y < float(bounds.top()):
                            dy += float(bounds.top()) - min_y
                        if max_y > float(bounds.bottom()):
                            dy -= max_y - float(bounds.bottom())
                        new_pos = old_pos + QPointF(dx, dy)
                    except Exception:
                        pass
                return new_pos
            except Exception:
                pass
        return super().itemChange(change, value)

    def shape(self):
        try:
            stroker = QPainterPathStroker()
            stroker.setWidth(16.0)
            return stroker.createStroke(self.path())
        except Exception:
            return super().shape()
    
    def hoverEnterEvent(self, event):
        try:
            p = QPen(self.pen())
            try:
                p.setWidth(max(int(p.width()), 5))
            except Exception:
                p.setWidth(5)
            c = QColor(p.color())
            c.setAlpha(255)
            p.setColor(c)
            self.setPen(p)
            self.setZValue(max(self._base_z, 60.0))
        except Exception:
            pass
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        try:
            if hasattr(self, "_base_pen"):
                self.setPen(QPen(self._base_pen))
            self.setZValue(float(getattr(self, "_base_z", 30.0)))
        except Exception:
            pass
        super().hoverLeaveEvent(event)

    def update_path(self):
        p1 = self.h1.pos()
        p2 = self.h2.pos()
        
        path = QPainterPath()
        path.moveTo(p1)
        path.lineTo(p2)
        
        # Draw ticks at ends
        dir_vec = p2 - p1
        length = np.sqrt(dir_vec.x()**2 + dir_vec.y()**2)
        if length > 0:
            dir_vec /= length
            perp = QPointF(-dir_vec.y(), dir_vec.x()) * 10
            
            path.moveTo(p1 + perp)
            path.lineTo(p1 - perp)
            path.moveTo(p2 + perp)
            path.lineTo(p2 - perp)
            
        self.setPath(path)
        
        # Update text
        mid = (p1 + p2) / 2
        text_pos = mid + QPointF(5, -20)
        
        pixel_len = length
        
        prefix = ""
        if self.axis_type == 'x': prefix = "X: "
        elif self.axis_type == 'y': prefix = "Y: "
        
        if self.mm_length:
            self.text_item.setPlainText(f"{prefix}{self.mm_length} mm")
        else:
            self.text_item.setPlainText(f"{prefix}{pixel_len:.1f} px\n(Double click)")
            
        self.text_item.setPos(text_pos)
        try:
            if self.on_change_callback:
                self.on_change_callback()
        except Exception:
            pass

    def mouseDoubleClickEvent(self, event):
        val, ok = QInputDialog.getDouble(None, "Βαθμονόμηση", f"Πραγματικό μήκος {self.axis_type.upper()} (mm):", 
                                       value=10.0 if not self.mm_length else self.mm_length, 
                                       min=0.1, max=1000.0, decimals=1)
        if ok:
            self.mm_length = val
            p1 = self.h1.pos()
            p2 = self.h2.pos()
            pixel_len = np.sqrt((p2.x()-p1.x())**2 + (p2.y()-p1.y())**2)
            
            if pixel_len > 0:
                self.pixel_ratio = val / pixel_len
                if self.on_calibrated:
                    self.on_calibrated(self.pixel_ratio, self.axis_type)
            self.update_path()
            
    def set_p2(self, p2):
        local_p2 = self.mapFromScene(p2)
        self.h2.setPos(local_p2)
        self.update_path()

class VerticalSeparatorLine(QGraphicsRectItem):
    def __init__(self, height, x_pos, label="Midline", color=None, on_change_callback=None):
        super().__init__(0, 0, 3, height)
        self.on_change_callback = on_change_callback
        self.label = label
        self.setPos(x_pos - 1.5, 0)
        
        if color:
             c = QColor(color)
             c.setAlpha(150)
             self.setBrush(QBrush(c))
        else:
             self.setBrush(QBrush(QColor(0, 255, 255, 150)))
             
        self.setPen(QPen(Qt.PenStyle.NoPen))
        self.setFlag(QGraphicsRectItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsRectItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.setCursor(Qt.CursorShape.SizeHorCursor)
        self.setZValue(5) # Lower Z-value than calibration lines
        self._hit_pad = 10.0
        self.setAcceptHoverEvents(True)
        self._base_brush = QBrush(self.brush())
        self._base_z = float(self.zValue())

    def shape(self):
        try:
            r = self.rect()
            pad = float(self._hit_pad)
            rr = r.adjusted(-pad, 0.0, pad, 0.0)
            p = QPainterPath()
            p.addRect(rr)
            return p
        except Exception:
            return super().shape()
    
    def hoverEnterEvent(self, event):
        try:
            c = QColor(self.brush().color())
            c.setAlpha(230)
            self.setBrush(QBrush(c))
            self.setZValue(max(self._base_z, 15.0))
        except Exception:
            pass
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        try:
            if hasattr(self, "_base_brush"):
                self.setBrush(QBrush(self._base_brush))
            self.setZValue(float(getattr(self, "_base_z", 5.0)))
        except Exception:
            pass
        super().hoverLeaveEvent(event)

    def itemChange(self, change, value):
        if change == QGraphicsRectItem.GraphicsItemChange.ItemPositionChange:
            new_pos = value
            if new_pos.y() != 0:
                new_pos.setY(0)
                return new_pos
            if self.on_change_callback:
                self.on_change_callback()
        return super().itemChange(change, value)

class CropRectItem(QGraphicsRectItem):
    def __init__(self, rect=None):
        super().__init__(rect if rect else QRectF())
        self.setPen(QPen(Qt.GlobalColor.yellow, 2, Qt.PenStyle.DashLine))
        self.setBrush(QBrush(QColor(255, 255, 0, 50)))

class RoiHandleItem(QGraphicsRectItem):
    def __init__(self, parent, role):
        super().__init__(-6, -6, 12, 12, parent)
        self.role = role # 'tl', 'tr', 'bl', 'br'
        self.setBrush(QBrush(Qt.GlobalColor.white))
        self.setPen(QPen(Qt.GlobalColor.black))
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)
        self.setCursor(Qt.CursorShape.SizeFDiagCursor if role in ('tl', 'br') else Qt.CursorShape.SizeBDiagCursor)
        self.setAcceptHoverEvents(True)

    def mouseMoveEvent(self, event):
        super().mouseMoveEvent(event)
        if self.parentItem():
            self.parentItem().handle_moved(self)

class RoiRectItem(QGraphicsRectItem):
    def __init__(self, rect, color=Qt.GlobalColor.green, label="ROI", on_change_callback=None):
        super().__init__(rect)
        self.on_change_callback = on_change_callback
        self.setPen(QPen(color, 2, Qt.PenStyle.DashLine))
        c = QColor(color)
        c.setAlpha(50)
        self.setBrush(QBrush(c))
        
        self.handles = {}
        for role in ['tl', 'tr', 'bl', 'br']:
            self.handles[role] = RoiHandleItem(self, role)
            
        self.label_item = QGraphicsSimpleTextItem(label, self)
        self.label_item.setBrush(QBrush(color))
        font = self.label_item.font()
        font.setBold(True)
        font.setPointSize(12)
        self.label_item.setFont(font)
        
        self.update_handles_pos()
        # The rect itself should be movable too, to drag the whole area
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable) 
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)

    def itemChange(self, change, value):
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange and self.scene():
            if self.on_change_callback:
                # We need to defer the callback or pass the new value because the position is updating
                # For simplicity, we can just trigger it. But usually geometry changes are better tracked.
                # However, for manual ROI, we just need the final rect when analysis starts.
                # But if we want real-time updates or saving, callback is useful.
                pass
        return super().itemChange(change, value)

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        if self.on_change_callback:
            self.on_change_callback(self)

    def update_handles_pos(self):
        r = self.rect()
        self.handles['tl'].setPos(r.topLeft())
        self.handles['tr'].setPos(r.topRight())
        self.handles['bl'].setPos(r.bottomLeft())
        self.handles['br'].setPos(r.bottomRight())
        self.label_item.setPos(r.left(), r.top() - 20)

    def handle_moved(self, handle):
        r = self.rect()
        pos = handle.pos()
        x, y = pos.x(), pos.y()
        
        l, t, w, h = r.x(), r.y(), r.width(), r.height()
        r_right = l + w
        r_bottom = t + h
        
        if handle.role == 'tl':
            l = x
            t = y
        elif handle.role == 'tr':
            r_right = x
            t = y
        elif handle.role == 'bl':
            l = x
            r_bottom = y
        elif handle.role == 'br':
            r_right = x
            r_bottom = y
            
        new_rect = QRectF(QPointF(l, t), QPointF(r_right, r_bottom)).normalized()
        self.setRect(new_rect)
        self.update_handles_pos()
        if self.on_change_callback:
            self.on_change_callback(self)


class DraggableLineItem(QGraphicsPathItem):
    def __init__(self, x1, y1, x2, y2, orientation='vertical', on_change_callback=None, parent=None, lock_axis='auto'):
        super().__init__(parent)
        self.orientation = orientation
        self.on_change_callback = on_change_callback
        self._hit_width = 16.0
        
        # Determine locking behavior
        if lock_axis == 'auto':
            if orientation == 'vertical':
                self.lock_axis = 'y' # Default: Lock Y, move X only
            else:
                self.lock_axis = 'x' # Default: Lock X, move Y only
        else:
            self.lock_axis = lock_axis # 'x', 'y', or None
            
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)
        
        self.pen_color = Qt.GlobalColor.cyan
        self.pen_width = 2
        self.update_pen()
        self.setAcceptHoverEvents(True)
        self._base_pen_width = int(self.pen_width)
        self._base_pen_color = self.pen_color
        self._base_z = float(self.zValue())
        
        path = QPainterPath()
        path.moveTo(x1, y1)
        path.lineTo(x2, y2)
        self.setPath(path)
        
        if orientation == 'vertical':
            self.setCursor(Qt.CursorShape.SizeAllCursor if self.lock_axis is None else Qt.CursorShape.SizeHorCursor)
        else:
            self.setCursor(Qt.CursorShape.SizeAllCursor if self.lock_axis is None else Qt.CursorShape.SizeVerCursor)

    def shape(self):
        try:
            w = float(self._hit_width)
            try:
                w = max(w, float(getattr(self, "pen_width", 1)) + 12.0)
            except Exception:
                pass
            stroker = QPainterPathStroker()
            stroker.setWidth(w)
            return stroker.createStroke(self.path())
        except Exception:
            return super().shape()
    
    def hoverEnterEvent(self, event):
        try:
            self.set_width(max(int(getattr(self, "pen_width", 2)), 4))
            c = QColor(self.pen().color())
            c.setAlpha(255)
            p = QPen(c, self.pen_width)
            p.setCosmetic(True)
            self.setPen(p)
            self.setZValue(max(self._base_z, 20.0))
        except Exception:
            pass
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        try:
            self.pen_width = int(getattr(self, "_base_pen_width", self.pen_width))
            self.pen_color = getattr(self, "_base_pen_color", self.pen_color)
            self.update_pen()
            self.setZValue(float(getattr(self, "_base_z", 0.0)))
        except Exception:
            pass
        super().hoverLeaveEvent(event)

    def set_vertical_endpoints(self, y1, y2):
        if self.orientation != 'vertical': return
        path = QPainterPath()
        # Assume item is at Y=0, but subtract self.y() to be safe
        local_y1 = y1 - self.y()
        local_y2 = y2 - self.y()
        path.moveTo(0, local_y1)
        path.lineTo(0, local_y2)
        self.setPath(path)

    def update_pen(self):
        pen = QPen(self.pen_color, self.pen_width)
        pen.setCosmetic(True) # Constant width regardless of zoom
        self.setPen(pen)

    def set_color(self, color):
        self.pen_color = color
        self.update_pen()

    def set_width(self, width):
        self.pen_width = width
        self.update_pen()

    def contextMenuEvent(self, event):
        menu = QMenu()
        color_action = menu.addAction("Χρώμα Γραμμής")
        width_action = menu.addAction("Πάχος Γραμμής")
        
        action = menu.exec(event.screenPos())
        
        if action == color_action:
            # Simple color cycle for now or dialog? Let's use QColorDialog
            from PyQt6.QtWidgets import QColorDialog
            color = QColorDialog.getColor(self.pen_color, None, "Επιλογή Χρώματος")
            if color.isValid():
                self.set_color(color)
                
        elif action == width_action:
             w, ok = QInputDialog.getInt(None, "Πάχος", "Πάχος Γραμμής:", self.pen_width, 1, 10)
             if ok:
                 self.set_width(w)
            
    def itemChange(self, change, value):
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange:
            # Constrain movement based on lock_axis
            new_pos = value
            if self.lock_axis == 'y':
                new_pos = QPointF(value.x(), self.y())
            elif self.lock_axis == 'x':
                new_pos = QPointF(self.x(), value.y())
            # If None, allow free movement
            
            if self.on_change_callback:
                self.on_change_callback()
            return new_pos
        return super().itemChange(change, value)

class ChangeHotspotMarkerItem(QGraphicsEllipseItem):
    def __init__(self, viewer_widget, idx: int, bbox: QRectF, x: float, y: float, r: float = 12.0):
        super().__init__(-r, -r, 2 * r, 2 * r)
        self.viewer_widget = viewer_widget
        self.idx = int(idx)
        self.bbox = bbox
        self.setPos(float(x), float(y))
        self.setBrush(QBrush(QColor(255, 255, 255, 25)))
        pen = QPen(QColor(255, 80, 0), 3)
        pen.setCosmetic(True)
        self.setPen(pen)
        self.setZValue(140)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)
        try:
            t = QGraphicsTextItem(str(self.idx), self)
            t.setDefaultTextColor(QColor(255, 80, 0))
            f = t.font()
            f.setBold(True)
            f.setPointSize(9)
            t.setFont(f)
            t.setPos(-6, -16)
            t.setZValue(141)
        except Exception:
            pass

    def mousePressEvent(self, event):
        try:
            if self.viewer_widget and hasattr(self.viewer_widget, "jump_to_change_hotspot"):
                self.viewer_widget.jump_to_change_hotspot(self.idx)
        except Exception:
            pass
        super().mousePressEvent(event)

    def hoverEnterEvent(self, event):
        try:
            pen = QPen(QColor(255, 80, 0), 4)
            pen.setCosmetic(True)
            self.setPen(pen)
            self.setBrush(QBrush(QColor(255, 255, 255, 45)))
        except Exception:
            pass
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        try:
            pen = QPen(QColor(255, 80, 0), 3)
            pen.setCosmetic(True)
            self.setPen(pen)
            self.setBrush(QBrush(QColor(255, 255, 255, 25)))
        except Exception:
            pass
        super().hoverLeaveEvent(event)

class CustomGraphicsView(QGraphicsView):
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)
        self.viewer_widget = parent
        self.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignHCenter)
        try:
            self.setFrameShape(QFrame.Shape.NoFrame)
        except Exception:
            pass
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setViewportUpdateMode(QGraphicsView.ViewportUpdateMode.FullViewportUpdate)
        self.setMouseTracking(True) # Enable mouse tracking for calibration drawing
        self._is_panning = False
        self._last_pan_pos = None
        self._pan_mouse_button = None
        self._space_down = False

    def wheelEvent(self, event):
        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        factor = 1.15
        if event.angleDelta().y() > 0:
            self.scale(factor, factor)
        else:
            self.scale(1/factor, 1/factor)

    def keyPressEvent(self, event):
        try:
            if event.key() == Qt.Key.Key_Space:
                self._space_down = True
                try:
                    if not self._is_panning:
                        self.setCursor(Qt.CursorShape.OpenHandCursor)
                except Exception:
                    pass
                event.accept()
                return
        except Exception:
            pass
        super().keyPressEvent(event)

    def keyReleaseEvent(self, event):
        try:
            if event.key() == Qt.Key.Key_Space:
                self._space_down = False
                try:
                    if not self._is_panning:
                        self.setCursor(Qt.CursorShape.ArrowCursor)
                except Exception:
                    pass
                event.accept()
                return
        except Exception:
            pass
        super().keyReleaseEvent(event)

    def drawForeground(self, painter, rect):
        super().drawForeground(painter, rect)
        
        # Draw Rulers if scale is set
        if self.viewer_widget and hasattr(self.viewer_widget, 'pixel_to_mm_scale'):
            scale = self.viewer_widget.pixel_to_mm_scale
            if scale is None: return
            
            # Simple visual scale bar at bottom right
            view_rect = self.viewport().rect()
            scene_rect = self.mapToScene(view_rect).boundingRect()
            
            # 10mm bar
            mm_target = 50.0 # 50mm
            px_width = mm_target / scale
            
            # Position at bottom right of scene visible area
            x = scene_rect.right() - px_width - 20
            y = scene_rect.bottom() - 40
            
            painter.setPen(QPen(Qt.GlobalColor.yellow, 2))
            painter.setBrush(Qt.BrushStyle.NoBrush)
            
            # Draw bar
            painter.drawLine(int(x), int(y), int(x + px_width), int(y))
            # Ticks
            painter.drawLine(int(x), int(y-5), int(x), int(y+5))
            painter.drawLine(int(x + px_width), int(y-5), int(x + px_width), int(y+5))
            
            # Text
            painter.setPen(Qt.GlobalColor.yellow)
            font = painter.font()
            font.setBold(True)
            painter.setFont(font)
            painter.drawText(int(x), int(y-10), f"{int(mm_target)} mm")

    def showEvent(self, event):
        super().showEvent(event)
        self.fit_scene_in_view()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.fit_scene_in_view()

    def fit_scene_in_view(self):
        if self.scene() and not self.scene().sceneRect().isEmpty():
            rect = None
            try:
                vw = getattr(self, "viewer_widget", None)
                pi = getattr(vw, "pixmap_item", None) if vw is not None else None
                if pi is not None:
                    rect = pi.mapToScene(pi.boundingRect()).boundingRect()
            except Exception:
                rect = None
            if rect is None:
                rect = self.scene().sceneRect()
            view_size = self.viewport().size()
            if view_size.width() <= 0 or view_size.height() <= 0:
                return
            if rect.width() <= 0 or rect.height() <= 0:
                return
            self.resetTransform()
            mode = "scene"
            try:
                mode = str(getattr(self.viewer_widget, "view_fit_mode", "scene") or "scene")
            except Exception:
                mode = "scene"
            if mode == "height":
                scale = view_size.height() / rect.height()
            else:
                scale_x = view_size.width() / rect.width()
                scale_y = view_size.height() / rect.height()
                scale = min(scale_x, scale_y)
            self.scale(scale, scale)
            try:
                pad_view_px = 8.0
                pad_scene = pad_view_px / float(scale) if float(scale) > 0 else 0.0
                visible_scene_h = float(view_size.height()) / float(scale) if float(scale) > 0 else float(rect.height())
                target_center_y = float(rect.top()) + (visible_scene_h / 2.0) - pad_scene
                self.centerOn(QPointF(float(rect.center().x()), float(target_center_y)))
            except Exception:
                pass
            try:
                if mode == "height":
                    hsb = self.horizontalScrollBar()
                    hsb.setValue(int((hsb.minimum() + hsb.maximum()) / 2))
            except Exception:
                pass

    def contextMenuEvent(self, event):
        item = self.itemAt(event.pos())
        if isinstance(item, (EditableTextItem, EditableRectItem)):
            super().contextMenuEvent(event)
            return
        menu = QMenu(self)
        add_tooth_action = menu.addAction("Προσθήκη Δοντιού")
        bulk_selected_action = menu.addAction("Μαζική Επεξεργασία Επιλεγμένων…")
        
        # --- NEW: Delete Action in Context Menu ---
        delete_selected_action = menu.addAction("Διαγραφή Επιλεγμένων")
        # ------------------------------------------
        
        condition_menu = menu.addMenu("Προσθήκη Κατάστασης")
        condition_actions = {}

        grouped = None
        if self.viewer_widget and hasattr(self.viewer_widget, "get_available_statuses_grouped"):
            try:
                grouped = self.viewer_widget.get_available_statuses_grouped()
            except Exception:
                grouped = None

        if not grouped:
            grouped = {
                "Όλα": ["Τερηδόνα", "Σφράγισμα", "Απονεύρωση", "Εμφύτευμα", "Γέφυρα", "Στεφάνη", "Εγκλεισμός", "Ριζικό Υπόλειμμα", "Ελλείπον"]
            }

        for group_name, statuses in grouped.items():
            target_menu = condition_menu if group_name == "Όλα" else condition_menu.addMenu(group_name)
            for status in statuses:
                action = target_menu.addAction(status)
                condition_actions[action] = status
            
        add_missing_action = menu.addAction("Προσθήκη Ελλείποντος (X)")
        add_missing_quiet_action = menu.addAction("Προσθήκη Ελλείποντος")
        
        action = menu.exec(event.globalPos())
        
        if action == add_tooth_action:
            scene_pos = self.mapToScene(event.pos())
            if self.viewer_widget:
                self.viewer_widget.add_manual_tooth(scene_pos)
        elif action == delete_selected_action: # --- HANDLE DELETE ---
            if self.viewer_widget and hasattr(self.viewer_widget, "delete_selected_items"):
                self.viewer_widget.delete_selected_items()
        elif action == bulk_selected_action:
            if self.viewer_widget and hasattr(self.viewer_widget, "open_bulk_status_editor_for_selected"):
                self.viewer_widget.open_bulk_status_editor_for_selected()
        elif action in condition_actions:
            cond_name = condition_actions[action]
            scene_pos = self.mapToScene(event.pos())
            if self.viewer_widget:
                if hasattr(self.viewer_widget, "add_status_region"):
                    self.viewer_widget.add_status_region(scene_pos, cond_name)
                else:
                    self.viewer_widget.add_condition_box(scene_pos, cond_name, "yellow")
        elif action == add_missing_action:
            scene_pos = self.mapToScene(event.pos())
            if self.viewer_widget:
                self.viewer_widget.add_missing_tooth(scene_pos)
        elif action == add_missing_quiet_action:
            scene_pos = self.mapToScene(event.pos())
            if self.viewer_widget:
                self.viewer_widget.add_missing_tooth(scene_pos, show_x=False)

    def mousePressEvent(self, event):
        try:
            if event.button() == Qt.MouseButton.LeftButton:
                vw = getattr(self, "viewer_widget", None)
                pan_enabled = bool(getattr(vw, "manual_pan_enabled", False)) or bool(getattr(self, "_space_down", False))
                try:
                    if vw is not None and bool(getattr(vw, "_manual_scan_active", False)):
                        pan_enabled = False
                except Exception:
                    pass
                if pan_enabled:
                    item = self.itemAt(event.pos())
                    if not isinstance(item, (EditableTextItem, EditableRectItem)):
                        self._is_panning = True
                        self._pan_mouse_button = Qt.MouseButton.LeftButton
                        self._last_pan_pos = event.pos()
                        self.setCursor(Qt.CursorShape.ClosedHandCursor)
                        event.accept()
                        return
        except Exception:
            pass

        if event.button() == Qt.MouseButton.MiddleButton:
            self._is_panning = True
            self._pan_mouse_button = Qt.MouseButton.MiddleButton
            self._last_pan_pos = event.pos()
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
            event.accept()
            return

        if event.button() == Qt.MouseButton.LeftButton and self.viewer_widget and bool(getattr(self.viewer_widget, "missing_cell_mode", False)):
            item = self.itemAt(event.pos())
            if not isinstance(item, (EditableTextItem, EditableRectItem)):
                scene_pos = self.mapToScene(event.pos())
                try:
                    self.viewer_widget.add_missing_tooth(scene_pos)
                except Exception:
                    pass
                try:
                    self.viewer_widget._set_missing_cell_mode(False)
                except Exception:
                    pass
                return

        if event.button() == Qt.MouseButton.LeftButton and self.viewer_widget and getattr(self.viewer_widget, 'is_cropping', False):
            self.viewer_widget.start_crop_selection(self.mapToScene(event.pos()))
            return

        if self.viewer_widget and getattr(self.viewer_widget, 'magic_wand_active', False):
            item = self.itemAt(event.pos())
            if not isinstance(item, (EditableTextItem, EditableRectItem)):
                scene_pos = self.mapToScene(event.pos())
                self.viewer_widget._magic_wand_segment(scene_pos)
                return

        try:
            if event.button() == Qt.MouseButton.LeftButton and self.viewer_widget:
                if bool(getattr(self.viewer_widget, "_manual_scan_active", False)):
                    item = self.itemAt(event.pos())
                    if isinstance(item, ScanCuspDot):
                        return super().mousePressEvent(event)
                    try:
                        if isinstance(item, QGraphicsTextItem) and (not isinstance(item, EditableTextItem)):
                            s = str(item.toPlainText() or "").strip()
                            if s.isdigit():
                                self.viewer_widget._manual_scan_select_fdi(int(s))
                                event.accept()
                                return
                    except Exception:
                        pass
                    if not isinstance(item, (EditableTextItem, EditableRectItem)):
                        scene_pos = self.mapToScene(event.pos())
                        self.viewer_widget._manual_scan_set_dot(scene_pos, pause_if_running=True)
                        return
        except Exception:
            pass
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if getattr(self, '_is_panning', False) and self._last_pan_pos:
            delta = event.pos() - self._last_pan_pos
            self._last_pan_pos = event.pos()
            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() - delta.x())
            self.verticalScrollBar().setValue(self.verticalScrollBar().value() - delta.y())
            event.accept()
            return

        if self.viewer_widget and getattr(self.viewer_widget, 'is_cropping', False) and (event.buttons() & Qt.MouseButton.LeftButton):
             self.viewer_widget.update_crop_selection(self.mapToScene(event.pos()))
             return

        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if self._pan_mouse_button is not None and event.button() == self._pan_mouse_button:
            self._is_panning = False
            self._pan_mouse_button = None
            try:
                if bool(getattr(self, "_space_down", False)):
                    self.setCursor(Qt.CursorShape.OpenHandCursor)
                else:
                    self.setCursor(Qt.CursorShape.ArrowCursor)
            except Exception:
                self.setCursor(Qt.CursorShape.ArrowCursor)
            event.accept()
            return

        if event.button() == Qt.MouseButton.LeftButton and self.viewer_widget and getattr(self.viewer_widget, 'is_cropping', False):
             self.viewer_widget.finish_crop_selection()
             return

        super().mouseReleaseEvent(event)

class SpeechToTextWorker(QThread):
    result = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, endpoint_url: str, wav_bytes: bytes, language: str = "el", timeout_ms: int = 500, parent=None):
        super().__init__(parent)
        self.endpoint_url = str(endpoint_url or "").strip()
        self.wav_bytes = wav_bytes or b""
        self.language = str(language or "el").strip() or "el"
        self.timeout_ms = int(timeout_ms) if timeout_ms is not None else 500

    def run(self):
        started = time.perf_counter()
        if not self.endpoint_url:
            self.error.emit("Δεν έχει οριστεί STT API URL.")
            return
        if not self.wav_bytes:
            self.error.emit("Δεν υπάρχει ηχητικό για μεταγραφή.")
            return
        try:
            url = self.endpoint_url
            if "?" in url:
                url = url + "&lang=" + urllib.parse.quote(self.language)
            else:
                url = url + "?lang=" + urllib.parse.quote(self.language)

            req = urllib.request.Request(url=url, data=self.wav_bytes, method="POST")
            req.add_header("Content-Type", "audio/wav")
            req.add_header("Accept", "application/json")
            with urllib.request.urlopen(req, timeout=max(0.1, self.timeout_ms / 1000.0)) as resp:
                raw = resp.read()
            try:
                payload = json.loads(raw.decode("utf-8", errors="replace"))
                if isinstance(payload, dict):
                    text = payload.get("text") or payload.get("transcript") or payload.get("result") or ""
                else:
                    text = str(payload)
            except Exception:
                text = raw.decode("utf-8", errors="replace")

            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.result.emit(str(text or "").strip(), float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class WhisperCppTranscribeWorker(QThread):
    result = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, whisper_cli: str, model_path: str, wav_bytes: bytes, language: str = "el", timeout_ms: int = 120000, parent=None):
        super().__init__(parent)
        self.whisper_cli = str(whisper_cli or "").strip()
        self.model_path = str(model_path or "").strip()
        self.wav_bytes = wav_bytes or b""
        self.language = str(language or "el").strip() or "el"
        self.timeout_ms = int(timeout_ms) if timeout_ms is not None else 120000

    def run(self):
        started = time.perf_counter()
        if not self.whisper_cli or not os.path.exists(self.whisper_cli):
            self.error.emit("Δεν βρέθηκε το whisper.cpp exe. Διάλεξε διαδρομή.")
            return
        if not self.model_path or not os.path.exists(self.model_path):
            self.error.emit("Δεν βρέθηκε model Whisper (.bin). Διάλεξε διαδρομή.")
            return
        if not self.wav_bytes:
            self.error.emit("Δεν υπάρχει ηχητικό για μεταγραφή.")
            return
        try:
            tmp_dir = tempfile.mkdtemp(prefix="whispercpp_")
            wav_path = os.path.join(tmp_dir, "input.wav")
            out_prefix = os.path.join(tmp_dir, "out")
            out_txt = out_prefix + ".txt"
            with open(wav_path, "wb") as f:
                f.write(self.wav_bytes)

            cmd = [
                self.whisper_cli,
                "-m", self.model_path,
                "-l", self.language,
                "-f", wav_path,
                "-t", str(max(2, min(8, int(os.cpu_count() or 4)))),
                "-bs", "5",
                "-bo", "5",
                "-otxt",
                "-of", out_prefix,
                "-nt",
                "-np",
                "--suppress-nst",
                "--prompt", "Ελληνικά. Μεταγράφεις φυσικό ελληνικό λόγο. Αγνόησε περιγραφές ήχων όπως [Χειροκρότημα].",
            ]
            proc = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                timeout=max(1.0, float(self.timeout_ms) / 1000.0),
                text=True,
                encoding="utf-8",
                errors="replace",
            )
            if proc.returncode != 0:
                msg = str(proc.stdout or "").strip()
                suffix = ""
                try:
                    low = msg.lower()
                    if "cublas" in low or "cuda" in low:
                        suffix = " (πιθανόν λείπουν CUDA runtime DLLs ή δεν είναι συμβατό GPU build)."
                except Exception:
                    suffix = ""
                self.error.emit((msg if msg else f"Αποτυχία whisper.cpp (exit {proc.returncode}).") + suffix)
                return
            text_out = ""
            try:
                if os.path.exists(out_txt):
                    with open(out_txt, "r", encoding="utf-8", errors="replace") as f:
                        text_out = f.read()
            except Exception:
                text_out = ""
            text_out = str(text_out or "").strip()
            if not text_out:
                fallback = str(proc.stdout or "").strip()
                if fallback:
                    low = fallback.lower()
                    if "usage:" in low and "options:" in low:
                        self.error.emit("Whisper.cpp: αποτυχία μεταγραφής (έξοδος βοήθειας/usage).")
                        return
                    text_out = fallback
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.result.emit(text_out, float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class WhisperCppModelDownloadWorker(QThread):
    progress = pyqtSignal(int, str)
    finished = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, dst_path: str, url: str, label: str, timeout_s: int = 240, parent=None):
        super().__init__(parent)
        self.dst_path = str(dst_path or "").strip()
        self.url = str(url or "").strip()
        self.label = str(label or "").strip() or "Κατέβασμα μοντέλου…"
        self.timeout_s = int(timeout_s) if timeout_s is not None else 240

    def run(self):
        started = time.perf_counter()
        if not self.dst_path:
            self.error.emit("Λείπει διαδρομή μοντέλου.")
            return
        if not self.url:
            self.error.emit("Λείπει URL μοντέλου.")
            return
        try:
            os.makedirs(os.path.dirname(self.dst_path), exist_ok=True)
        except Exception:
            pass
        tmp_path = self.dst_path + ".tmp"
        try:
            self.progress.emit(0, self.label)
            req = urllib.request.Request(url=self.url, method="GET", headers={"User-Agent": "StomaDiagnosis"})
            with urllib.request.urlopen(req, timeout=max(1, self.timeout_s)) as resp:
                total = 0
                try:
                    total = int(resp.headers.get("Content-Length") or 0)
                except Exception:
                    total = 0
                done = 0
                with open(tmp_path, "wb") as f:
                    while True:
                        if self.isInterruptionRequested():
                            raise RuntimeError("Ακυρώθηκε.")
                        chunk = resp.read(1024 * 1024)
                        if not chunk:
                            break
                        f.write(chunk)
                        done += len(chunk)
                        if total > 0:
                            pct = int((done / total) * 100)
                            self.progress.emit(max(0, min(100, pct)), f"{self.label} {pct}%")
            os.replace(tmp_path, self.dst_path)
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(self.dst_path, float(elapsed_ms))
        except Exception as e:
            try:
                if os.path.exists(tmp_path):
                    os.remove(tmp_path)
            except Exception:
                pass
            self.error.emit(str(e))

class PiperSpeakWorker(QThread):
    finished = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, piper_cli: str, voice_model: str, text_in: str, volume: float = 1.0, length_scale: float | None = None, parent=None):
        super().__init__(parent)
        self.piper_cli = str(piper_cli or "").strip()
        self.voice_model = str(voice_model or "").strip()
        self.text_in = str(text_in or "")
        self.volume = float(volume) if volume is not None else 1.0
        self.length_scale = float(length_scale) if length_scale is not None else None

    def run(self):
        started = time.perf_counter()
        if not self.piper_cli or not os.path.exists(self.piper_cli):
            self.error.emit("Δεν βρέθηκε το piper.exe. Διάλεξε διαδρομή.")
            return
        if not self.voice_model or not os.path.exists(self.voice_model):
            self.error.emit("Δεν βρέθηκε voice model Piper (.onnx). Διάλεξε διαδρομή.")
            return
        txt = str(self.text_in or "").strip()
        if not txt:
            self.error.emit("Κενό κείμενο για ομιλία.")
            return
        try:
            tmp_dir = tempfile.mkdtemp(prefix="piper_")
            wav_path = os.path.join(tmp_dir, "tts.wav")
            cmd = [self.piper_cli, "--model", self.voice_model, "--output_file", wav_path]
            if self.length_scale is not None:
                cmd.extend(["--length_scale", str(self.length_scale)])
            subprocess.run(
                cmd,
                input=txt,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                timeout=120.0,
                text=True,
                encoding="utf-8",
                errors="replace",
            )
            if not os.path.exists(wav_path):
                self.error.emit("Το Piper δεν παρήγαγε wav αρχείο.")
                return
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(wav_path, float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class EdgeTTSSpeakWorker(QThread):
    finished = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, voice: str, text_in: str, rate: str = "+0%", volume: str = "+0%", parent=None):
        super().__init__(parent)
        self.voice = str(voice or "el-GR-AthinaNeural").strip()
        self.text_in = str(text_in or "").strip()
        self.rate = str(rate or "+0%").strip()
        self.volume = str(volume or "+0%").strip()

    def run(self):
        started = time.perf_counter()
        if not self.text_in:
            self.error.emit("Κενό κείμενο για ομιλία.")
            return
        
        try:
            # Check if edge-tts is available via python -m edge_tts
            # We use subprocess to call it as a CLI tool to avoid async issues in QThread
            # We assume python is in path or use sys.executable
            import sys
            
            tmp_dir = tempfile.mkdtemp(prefix="edgetts_")
            mp3_path = os.path.join(tmp_dir, "tts.mp3")
            
            cmd = [
                sys.executable, "-m", "edge_tts",
                "--voice", self.voice,
                "--text", self.text_in,
                "--write-media", mp3_path,
                "--rate", self.rate,
                "--volume", self.volume
            ]
            
            proc = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                timeout=120.0,
                text=True,
                encoding="utf-8",
                errors="replace",
            )
            
            if proc.returncode != 0:
                msg = str(proc.stdout or "").strip()
                self.error.emit(f"Edge-TTS error: {msg}")
                return

            if not os.path.exists(mp3_path):
                self.error.emit("Το Edge-TTS δεν παρήγαγε αρχείο ήχου.")
                return
                
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(mp3_path, float(elapsed_ms))
            
        except Exception as e:
            self.error.emit(str(e))

class ChatLLMWorker(QThread):
    result = pyqtSignal(str, object, float)
    error = pyqtSignal(str)

    def __init__(self, endpoint_url: str, payload: dict, timeout_ms: int = 2500, parent=None):
        super().__init__(parent)
        self.endpoint_url = str(endpoint_url or "").strip()
        self.payload = payload if isinstance(payload, dict) else {}
        self.timeout_ms = int(timeout_ms) if timeout_ms is not None else 2500

    def run(self):
        started = time.perf_counter()
        if not self.endpoint_url:
            self.error.emit("Δεν έχει οριστεί AI API URL.")
            return
        try:
            body = json.dumps(self.payload, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(url=self.endpoint_url, data=body, method="POST")
            req.add_header("Content-Type", "application/json; charset=utf-8")
            req.add_header("Accept", "application/json")
            with urllib.request.urlopen(req, timeout=max(0.1, self.timeout_ms / 1000.0)) as resp:
                raw = resp.read()
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            try:
                payload = json.loads(raw.decode("utf-8", errors="replace"))
            except Exception:
                payload = {"reply": raw.decode("utf-8", errors="replace")}

            reply = ""
            tool = None
            if isinstance(payload, dict):
                if payload.get("reply"):
                    reply = str(payload.get("reply") or "").strip()
                elif payload.get("text"):
                    reply = str(payload.get("text") or "").strip()
                elif isinstance(payload.get("message"), dict):
                    reply = str((payload.get("message") or {}).get("content") or "").strip()
                else:
                    reply = str(payload.get("message") or "").strip()
                tool = payload.get("tool") or payload.get("command") or payload.get("action")
            else:
                reply = str(payload).strip()

            self.result.emit(reply, tool, float(elapsed_ms))
        except urllib.error.HTTPError as e:
            try:
                raw = e.read()
                txt = raw.decode("utf-8", errors="replace")
                detail = ""
                try:
                    obj = json.loads(txt)
                    if isinstance(obj, dict):
                        detail = str(obj.get("error") or obj.get("message") or obj)
                    else:
                        detail = str(obj)
                except Exception:
                    detail = txt.strip()
                detail = (detail or "").strip()
                if len(detail) > 900:
                    detail = detail[:900]
                msg = f"HTTP {int(getattr(e, 'code', 0) or 0)}: {detail}" if detail else str(e)
                self.error.emit(msg)
                return
            except Exception:
                self.error.emit(str(e))
        except Exception as e:
            self.error.emit(str(e))

class ChatLLMStreamWorker(QThread):
    chunk = pyqtSignal(str)
    result = pyqtSignal(str, object, float)
    error = pyqtSignal(str)

    def __init__(self, endpoint_url: str, payload: dict, timeout_ms: int = 6000, parent=None):
        super().__init__(parent)
        self.endpoint_url = str(endpoint_url or "").strip()
        self.payload = payload if isinstance(payload, dict) else {}
        self.timeout_ms = int(timeout_ms) if timeout_ms is not None else 6000
        self._stop = False

    def request_stop(self):
        self._stop = True

    def run(self):
        started = time.perf_counter()
        if not self.endpoint_url:
            self.error.emit("Δεν έχει οριστεί AI API URL.")
            return
        try:
            body = json.dumps(self.payload, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(url=self.endpoint_url, data=body, method="POST")
            req.add_header("Content-Type", "application/json; charset=utf-8")
            req.add_header("Accept", "application/json")
            full = ""
            tool = None
            with urllib.request.urlopen(req, timeout=max(0.1, self.timeout_ms / 1000.0)) as resp:
                while not self._stop:
                    line = resp.readline()
                    if not line:
                        break
                    s = line.decode("utf-8", errors="replace").strip()
                    if not s:
                        continue
                    if s.startswith("data:"):
                        s = s[len("data:"):].strip()
                    if s == "[DONE]":
                        break
                    if s.startswith(":"):
                        continue
                    try:
                        obj = json.loads(s)
                    except Exception:
                        continue
                    if isinstance(obj, dict):
                        if obj.get("error"):
                            self.error.emit(str(obj.get("error") or "").strip() or "Σφάλμα από Ollama.")
                            return
                        msg = obj.get("message")
                        delta = ""
                        if isinstance(msg, dict):
                            delta = str(msg.get("content") or "")
                        elif obj.get("response"):
                            delta = str(obj.get("response") or "")
                        if delta:
                            full += delta
                            self.chunk.emit(delta)
                        if obj.get("tool") or obj.get("command") or obj.get("action"):
                            tool = obj.get("tool") or obj.get("command") or obj.get("action")
                        if bool(obj.get("done")):
                            break
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            if self._stop:
                self.error.emit("Ακυρώθηκε.")
                return
            out = str(full or "").strip()
            if not out and not tool:
                self.error.emit("Κενή απάντηση από Ollama (stream).")
                return
            self.result.emit(out, tool, float(elapsed_ms))
        except urllib.error.HTTPError as e:
            try:
                raw = e.read()
                txt = raw.decode("utf-8", errors="replace")
                detail = ""
                try:
                    obj = json.loads(txt)
                    if isinstance(obj, dict):
                        detail = str(obj.get("error") or obj.get("message") or obj)
                    else:
                        detail = str(obj)
                except Exception:
                    detail = txt.strip()
                detail = (detail or "").strip()
                if len(detail) > 900:
                    detail = detail[:900]
                msg = f"HTTP {int(getattr(e, 'code', 0) or 0)}: {detail}" if detail else str(e)
                self.error.emit(msg)
                return
            except Exception:
                self.error.emit(str(e))
        except Exception as e:
            self.error.emit(str(e))

class OpenAIChatWorker(QThread):
    result = pyqtSignal(str, object, float)
    error = pyqtSignal(str)

    def __init__(self, api_base: str, model: str, messages: list, want_json: bool = False, timeout_ms: int = 6000, parent=None):
        super().__init__(parent)
        self.api_base = str(api_base or "").strip() or "https://api.openai.com/v1"
        self.model = str(model or "").strip()
        self.messages = messages if isinstance(messages, list) else []
        self.want_json = bool(want_json)
        self.timeout_ms = int(timeout_ms) if timeout_ms is not None else 6000

    def run(self):
        started = time.perf_counter()
        api_key = str(os.environ.get("OPENAI_API_KEY") or "").strip()
        if not api_key:
            self.error.emit("Λείπει το OPENAI_API_KEY (environment variable).")
            return
        if not self.model:
            self.error.emit("Δεν έχει οριστεί Cloud model.")
            return
        try:
            url = self.api_base.rstrip("/") + "/chat/completions"
            body_obj = {
                "model": self.model,
                "messages": self.messages,
                "temperature": 0.2,
                "max_tokens": 160,
            }
            if self.want_json:
                body_obj["response_format"] = {"type": "json_object"}
            body = json.dumps(body_obj, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(url=url, data=body, method="POST")
            req.add_header("Content-Type", "application/json; charset=utf-8")
            req.add_header("Accept", "application/json")
            req.add_header("Authorization", f"Bearer {api_key}")
            with urllib.request.urlopen(req, timeout=max(0.1, self.timeout_ms / 1000.0)) as resp:
                raw = resp.read()
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            try:
                payload = json.loads(raw.decode("utf-8", errors="replace"))
            except Exception:
                payload = {}
            if isinstance(payload, dict) and isinstance(payload.get("error"), dict):
                msg = str((payload.get("error") or {}).get("message") or "Σφάλμα από Cloud API.")
                self.error.emit(msg)
                return
            content = ""
            try:
                choices = payload.get("choices") if isinstance(payload, dict) else None
                if isinstance(choices, list) and choices:
                    msg = (choices[0] or {}).get("message")
                    if isinstance(msg, dict):
                        content = str(msg.get("content") or "")
            except Exception:
                content = ""
            self.result.emit(str(content or "").strip(), None, float(elapsed_ms))
        except urllib.error.HTTPError as e:
            try:
                raw = e.read()
                payload = json.loads(raw.decode("utf-8", errors="replace"))
                if isinstance(payload, dict) and isinstance(payload.get("error"), dict):
                    self.error.emit(str((payload.get("error") or {}).get("message") or str(e)))
                    return
            except Exception:
                pass
            self.error.emit(str(e))
        except Exception as e:
            self.error.emit(str(e))

class OllamaTagsWorker(QThread):
    result = pyqtSignal(list, float)
    error = pyqtSignal(str)

    def __init__(self, base_url: str, timeout_ms: int = 1500, parent=None):
        super().__init__(parent)
        self.base_url = str(base_url or "").strip()
        self.timeout_ms = int(timeout_ms) if timeout_ms is not None else 1500

    def run(self):
        started = time.perf_counter()
        if not self.base_url:
            self.error.emit("Δεν έχει οριστεί AI API URL.")
            return
        try:
            url = str(self.base_url)
            if "/api/chat" in url:
                url = url.replace("/api/chat", "/api/tags")
            else:
                url = url.rstrip("/") + "/api/tags"
            req = urllib.request.Request(url=url, method="GET")
            req.add_header("Accept", "application/json")
            with urllib.request.urlopen(req, timeout=max(0.1, self.timeout_ms / 1000.0)) as resp:
                raw = resp.read()
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            try:
                payload = json.loads(raw.decode("utf-8", errors="replace"))
            except Exception:
                self.error.emit("Μη έγκυρη απάντηση από /api/tags.")
                return
            models = []
            if isinstance(payload, dict) and isinstance(payload.get("models"), list):
                for m in (payload.get("models") or []):
                    if isinstance(m, dict) and str(m.get("name") or "").strip():
                        models.append(str(m.get("name")).strip())
            self.result.emit(models, float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class OllamaPortableInstallWorker(QThread):
    progress = pyqtSignal(int, str)
    finished = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, zip_url: str, install_dir: str, parent=None):
        super().__init__(parent)
        self.zip_url = str(zip_url or "").strip()
        self.install_dir = str(install_dir or "").strip()

    def run(self):
        started = time.perf_counter()
        if not self.zip_url:
            self.error.emit("Λείπει URL για κατέβασμα Ollama.")
            return
        if not self.install_dir:
            self.error.emit("Λείπει φάκελος εγκατάστασης Ollama.")
            return
        try:
            os.makedirs(self.install_dir, exist_ok=True)
            zip_path = os.path.join(self.install_dir, "ollama-windows-amd64.zip")
            tmp_path = zip_path + ".tmp"
            self.progress.emit(0, "Κατέβασμα Ollama…")
            req = urllib.request.Request(url=self.zip_url, method="GET")
            with urllib.request.urlopen(req, timeout=60) as resp:
                total = 0
                try:
                    total = int(resp.headers.get("Content-Length") or 0)
                except Exception:
                    total = 0
                done = 0
                with open(tmp_path, "wb") as f:
                    while True:
                        if self.isInterruptionRequested():
                            try:
                                f.flush()
                            except Exception:
                                pass
                            try:
                                os.remove(tmp_path)
                            except Exception:
                                pass
                            self.error.emit("Ακυρώθηκε.")
                            return
                        chunk = resp.read(1024 * 1024)
                        if not chunk:
                            break
                        f.write(chunk)
                        done += len(chunk)
                        if total > 0:
                            pct = int((done / total) * 100)
                            self.progress.emit(max(0, min(100, pct)), f"Κατέβασμα Ollama… {pct}%")
            try:
                os.replace(tmp_path, zip_path)
            except Exception:
                zip_path = tmp_path

            self.progress.emit(0, "Αποσυμπίεση Ollama…")
            if self.isInterruptionRequested():
                self.error.emit("Ακυρώθηκε.")
                return
            with zipfile.ZipFile(zip_path, "r") as zf:
                zf.extractall(self.install_dir)
            try:
                os.remove(zip_path)
            except Exception:
                pass
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(self.install_dir, float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class WhisperCppPortableInstallWorker(QThread):
    progress = pyqtSignal(int, str)
    finished = pyqtSignal(str, str, float)
    error = pyqtSignal(str)

    def __init__(self, install_dir: str, parent=None):
        super().__init__(parent)
        self.install_dir = str(install_dir or "").strip()

    def _get_latest_whispercpp_windows_zip(self) -> str:
        api = "https://api.github.com/repos/ggml-org/whisper.cpp/releases/latest"
        req = urllib.request.Request(
            url=api,
            method="GET",
            headers={"Accept": "application/vnd.github+json", "User-Agent": "StomaDiagnosis"},
        )
        with urllib.request.urlopen(req, timeout=30) as resp:
            data = json.loads(resp.read().decode("utf-8", errors="replace") or "{}")
        assets = data.get("assets") if isinstance(data, dict) else None
        if not isinstance(assets, list):
            return ""
        best = ""
        for a in assets:
            if not isinstance(a, dict):
                continue
            name = str(a.get("name") or "").lower()
            url = str(a.get("browser_download_url") or "").strip()
            if not url:
                continue
            if not name.endswith(".zip"):
                continue
            if ("win" in name or "windows" in name) and ("x64" in name or "amd64" in name):
                if "bin" in name or "whisper" in name:
                    if not any(k in name for k in ("cublas", "cuda", "cu12", "cu11")):
                        best = url
                        break
        for a in assets:
            if not isinstance(a, dict):
                continue
            name = str(a.get("name") or "").lower()
            url = str(a.get("browser_download_url") or "").strip()
            if not url:
                continue
            if not name.endswith(".zip"):
                continue
            if ("win" in name or "windows" in name) and ("x64" in name or "amd64" in name):
                if "bin" in name or "whisper" in name:
                    if any(k in name for k in ("cublas", "cuda", "cu12", "cu11")):
                        if not best:
                            best = url
                    else:
                        best = url
                        break
        if best:
            return best
        for a in assets:
            if not isinstance(a, dict):
                continue
            name = str(a.get("name") or "").lower()
            url = str(a.get("browser_download_url") or "").strip()
            if url and name.endswith(".zip") and ("x64" in name or "amd64" in name):
                return url
        return ""

    def _download_file(self, url: str, dst_path: str, label: str, timeout: int = 60):
        tmp_path = dst_path + ".tmp"
        self.progress.emit(0, label)
        req = urllib.request.Request(url=str(url), method="GET", headers={"User-Agent": "StomaDiagnosis"})
        with urllib.request.urlopen(req, timeout=int(timeout)) as resp:
            total = 0
            try:
                total = int(resp.headers.get("Content-Length") or 0)
            except Exception:
                total = 0
            done = 0
            with open(tmp_path, "wb") as f:
                while True:
                    if self.isInterruptionRequested():
                        try:
                            f.flush()
                        except Exception:
                            pass
                        try:
                            os.remove(tmp_path)
                        except Exception:
                            pass
                        raise RuntimeError("Ακυρώθηκε.")
                    chunk = resp.read(1024 * 1024)
                    if not chunk:
                        break
                    f.write(chunk)
                    done += len(chunk)
                    if total > 0:
                        pct = int((done / total) * 100)
                        self.progress.emit(max(0, min(100, pct)), f"{label} {pct}%")
        os.replace(tmp_path, dst_path)

    def _find_exe(self, root_dir: str) -> str:
        candidates = []
        for base, _, files in os.walk(root_dir):
            for fn in files:
                low = fn.lower()
                if low in ("whisper-cli.exe", "main.exe", "whisper.exe"):
                    candidates.append(os.path.join(base, fn))
        for want in ("whisper-cli.exe", "main.exe", "whisper.exe"):
            for p in candidates:
                if os.path.basename(p).lower() == want:
                    return p
        return candidates[0] if candidates else ""

    def run(self):
        started = time.perf_counter()
        if not self.install_dir:
            self.error.emit("Λείπει φάκελος εγκατάστασης Whisper.cpp.")
            return
        try:
            os.makedirs(self.install_dir, exist_ok=True)
            zip_url = self._get_latest_whispercpp_windows_zip()
            if not zip_url:
                self.error.emit("Δεν βρέθηκε Windows zip για whisper.cpp.")
                return
            zip_path = os.path.join(self.install_dir, "whispercpp-windows-x64.zip")
            self._download_file(zip_url, zip_path, "Κατέβασμα Whisper.cpp…")
            self.progress.emit(0, "Αποσυμπίεση Whisper.cpp…")
            if self.isInterruptionRequested():
                self.error.emit("Ακυρώθηκε.")
                return
            with zipfile.ZipFile(zip_path, "r") as zf:
                zf.extractall(self.install_dir)
            try:
                os.remove(zip_path)
            except Exception:
                pass

            exe_path = self._find_exe(self.install_dir)
            if not exe_path or not os.path.exists(exe_path):
                self.error.emit("Δεν βρέθηκε whisper-cli.exe μέσα στο zip.")
                return

            models_dir = os.path.join(self.install_dir, "models")
            os.makedirs(models_dir, exist_ok=True)
            model_path = os.path.join(models_dir, "ggml-small.bin")
            if not os.path.exists(model_path):
                model_url = "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-small.bin?download=true"
                self._download_file(model_url, model_path, "Κατέβασμα Whisper model (small)…", timeout=240)

            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(str(exe_path), str(model_path), float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class PiperPortableInstallWorker(QThread):
    progress = pyqtSignal(int, str)
    finished = pyqtSignal(str, str, float)
    error = pyqtSignal(str)

    def __init__(self, install_dir: str, parent=None):
        super().__init__(parent)
        self.install_dir = str(install_dir or "").strip()

    def _download_file(self, url: str, dst_path: str, label: str, timeout: int = 60):
        tmp_path = dst_path + ".tmp"
        self.progress.emit(0, label)
        req = urllib.request.Request(url=str(url), method="GET", headers={"User-Agent": "StomaDiagnosis"})
        with urllib.request.urlopen(req, timeout=int(timeout)) as resp:
            total = 0
            try:
                total = int(resp.headers.get("Content-Length") or 0)
            except Exception:
                total = 0
            done = 0
            with open(tmp_path, "wb") as f:
                while True:
                    if self.isInterruptionRequested():
                        try:
                            f.flush()
                        except Exception:
                            pass
                        try:
                            os.remove(tmp_path)
                        except Exception:
                            pass
                        raise RuntimeError("Ακυρώθηκε.")
                    chunk = resp.read(1024 * 1024)
                    if not chunk:
                        break
                    f.write(chunk)
                    done += len(chunk)
                    if total > 0:
                        pct = int((done / total) * 100)
                        self.progress.emit(max(0, min(100, pct)), f"{label} {pct}%")
        os.replace(tmp_path, dst_path)

    def _find_piper_exe(self, root_dir: str) -> str:
        for base, _, files in os.walk(root_dir):
            for fn in files:
                if fn.lower() == "piper.exe":
                    return os.path.join(base, fn)
        return ""

    def run(self):
        started = time.perf_counter()
        if not self.install_dir:
            self.error.emit("Λείπει φάκελος εγκατάστασης Piper.")
            return
        try:
            os.makedirs(self.install_dir, exist_ok=True)
            zip_url = "https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_windows_amd64.zip"
            zip_path = os.path.join(self.install_dir, "piper_windows_amd64.zip")
            self._download_file(zip_url, zip_path, "Κατέβασμα Piper…", timeout=120)
            self.progress.emit(0, "Αποσυμπίεση Piper…")
            if self.isInterruptionRequested():
                self.error.emit("Ακυρώθηκε.")
                return
            with zipfile.ZipFile(zip_path, "r") as zf:
                zf.extractall(self.install_dir)
            try:
                os.remove(zip_path)
            except Exception:
                pass
            exe_path = self._find_piper_exe(self.install_dir)
            if not exe_path or not os.path.exists(exe_path):
                self.error.emit("Δεν βρέθηκε piper.exe μέσα στο zip.")
                return

            voices_dir = os.path.join(self.install_dir, "voices")
            os.makedirs(voices_dir, exist_ok=True)
            primary = "el_GR-rapunzelina-medium"
            fallback = "el_GR-rapunzelina-low"
            voice_base = primary
            voice_onnx = os.path.join(voices_dir, voice_base + ".onnx")
            voice_json = os.path.join(voices_dir, voice_base + ".onnx.json")
            try:
                if not os.path.exists(voice_onnx):
                    voice_url = "https://huggingface.co/rhasspy/piper-voices/resolve/main/el/el_GR/rapunzelina/medium/el_GR-rapunzelina-medium.onnx?download=true"
                    self._download_file(voice_url, voice_onnx, "Κατέβασμα Ελληνικής φωνής (Piper)…", timeout=240)
                if not os.path.exists(voice_json):
                    cfg_url = "https://huggingface.co/rhasspy/piper-voices/resolve/main/el/el_GR/rapunzelina/medium/el_GR-rapunzelina-medium.onnx.json?download=true"
                    self._download_file(cfg_url, voice_json, "Κατέβασμα config φωνής (Piper)…", timeout=90)
            except Exception:
                voice_base = fallback
                voice_onnx = os.path.join(voices_dir, voice_base + ".onnx")
                voice_json = os.path.join(voices_dir, voice_base + ".onnx.json")
                if not os.path.exists(voice_onnx):
                    voice_url = "https://huggingface.co/rhasspy/piper-voices/resolve/main/el/el_GR/rapunzelina/low/el_GR-rapunzelina-low.onnx?download=true"
                    self._download_file(voice_url, voice_onnx, "Κατέβασμα Ελληνικής φωνής (Piper)…", timeout=180)
                if not os.path.exists(voice_json):
                    cfg_url = "https://huggingface.co/rhasspy/piper-voices/resolve/main/el/el_GR/rapunzelina/low/el_GR-rapunzelina-low.onnx.json?download=true"
                    self._download_file(cfg_url, voice_json, "Κατέβασμα config φωνής (Piper)…", timeout=60)

            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(str(exe_path), str(voice_onnx), float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class OllamaPullWorker(QThread):
    progress = pyqtSignal(str)
    finished = pyqtSignal(str, float)
    error = pyqtSignal(str)

    def __init__(self, ollama_cli: str, model_name: str, parent=None):
        super().__init__(parent)
        self.ollama_cli = str(ollama_cli or "").strip()
        self.model_name = str(model_name or "").strip()
        self._proc = None

    def run(self):
        started = time.perf_counter()
        if not self.ollama_cli or not os.path.exists(self.ollama_cli):
            self.error.emit("Δεν βρέθηκε το ollama.exe. Πάτα «Εκκίνηση» για εγκατάσταση.")
            return
        if not self.model_name:
            self.error.emit("Δεν έχει οριστεί όνομα μοντέλου.")
            return
        try:
            cmd = [self.ollama_cli, "pull", self.model_name]
            self.progress.emit("Ξεκινάει κατέβασμα μοντέλου…")
            last_line = ""
            self._proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding="utf-8",
                errors="replace",
                bufsize=1,
                universal_newlines=True,
            )
            out = self._proc.stdout
            if out is not None:
                for ln in out:
                    if self.isInterruptionRequested():
                        try:
                            self._proc.terminate()
                        except Exception:
                            pass
                        self.error.emit("Ακυρώθηκε.")
                        return
                    s = str(ln or "").rstrip()
                    if s:
                        last_line = s
                        self.progress.emit(s)
            rc = None
            try:
                rc = self._proc.wait(timeout=3)
            except Exception:
                rc = self._proc.poll()
            if rc is None:
                self.error.emit("Δεν ολοκληρώθηκε η διεργασία pull.")
                return
            if int(rc) != 0:
                if last_line:
                    self.error.emit(last_line)
                else:
                    self.error.emit(f"Αποτυχία pull (exit code {rc}).")
                return
            elapsed_ms = (time.perf_counter() - started) * 1000.0
            self.finished.emit(self.model_name, float(elapsed_ms))
        except Exception as e:
            self.error.emit(str(e))

class ScanningBeamItem(QGraphicsRectItem):
    def __init__(self, rect, color=QColor(0, 255, 0, 100)):
        super().__init__(rect)
        self.setBrush(QBrush(color))
        self.setPen(QPen(Qt.PenStyle.NoPen))
        self.setZValue(100) # On top of everything

class ImageLoaderThread(QThread):
    finished_signal = pyqtSignal(QImage, object, str)

    def __init__(self, file_path):
        super().__init__()
        self.file_path = file_path

    def run(self):
        try:
            np_img = None
            qimg = None
            
            if self.file_path.lower().endswith('.dcm'):
                try:
                    ds = pydicom.dcmread(self.file_path)
                    pixel_array = ds.pixel_array
                    if 'PhotometricInterpretation' in ds and ds.PhotometricInterpretation == "MONOCHROME1":
                        pixel_array = np.amax(pixel_array) - pixel_array
                    
                    pixel_array = pixel_array.astype(float)
                    if pixel_array.max() > 0:
                        pixel_array = (np.maximum(pixel_array, 0) / pixel_array.max()) * 255.0
                    pixel_array = np.uint8(pixel_array)
                    
                    h, w = pixel_array.shape
                    qimg = QImage(pixel_array.data, w, h, w, QImage.Format.Format_Grayscale8)
                    qimg = qimg.copy() 
                    np_img = pixel_array
                except Exception as e:
                    print(f"DICOM Load Error: {e}")
                    qimg = QImage()
            else:
                qimg = QImage(self.file_path)
                try:
                    img = Image.open(self.file_path).convert('L')
                    np_img = np.array(img)
                except Exception:
                    np_img = None
            
            self.finished_signal.emit(qimg, np_img, self.file_path)
        except Exception as e:
            print(f"Image Loader Error: {e}")
            self.finished_signal.emit(QImage(), None, self.file_path)

class RadiographViewerWidget(QWidget):
    def __init__(self, radiograph_path=None, model_path=None, parent=None, origin_patient_id=None, origin_patient_name=None):
        super().__init__(parent)
        self.radiograph_path = radiograph_path
        self.origin_patient_id = origin_patient_id
        self.origin_patient_name = str(origin_patient_name or "").strip() or None
        if not self.origin_patient_name and self.origin_patient_id is not None:
            try:
                db = QSqlDatabase.database("patients_connection")
                query = QSqlQuery(db)
                query.prepare("SELECT last_name, first_name FROM patients WHERE patient_id=?")
                query.addBindValue(self.origin_patient_id)
                if query.exec() and query.next():
                    last_name = str(query.value(0) or "").strip()
                    first_name = str(query.value(1) or "").strip()
                    nm = f"{last_name} {first_name}".strip()
                    if nm:
                        self.origin_patient_name = nm
            except Exception:
                pass
        try:
            if self.origin_patient_name:
                self.setWindowTitle(f"Προβολή Ακτινογραφιών — {self.origin_patient_name}")
            elif self.origin_patient_id is not None:
                self.setWindowTitle(f"Προβολή Ακτινογραφιών — #{self.origin_patient_id}")
            else:
                self.setWindowTitle("Προβολή Ακτινογραφιών")
        except Exception:
            self.setWindowTitle("Προβολή Ακτινογραφιών")
        self.pixmap_item = None
        self.current_image_path = None
        self.analysis_results_items = []
        self.analysis_results = None
        self.thread = None
        self.worker = None
        self.image_loader = None
        self.boxes_visible = True
        self.jaw_separator_line = None
        self.vertical_separator_line = None
        self._spee_lower_overlay_item = None
        self.magic_wand_active = False
        self.missing_cell_mode = False
        self._last_wand_message_shown = False
        self.is_cropping = False
        self.crop_selection_item = None
        self.crop_start_pos = None
        self.grid_lines_v = []
        self.grid_lines_h = []
        self.grid_lines_v_upper = []
        self.grid_lines_v_lower = []
        self.grid_handle = None
        self.grid_active = False
        self.grid_visible = False
        self.grid_cell_label_map = {}
        self.auto_fdi_enabled = True
        self.snap_annotations_to_grid_on_drop = True
        self.corrections_mode_active = False
        self._corrections_prev_auto_fdi = None
        self.post_analysis_popup_enabled = True
        self._post_analysis_popup_message = ""
        self._analysis_text_dialog = None
        self._ai_timer = QTimer(self)
        try:
            self._ai_timer.setSingleShot(True)
            self._ai_timer.timeout.connect(self._on_ai_slider_timeout)
        except Exception:
            pass
        self._analysis_expected_secs = 153.0
        self._analysis_last_eta_secs = 0.0
        self._analysis_last_eta_progress = 0.0
        self._analysis_expected_secs = 153.0
        self.layout_locked = False
        self.grid_stats_items = [] # Items for grid statistics (density)
        self.analysis_items = []
        self.original_image_np = None
        self.view_mode = 1  # 0: All, 1: Labels Only
        self.change_overlay_item = None
        self.change_overlay_enabled = True
        self.change_overlay_alpha = 0.45
        self.change_overlay_percentile = 92.0
        self._change_overlay_cache_key = ""
        self._change_overlay_cached_pixmap = None
        self._change_overlay_cached_heat = None
        self.change_hotspots = []
        self.change_hotspot_items = []
        self._fdi_item_cache = {}
        self._fdi_item_cache_image_path = None
        self.view_fit_mode = "scene"
        self.manual_pan_enabled = False
        self._button_order_prefs = {}
        self.fdi_from_grid_enabled = False
        self.toolbar_reorder_enabled = False
        self._toolbar_rows = {}
        self._default_button_order = {}
        self.tools_location = "top"
        
        # Initialize project_root BEFORE using it
        self.project_root = str(Path(__file__).resolve().parents[2])
        
        # Anatomical Zoning (New Philosophy)
        self.zoning_mode_active = False
        self.zone_line_1 = None
        self.zone_line_2 = None
        self.zone_manager = AnatomicalZoneManager(self.project_root)
        
        # Calibration
        self.is_calibrating = False
        self.is_drawing_calibration = False
        self.calibration_line = None
        self.calib_line_x = None
        self.calib_line_y = None
        self.pixel_to_mm_scale = None # Default None until calibrated
        self.pixel_to_mm_scale_x = None
        self.pixel_to_mm_scale_y = None
        
        # Feedback / Online Learning
        self.project_root = str(Path(__file__).resolve().parents[2])
        base_root = Path(self.project_root)
        try:
            prefs = AppPrefs(Path(self.project_root))
            raw_selected = prefs.get("selected_model_path")
            raw_detect = prefs.get("selected_detect_model_path")
            raw_toothdet = prefs.get("selected_toothdet_model_path")
            raw_toothcls = prefs.get("selected_toothcls_model_path")
            try:
                s = str(raw_selected or "")
                s_low = s.replace("/", "\\").lower()
                is_toothdet = ("\\models\\secure\\toothdet\\" in s_low) or (os.path.basename(s_low).startswith("toothdet_"))
            except Exception:
                is_toothdet = False
            try:
                if raw_selected and raw_detect is None and raw_toothdet is None:
                    if is_toothdet:
                        prefs.set("selected_toothdet_model_path", raw_selected)
                        raw_detect = str(base_root / "models" / "stoma_default.pt") if (base_root / "models" / "stoma_default.pt").exists() else None
                        if raw_detect:
                            prefs.set("selected_detect_model_path", raw_detect)
                            prefs.set("selected_model_path", raw_detect)
                    else:
                        prefs.set("selected_detect_model_path", raw_selected)
                        raw_detect = raw_selected
            except Exception:
                pass
            self.detect_model_path = str(raw_detect or raw_selected or "")
            self.toothdet_model_path = str(raw_toothdet or "")
            self.toothcls_model_path = str(raw_toothcls or "")
        except Exception:
            self.detect_model_path = ""
            self.toothdet_model_path = ""
            self.toothcls_model_path = ""

        candidate = model_path
        if isinstance(candidate, Path):
            candidate = str(candidate)
        if not isinstance(candidate, str) or not candidate.strip() or not os.path.exists(candidate):
            default_pt = base_root / "models" / "stoma_default.pt"
            if default_pt.exists():
                candidate = str(default_pt)
            else:
                candidate = "yolov8n.pt"
        try:
            s = str(candidate or "")
            s_low = s.replace("/", "\\").lower()
            is_toothdet = ("\\models\\secure\\toothdet\\" in s_low) or (os.path.basename(s_low).startswith("toothdet_"))
        except Exception:
            is_toothdet = False
        if is_toothdet:
            if str(candidate) and not str(self.toothdet_model_path or "").strip():
                self.toothdet_model_path = str(candidate)
            if str(self.detect_model_path or "").strip() and os.path.exists(str(self.detect_model_path)):
                candidate = str(self.detect_model_path)
            else:
                default_pt = base_root / "models" / "stoma_default.pt"
                if default_pt.exists():
                    candidate = str(default_pt)
        self.model_path = candidate
        self.comm_stt_url = ""
        self.comm_stt_lang = "el"
        self.comm_stt_backend = "api"
        self.comm_whispercpp_cli = ""
        self.comm_whispercpp_model = ""
        self.comm_templates = {}
        self.comm_last_template = ""
        self.comm_aliases = {}
        self.comm_macros = {}
        self.comm_voice_auto_transcribe = False
        self.comm_voice_auto_send = False
        self.comm_voice_chat_enabled = False
        self.comm_voice_handsfree = False
        self.comm_voice_continuous = False
        self.comm_voice_push_to_talk = False
        self.comm_tts_enabled = False
        self.comm_action_tts_enabled = True
        self.comm_scan_tts_enabled = False
        self.comm_confirm_new_commands = False
        self.comm_confirm_threshold = 1
        self.comm_confirm_counts = {}
        self.comm_tts_backend = "qt"
        self.comm_piper_cli = ""
        self.comm_piper_voice_model = ""

        self.comm_tts_voice_id = ""
        self.comm_piper_length_scale = None
        self.comm_tts_rate = -0.25
        self.comm_tts_volume = 1.0
        self.comm_voice_force_cloud = False
        self.comm_ai_enabled = False
        self.comm_ai_auto_execute = True
        self.comm_learning_enabled = True
        self.comm_learning_auto_accept = False
        self.comm_conversation_enabled = True
        self.comm_ai_stream_enabled = True
        self.comm_memory_text = ""
        self.comm_patient_memory = {}
        self.comm_patient_ai_messages = {}
        self.auto_train_after_analysis = False
        self.auto_train_every_save = False
        self.auto_save_manual_edits = True
        self.auto_pipeline_enabled = True
        self.auto_analyze_on_open = True
        self.auto_sync_multiclass_on_save = True
        self.auto_pipeline_require_confirm = True
        self._pipeline_waiting_confirm = False
        self._pipeline_pending_after_save_data = None
        self.auto_detect_retrain_enabled = True
        self.auto_toothcls_train_enabled = True
        self.auto_detect_retrain_threshold = 8
        self.auto_toothcls_train_threshold = 30
        self.auto_detect_min_interval_s = 6 * 3600
        self.auto_toothcls_min_interval_s = 12 * 3600
        self._auto_detect_save_count = 0
        self._auto_toothcls_save_count = 0
        self._auto_detect_last_train_ts = 0.0
        self._auto_toothcls_last_train_ts = 0.0
        self._auto_detect_pending = False
        self._auto_toothcls_pending = False
        self.detect_training_worker = None
        self.detect_training_thread = None
        self.toothcls_training_worker = None
        self.toothcls_training_thread = None
        self.comm_llm_url = "http://localhost:11434/api/chat"
        self.comm_llm_model = "llama3.2:3b"
        self.comm_ai_backend_mode = "local"
        self.comm_cloud_api_base = "https://api.openai.com/v1"
        self.comm_cloud_model = "gpt-4o-mini"
        self._comm_cloud_api_key_dpapi = ""
        self.comm_llm_system_prompt = (
            "Είσαι κλινικός βοηθός οδοντιατρικής ακτινολογίας για πανοραμικές. "
            "Απάντα στα ελληνικά, σύντομα και πρακτικά. "
            "Στόχος: να βοηθήσεις τον χρήστη να ολοκληρώσει εργασία στο πρόγραμμα (ανάλυση, πλοήγηση, ρυθμίσεις εικόνας, επαλήθευση, εκπαίδευση). "
            "Μην επινοείς ευρήματα από εικόνα. Όταν δεν υπάρχουν δεδομένα, ζήτησε το ελάχιστο απαραίτητο ή πρότεινε ασφαλές επόμενο βήμα. "
            "Πρότεινε πάντα 1–2 συγκεκριμένες ενέργειες/εντολές του viewer που βοηθούν στο επόμενο βήμα. "
            "Να είσαι προδραστικός: όταν είναι ασφαλές, πρότεινε εντολή. "
            "Απέφυγε ιατρική διάγνωση/θεραπευτικές οδηγίες· περιορίσου σε υποβοήθηση χρήσης του εργαλείου και περιγραφική αναφορά."
        )
        self._ai_messages = []
        self._ai_pending_command = ""
        self._ai_pending_origin_phrase = ""
        self._ai_last_user_text = ""
        self._learn_pending_phrase = ""
        self._learn_pending_command = ""
        self._comm_known_commands = []
        self._voice_running = False
        self._voice_pcm = bytearray()
        self._voice_audio_source = None
        self._voice_audio_io = None
        self._voice_audio_timer = None
        self._last_voice_wav = b""
        self._speak_actions_active = False
        self._speak_actions_timer = None
        self._pending_confirm_action = ""
        self._pending_confirm_command = ""
        self._pending_confirm_prompt = ""
        self._prefs_save_timer = None
        self._layout_save_timer = None
        self._loaded_layout_from_sidecar = False
        self._loaded_layout_from_analysis = False
        self._layout_last_sig_by_image = {}
        self._layout_last_notify_at = 0.0
        self.comm_chat_visible = False
        self._load_viewer_prefs()
        try:
            self.auto_train_every_save = False
            self.auto_train_after_analysis = False
        except Exception:
            pass

        # --- Auto-detect Piper Greek Female Voice (Upgrade from Default Qt if available) ---
        if getattr(self, "comm_tts_backend", "qt") == "qt":
            try:
                _piper_exe = os.path.join(self.project_root, "data", "voice", "piper", "piper", "piper.exe")
                _rapunzelina = os.path.join(self.project_root, "data", "voice", "piper", "voices", "el_GR-rapunzelina-low.onnx")
                
                if os.path.exists(_piper_exe) and os.path.exists(_rapunzelina):
                    self.comm_tts_backend = "piper"
                    self.comm_piper_cli = _piper_exe
                    self.comm_piper_voice_model = _rapunzelina
                    self.comm_tts_enabled = True # Auto-enable TTS
                    self.comm_action_tts_enabled = True
            except Exception:
                pass
        # ---------------------------------------------------------------------------------

        self._tts_engine = None
        self._tts_kind = "none"
        self._init_tts_engine()
        self._autosave_timer = QTimer(self)
        self._autosave_timer.setSingleShot(True)
        self._autosave_timer.timeout.connect(self._autosave_current_analysis)
        self._autosave_reason = ""

        self.feedback_manager = FeedbackManager(self.project_root, auto_train=False, feedback_threshold=1, min_train_interval_s=0)
        self.feedback_manager.training_triggered.connect(self.on_training_triggered)
        self._auto_train_pending = False
        self._auto_train_run_name = None
        self._auto_train_params = None
        self._auto_train_data_stats = None
        self._last_saved_analysis_data = None
        try:
            self._apply_auto_train_policy()
        except Exception:
            pass

        self._session_started_at = datetime.now()
        self._session_events = []
        sessions_dir = Path("data/sessions")
        sessions_dir.mkdir(parents=True, exist_ok=True)
        sid = self._session_started_at.strftime("%Y%m%d_%H%M%S")
        pid = str(self.origin_patient_id) if self.origin_patient_id is not None else "general"
        self._session_file_path = sessions_dir / f"session_{pid}_{sid}.jsonl"
        self._session_log("session_started", {"patient_id": pid, "model_path": str(self.model_path)})

        self._trace_recording_active = False
        self._trace_started_at = None
        self._trace_events = []
        self._trace_file_path = None
        self._trace_stdout_path = None
        self._trace_last_rect_move_at = 0.0
        self._pipeline_steps = [
            ("image", "Εικόνα"),
            ("dups", "Διπλότυπα"),
            ("crop", "Αποκοπή"),
            ("calib", "Βαθμονόμηση"),
            ("lines", "Γραμμές"),
            ("grid", "Πλέγμα"),
            ("analysis", "Ανάλυση"),
            ("review", "Διόρθωση"),
            ("save", "Αποθήκευση"),
            ("sync", "Sync dataset"),
            ("train", "Εκπαίδευση"),
            ("eval", "Αξιολόγηση"),
        ]
        self._pipeline_state = {
            "current": "idle",
            "step_status": {k: "TODO" for k, _ in self._pipeline_steps},
            "last_hint": "",
        }
        try:
            self._pipeline_state["step_status"]["image"] = "WAIT"
        except Exception:
            pass
        try:
            self._pipeline_state["step_status"]["dups"] = "WAIT"
            self._pipeline_state["step_status"]["crop"] = "WAIT"
            self._pipeline_state["step_status"]["calib"] = "WAIT"
            self._pipeline_state["step_status"]["lines"] = "WAIT"
            self._pipeline_state["step_status"]["grid"] = "WAIT"
        except Exception:
            pass
        self._pipeline_prompted_crop = False
        self._pipeline_prompted_calib = False
        self._pipeline_waiting_hide_grid_before_analysis = False

        main_layout = QHBoxLayout(self)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        try:
            self.main_splitter.setChildrenCollapsible(True)
            self.main_splitter.setStretchFactor(0, 1)
            self.main_splitter.setStretchFactor(1, 3)
            self.main_splitter.setSizes([420, 980])
        except Exception:
            pass
        try:
            self.main_splitter.splitterMoved.connect(lambda *_: self._on_main_splitter_moved())
        except Exception:
            pass
        main_layout.addWidget(self.main_splitter, 1)
        
        # Left Layout Container
        self.left_widget = QWidget()
        self.left_widget.setMinimumWidth(320)  # Enforce minimum width
        self.left_layout = QVBoxLayout(self.left_widget)

        self.patient_name_label = QLabel("")
        try:
            if self.origin_patient_name:
                self.patient_name_label.setText(f"Ασθενής: {self.origin_patient_name}")
            elif self.origin_patient_id is not None:
                self.patient_name_label.setText(f"Ασθενής: #{self.origin_patient_id}")
            else:
                self.patient_name_label.setVisible(False)
        except Exception:
            pass
        try:
            self.patient_name_label.setStyleSheet("font-weight: bold; color: #0d6efd;")
        except Exception:
            pass
        self.left_layout.addWidget(self.patient_name_label)
        
        self.image_list_widget = QListWidget()
        self.image_list_widget.itemClicked.connect(self.display_selected_image)
        
        self.results_tabs = QTabWidget()
        
        self.results_text_edit = QTextEdit()
        self.results_text_edit.setReadOnly(True)
        self.results_tabs.addTab(self.results_text_edit, "Κείμενο")
        
        self.odontogram_table = QTableWidget()
        try:
            self.odontogram_table.setRowCount(4)
            self.odontogram_table.setColumnCount(8)
            self.odontogram_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
            self.odontogram_table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
            self.odontogram_table.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            self.odontogram_table.setAlternatingRowColors(False)
            self.odontogram_table.setShowGrid(True)
            self.odontogram_table.verticalHeader().setVisible(True)
            self.odontogram_table.horizontalHeader().setVisible(False)
            self.odontogram_table.verticalHeader().setDefaultSectionSize(52)
            self.odontogram_table.horizontalHeader().setDefaultSectionSize(58)
            self.odontogram_table.setVerticalHeaderLabels(["Άνω Δεξιά", "Άνω Αριστερά", "Κάτω Αριστερά", "Κάτω Δεξιά"])
        except Exception:
            pass
        self._init_odontogram_cells()
        
        # Odontogram Tab Container
        self.odontogram_tab_widget = QWidget()
        self.odontogram_tab_layout = QVBoxLayout(self.odontogram_tab_widget)
        self.odontogram_tab_layout.setContentsMargins(0, 0, 0, 0)
        self.odontogram_tab_layout.addWidget(self.odontogram_table)
        
        # Save Button for Odontogram (Requested by user)
        self.save_odontogram_button = QPushButton("Αποθήκευση")
        self.save_odontogram_button.setToolTip("Αποθήκευση Ανάλυσης")
        self.save_odontogram_button.clicked.connect(self.save_edited_results)
        self.save_odontogram_button.setEnabled(False)
        self.save_odontogram_button.setStyleSheet("""
            QPushButton {
                background-color: #27ae60; 
                color: white;
                font-weight: bold;
                padding: 6px;
                font-size: 14px;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
            }
        """)
        self.odontogram_tab_layout.addWidget(self.save_odontogram_button)
        
        self.results_tabs.addTab(self.odontogram_tab_widget, "Οδοντόγραμμα")
        
        self.left_splitter = QSplitter(Qt.Orientation.Vertical)
        try:
            self.left_splitter.setChildrenCollapsible(True)
            self.left_splitter.setStretchFactor(0, 3)
            self.left_splitter.setStretchFactor(1, 2)
            self.left_splitter.setSizes([420, 260])
        except Exception:
            pass
        try:
            self.left_splitter.splitterMoved.connect(lambda *_: self._on_left_splitter_moved())
        except Exception:
            pass
        self.left_splitter.addWidget(self.image_list_widget)
        self.left_splitter.addWidget(self.results_tabs)
        self.left_layout.addWidget(self.left_splitter, 1)
        try:
            self._apply_left_splitter_prefs()
        except Exception:
            pass
        
        try:
            self.main_splitter.addWidget(self.left_widget)
        except Exception:
            main_layout.addWidget(self.left_widget, 1)

        # Right Layout Container
        self.right_widget = QWidget()
        self.right_layout = QVBoxLayout(self.right_widget)
        self.right_splitter = QSplitter(Qt.Orientation.Vertical)
        self.right_layout.addWidget(self.right_splitter, 1)
        self.right_top_panel = QWidget()
        self.right_top_layout = QVBoxLayout(self.right_top_panel)
        self.right_top_layout.setContentsMargins(0, 0, 0, 0)
        self.right_bottom_panel = QWidget()
        self.right_bottom_container = QWidget()
        self.right_bottom_layout = QVBoxLayout(self.right_bottom_container)
        self.right_bottom_layout.setContentsMargins(0, 0, 0, 0)
        self.right_bottom_scroll = QScrollArea()
        self.right_bottom_scroll.setWidgetResizable(True)
        self.right_bottom_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.right_bottom_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.right_bottom_scroll.setWidget(self.right_bottom_container)
        self.right_bottom_panel_layout = QVBoxLayout(self.right_bottom_panel)
        self.right_bottom_panel_layout.setContentsMargins(0, 0, 0, 0)
        self.right_bottom_header = QWidget()
        self.right_bottom_header_layout = QVBoxLayout(self.right_bottom_header)
        self.right_bottom_header_layout.setContentsMargins(0, 0, 0, 0)
        self.right_bottom_footer = QWidget()
        self.right_bottom_footer_layout = QVBoxLayout(self.right_bottom_footer)
        self.right_bottom_footer_layout.setContentsMargins(0, 0, 0, 0)
        try:
            self.right_bottom_footer_layout.setSpacing(6)
        except Exception:
            pass
        self.right_bottom_panel_layout.addWidget(self.right_bottom_header, 0)
        self.right_bottom_panel_layout.addWidget(self.right_bottom_scroll, 1)
        self.right_bottom_panel_layout.addWidget(self.right_bottom_footer, 0)
        self.right_splitter.addWidget(self.right_top_panel)
        self.right_splitter.addWidget(self.right_bottom_panel)
        try:
            self.right_splitter.setChildrenCollapsible(True)
            self.right_splitter.setCollapsible(0, True)
            self.right_splitter.setCollapsible(1, True)
            self.right_splitter.setStretchFactor(0, 3)
            self.right_splitter.setStretchFactor(1, 2)
            self.right_splitter.setSizes([520, 320])
        except Exception:
            pass
        try:
            self.right_bottom_scroll.setMinimumHeight(120)
            self.right_bottom_panel.setMinimumHeight(120)
        except Exception:
            pass
        try:
            self.right_splitter.splitterMoved.connect(lambda *_: self._on_right_splitter_moved())
        except Exception:
            pass
        try:
            self._apply_right_splitter_prefs()
        except Exception:
            pass
        try:
            self._apply_main_splitter_prefs()
        except Exception:
            pass

        # --- Top Toolbar (Actions) ---
        self.action_toolbar = QToolBar()
        try:
            self.action_toolbar.setObjectName("radiograph_action_toolbar")
        except Exception:
            pass
        try:
            self.action_toolbar.setMovable(False)
        except Exception:
            pass
        try:
            self.action_toolbar.setFloatable(False)
        except Exception:
            pass
        try:
            self.action_toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)
        except Exception:
            pass
        try:
            self.action_toolbar.setContextMenuPolicy(Qt.ContextMenuPolicy.PreventContextMenu)
        except Exception:
            pass
        try:
            self.action_toolbar.setStyleSheet("QToolBar{border:0; spacing:8px;} QToolButton{padding:4px 10px;}")
        except Exception:
            pass
        try:
            self.action_toolbar.setIconSize(QSize(18, 18))
        except Exception:
            pass
        try:
            self.action_toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)
        except Exception:
            pass

        def _compact_toolbar_button(btn: QPushButton, icon_pixmap, shortcut=None):
            try:
                btn.setIcon(self.style().standardIcon(icon_pixmap))
            except Exception:
                pass
            try:
                btn.setText("")
            except Exception:
                pass
            try:
                tip = str(btn.toolTip() or "").strip()
                base = tip if tip else str(getattr(btn, "_orig_text", "") or "").strip()
                if shortcut:
                    base = (base + f" ({shortcut})").strip()
                if base:
                    btn.setToolTip(base)
            except Exception:
                pass
            try:
                if shortcut:
                    btn.setShortcut(shortcut)
            except Exception:
                pass
            try:
                btn.setFixedSize(34, 28)
            except Exception:
                pass
            try:
                btn.setFlat(True)
            except Exception:
                pass
        
        self.add_image_button = QPushButton("Προσθήκη")
        self.add_image_button._orig_text = "Προσθήκη"
        self.add_image_button.setToolTip("Προσθήκη Νέας Ακτινογραφίας")
        self.add_image_button.clicked.connect(self.add_new_radiograph)
        self.add_image_button.clicked.connect(lambda: self._record_macro_step("προσθήκη ακτινογραφίας"))
        _compact_toolbar_button(self.add_image_button, QStyle.StandardPixmap.SP_DialogOpenButton, "Ctrl+O")
        self.action_toolbar.addWidget(self.add_image_button)
        
        # --- NEW: Delete Button in Action Toolbar ---
        self.delete_item_button = QPushButton("Διαγραφή")
        self.delete_item_button._orig_text = "Διαγραφή"
        self.delete_item_button.setToolTip("Διαγραφή Επιλεγμένων (Del)")
        self.delete_item_button.clicked.connect(self.delete_selected_items_action)
        _compact_toolbar_button(self.delete_item_button, QStyle.StandardPixmap.SP_TrashIcon, "Del")
        self.action_toolbar.addWidget(self.delete_item_button)
        # ---------------------------------------------
        
        self.manage_duplicates_button = QPushButton("Διπλότυπα")
        self.manage_duplicates_button._orig_text = "Διπλότυπα"
        self.manage_duplicates_button.setToolTip("Διαχείριση Διπλότυπων Εικόνων")
        self.manage_duplicates_button.clicked.connect(self.manage_duplicate_images)
        self.manage_duplicates_button.clicked.connect(lambda: self._record_macro_step("διπλότυπα"))
        _compact_toolbar_button(self.manage_duplicates_button, QStyle.StandardPixmap.SP_FileDialogDetailedView)
        self.action_toolbar.addWidget(self.manage_duplicates_button)
        
        self.analyze_button = QPushButton("Ανάλυση")
        self.analyze_button._orig_text = "Ανάλυση"
        self.analyze_button.setToolTip("Ανάλυση με AI")
        self.analyze_button.clicked.connect(self.analyze_image_with_ai)
        self.analyze_button.clicked.connect(lambda: self._record_macro_step("ανάλυση"))
        self.analyze_button.setEnabled(False)
        _compact_toolbar_button(self.analyze_button, QStyle.StandardPixmap.SP_MediaPlay)
        self.action_toolbar.addWidget(self.analyze_button)

        self.abort_button = QPushButton("Διακοπή")
        self.abort_button._orig_text = "Διακοπή"
        self.abort_button.setToolTip("Διακοπή ενεργής ανάλυσης")
        self.abort_button.clicked.connect(self._on_abort_clicked)
        self.abort_button.clicked.connect(lambda: self._record_macro_step("διακοπή ανάλυσης"))
        self.abort_button.setEnabled(False)
        _compact_toolbar_button(self.abort_button, QStyle.StandardPixmap.SP_BrowserStop)
        try:
            self.abort_button.setStyleSheet("color: #e74c3c; font-weight: bold;")
        except Exception:
            pass
        self.action_toolbar.addWidget(self.abort_button)

        self.record_button = QPushButton("Record")
        self.record_button._orig_text = "Record"
        self.record_button.setToolTip("Καταγραφή κινήσεων/ανάλυσης για debugging")
        try:
            self.record_button.setCheckable(True)
        except Exception:
            pass
        self.record_button.clicked.connect(self._toggle_trace_recording)
        _compact_toolbar_button(self.record_button, QStyle.StandardPixmap.SP_DialogYesButton, "Ctrl+R")
        try:
            self.record_button.setText("REC")
        except Exception:
            pass
        try:
            self.record_button.setFixedSize(54, 28)
        except Exception:
            pass
        try:
            self.record_button.setFlat(False)
        except Exception:
            pass
        try:
            self.record_button.setStyleSheet(
                "QPushButton{background:#2b2b2b;color:#ffffff;border:1px solid #555;border-radius:6px;padding:2px 8px;font-weight:700;}"
                "QPushButton:checked{background:#b00020;border:1px solid #ff6b81;}"
            )
        except Exception:
            pass
        self.action_toolbar.addWidget(self.record_button)

        self.transfer_prev_button = QPushButton("Μεταφορά")
        self.transfer_prev_button._orig_text = "Μεταφορά"
        self.transfer_prev_button.setToolTip("Μεταφορά προηγούμενης ανάλυσης στην τρέχουσα εικόνα")
        self.transfer_prev_button.clicked.connect(self.transfer_previous_analysis)
        try:
            self.transfer_prev_button.clicked.connect(lambda: self._record_macro_step("μεταφορά προηγούμενης"))
        except Exception:
            pass
        self.transfer_prev_button.setEnabled(False)
        _compact_toolbar_button(self.transfer_prev_button, QStyle.StandardPixmap.SP_ArrowForward)
        self.action_toolbar.addWidget(self.transfer_prev_button)

        self.change_overlay_button = QPushButton("Αλλαγές")
        self.change_overlay_button._orig_text = "Αλλαγές"
        self.change_overlay_button.setToolTip("Προεπισκόπηση αλλαγών σε σχέση με προηγούμενη ακτινογραφία")
        self.change_overlay_button.setCheckable(True)
        self.change_overlay_button.clicked.connect(self.toggle_change_overlay)
        try:
            self.change_overlay_button.clicked.connect(lambda: self._record_macro_step("αλλαγές"))
        except Exception:
            pass
        self.change_overlay_button.setEnabled(False)
        _compact_toolbar_button(self.change_overlay_button, QStyle.StandardPixmap.SP_FileDialogContentsView)
        self.action_toolbar.addWidget(self.change_overlay_button)

        self.verify_button = QPushButton("Επαλήθευση")
        self.verify_button._orig_text = "Επαλήθευση"
        self.verify_button.setToolTip("Επαλήθευση Επανάλυσης")
        self.verify_button.clicked.connect(self.verify_reanalysis)
        self.verify_button.clicked.connect(lambda: self._record_macro_step("επαλήθευση"))
        self.verify_button.setEnabled(False)
        _compact_toolbar_button(self.verify_button, QStyle.StandardPixmap.SP_DialogApplyButton)
        self.action_toolbar.addWidget(self.verify_button)
        try:
            self.action_toolbar.addSeparator()
        except Exception:
            pass
        
        self.export_button = QPushButton("Εξαγωγή")
        self.export_button._orig_text = "Εξαγωγή"
        self.export_button.setToolTip("Εξαγωγή Αποτελεσμάτων")
        self.export_button.clicked.connect(self.export_results_to_text)
        self.export_button.clicked.connect(lambda: self._record_macro_step("εξαγωγή"))
        self.export_button.setEnabled(False)
        _compact_toolbar_button(self.export_button, QStyle.StandardPixmap.SP_ArrowDown, "Ctrl+E")
        self.action_toolbar.addWidget(self.export_button)

        self.analysis_text_button = QPushButton("Κείμενο")
        self.analysis_text_button._orig_text = "Κείμενο Ανάλυσης"
        self.analysis_text_button.setToolTip("Κείμενο Ανάλυσης")
        self.analysis_text_button.clicked.connect(self.open_analysis_text_dialog)
        self.analysis_text_button.clicked.connect(lambda: self._record_macro_step("κείμενο ανάλυσης"))
        self.analysis_text_button.setEnabled(False)
        _compact_toolbar_button(self.analysis_text_button, QStyle.StandardPixmap.SP_FileDialogContentsView, "Ctrl+T")
        self.action_toolbar.addWidget(self.analysis_text_button)

        self.save_analysis_button = QPushButton("Αποθήκευση")
        self.save_analysis_button._orig_text = "Αποθήκευση"
        self.save_analysis_button.setToolTip("Αποθήκευση Ανάλυσης")
        self.save_analysis_button.clicked.connect(self.save_edited_results)
        self.save_analysis_button.clicked.connect(lambda: self._record_macro_step("αποθήκευση ανάλυσης"))
        self.save_analysis_button.setEnabled(False)
        _compact_toolbar_button(self.save_analysis_button, QStyle.StandardPixmap.SP_DialogSaveButton, "Ctrl+S")
        self.action_toolbar.addWidget(self.save_analysis_button)

        self.train_model_button = QPushButton("Εκπαίδευση")
        self.train_model_button._orig_text = "Εκπαίδευση Μοντέλου"
        self.train_model_button.setToolTip("Εκπαίδευση μοντέλου από τις διορθώσεις (διαφορές vs AI)")
        self.train_model_button.clicked.connect(self._on_train_model_button_clicked)
        try:
            self.train_model_button.clicked.connect(lambda: self._record_macro_step("εκπαίδευση μοντέλου"))
        except Exception:
            pass
        self.train_model_button.setEnabled(False)
        _compact_toolbar_button(self.train_model_button, QStyle.StandardPixmap.SP_BrowserReload, "Ctrl+M")
        self.action_toolbar.addWidget(self.train_model_button)

        self.history_button = QPushButton("Ιστορικό")
        self.history_button._orig_text = "Ιστορικό"
        self.history_button.clicked.connect(self.show_history_dialog)
        self.history_button.clicked.connect(lambda: self._record_macro_step("ιστορικό"))
        _compact_toolbar_button(self.history_button, QStyle.StandardPixmap.SP_FileDialogInfoView, "Ctrl+H")
        self.action_toolbar.addWidget(self.history_button)

        self.clear_analysis_button = QPushButton("Καθαρισμός")
        self.clear_analysis_button._orig_text = "Καθαρισμός"
        self.clear_analysis_button.setToolTip("Καθαρισμός Ανάλυσης")
        self.clear_analysis_button.clicked.connect(self.clear_analysis)
        self.clear_analysis_button.clicked.connect(lambda: self._record_macro_step("καθαρισμός ανάλυσης"))
        self.clear_analysis_button.setEnabled(False)
        _compact_toolbar_button(self.clear_analysis_button, QStyle.StandardPixmap.SP_TrashIcon, "Del")
        self.action_toolbar.addWidget(self.clear_analysis_button)

        self.delete_image_button = QPushButton("Διαγραφή Εικόνας")
        self.delete_image_button._orig_text = "Διαγραφή Εικόνας"
        self.delete_image_button.setToolTip("Διαγραφή πανοραμικής κακής ποιότητας από το αρχείο")
        self.delete_image_button.clicked.connect(self._on_delete_current_radiograph_clicked)
        self.delete_image_button.setEnabled(False)
        _compact_toolbar_button(self.delete_image_button, QStyle.StandardPixmap.SP_DialogDiscardButton)
        self.action_toolbar.addWidget(self.delete_image_button)
        self.right_top_layout.addWidget(self.action_toolbar)

        # --- Graphics View ---
        self.scene = QGraphicsScene()
        self.view = CustomGraphicsView(self.scene, parent=self)
        self.view.setMinimumHeight(260)
        self.right_top_layout.addWidget(self.view, 1)

        # --- PRIMARY TOOLS ROW (DIRECTLY BELOW IMAGE) ---
        self.primary_tools_widget = QWidget()
        self.primary_tools_layout = QHBoxLayout(self.primary_tools_widget)
        self.primary_tools_layout.setContentsMargins(5, 5, 5, 5)
        self.primary_tools_layout.setSpacing(10)
        self.right_top_layout.addWidget(self.primary_tools_widget)

        # 1. Calibration (Priority 1)
        self.calibration_button = QPushButton("Βαθμονόμηση")
        self.calibration_button.setCheckable(True)
        self.calibration_button.setMinimumWidth(120)
        self.calibration_button.setFixedHeight(40) # Taller button
        self.calibration_button.setStyleSheet("""
            QPushButton {
                background-color: #c0392b; 
                color: white; 
                font-weight: bold; 
                font-size: 14px;
                border-radius: 5px;
            }
            QPushButton:checked {
                background-color: #e74c3c;
                border: 2px solid white;
            }
        """)
        self.calibration_button.clicked.connect(self.toggle_calibration_mode)
        self.calibration_button.clicked.connect(lambda: self._record_macro_step("βαθμονόμηση"))
        self.primary_tools_layout.addWidget(self.calibration_button)
        
        # 2. Magic Wand
        self.magic_wand_button = QPushButton("Μαγικό Ραβδί")
        self.magic_wand_button.setCheckable(True)
        self.magic_wand_button.setFixedHeight(40)
        self.magic_wand_button.clicked.connect(self.toggle_magic_wand_mode)
        self.magic_wand_button.clicked.connect(lambda: self._record_macro_step("μαγικό ραβδί"))
        self.primary_tools_layout.addWidget(self.magic_wand_button)

        # 3. Edit Zones (Manual) - RENAMED TO "Ανίχνευση Ζωνών" & Changed Color
        self.zoning_edit_button = QPushButton("Ανίχνευση Ζωνών") # Changed Label
        self.zoning_edit_button.setCheckable(True)
        self.zoning_edit_button.setFixedHeight(40)
        self.zoning_edit_button.setToolTip("Εκκίνηση οδηγού ανίχνευσης και διόρθωσης ζωνών (Βήμα-Βήμα)")
        self.zoning_edit_button.clicked.connect(lambda: self.toggle_zoning_mode(self.zoning_edit_button.isChecked()))
        self.zoning_edit_button.setStyleSheet("""
            QPushButton {
                background-color: #27ae60; 
                color: white;
                border-radius: 5px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:checked {
                background-color: #2ecc71;
                border: 2px solid white;
            }
        """)
        self.primary_tools_layout.addWidget(self.zoning_edit_button)

        # Manual ROI Button
        self.manual_roi_button = QPushButton("Ζώνη Σάρωσης")
        self.manual_roi_button.setCheckable(True)
        self.manual_roi_button.setFixedHeight(40)
        self.manual_roi_button.setToolTip("Χειροκίνητος ορισμός της περιοχής σάρωσης (ROI).")
        self.manual_roi_button.clicked.connect(self.toggle_manual_roi)
        self.manual_roi_button.setStyleSheet("""
            QPushButton {
                background-color: #8e44ad; 
                color: white;
                border-radius: 5px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:checked {
                background-color: #9b59b6;
                border: 2px solid white;
            }
        """)
        self.primary_tools_layout.addWidget(self.manual_roi_button)

        # 4. Scan Verification (Visual) - RESTORED & IMPROVED (Blue Line / Midline Outwards)
        self.zoning_scan_button = QPushButton("Σάρωση Επαλήθευσης")
        self.zoning_scan_button.setCheckable(False)
        self.zoning_scan_button.setFixedHeight(40)
        self.zoning_scan_button.setToolTip("Ενεργοποιεί την Οπτική Σάρωση (Μπλε Γραμμή) για επιβεβαίωση της αρίθμησης από τη μέση γραμμή.")
        self.zoning_scan_button.clicked.connect(self._on_zoning_scan_button_clicked)
        self.zoning_scan_button.setStyleSheet("""
            QPushButton {
                background-color: #2980b9;
                color: white;
                border-radius: 5px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:checked {
                background-color: #3498db;
                border: 2px solid white;
            }
        """)
        self.primary_tools_layout.addWidget(self.zoning_scan_button)

        # Speed Controller
        speed_layout = QHBoxLayout()
        speed_layout.setContentsMargins(0, 0, 0, 0)
        speed_lbl = QLabel("Ταχύτητα:")
        speed_lbl.setStyleSheet("font-size: 10px; font-weight: bold; color: #555;")
        speed_layout.addWidget(speed_lbl)
        
        self.scan_speed_slider = QSlider(Qt.Orientation.Horizontal)
        self.scan_speed_slider.setRange(10, 200) # 10ms (fast) to 200ms (slow)
        self.scan_speed_slider.setValue(40) # Default
        self.scan_speed_slider.setInvertedAppearance(True) # Left = Slow (200), Right = Fast (10)? No, usually Right is "More Speed" -> Lower Interval.
        # If InvertedAppearance=True: Min(Left)=High Value, Max(Right)=Low Value?
        # Standard: Left=Min, Right=Max.
        # We want Right=Fast (Low Interval). So Left=Slow (High Interval).
        # If Range is 10..200. Left=10 (Fast), Right=200 (Slow). This is counter-intuitive if we call it "Speed".
        # Better: Range 1..100 (Speed). Interval = K / Speed.
        # Let's keep it simple: "Delay" slider? Or "Speed" slider.
        # If "Speed", Right is Fast.
        # So slider value 0..100. Interval = 200 - (value * 1.9).
        # Let's use direct interval but inverted logic.
        self.scan_speed_slider.setInvertedAppearance(True) # Right side is Min value (10ms = Fast). Left side is Max value (200ms = Slow).
        self.scan_speed_slider.setFixedWidth(80)
        self.scan_speed_slider.setToolTip("Ρύθμιση ταχύτητας σάρωσης (Αριστερά=Αργά, Δεξιά=Γρήγορα)")
        self.scan_speed_slider.valueChanged.connect(self._update_scan_speed)
        speed_layout.addWidget(self.scan_speed_slider)
        
        # Add to a container widget to put in layout? Or just add layout?
        # primary_tools_layout is likely VBox or HBox.
        # If it's VBox, this adds a row.
        # If it's HBox, this adds elements.
        # The previous elements are buttons.
        # I'll wrap it in a widget to be safe.
        speed_widget = QWidget()
        speed_widget.setLayout(speed_layout)
        self.primary_tools_layout.addWidget(speed_widget)

        self.zoning_quadrant_combo = QComboBox()
        self.zoning_quadrant_combo.setFixedHeight(34)
        self.zoning_quadrant_combo.setToolTip("Επιλογή τεταρτημορίου για χειροκίνητη σάρωση/καταχώρηση FDI.")
        self.zoning_quadrant_combo.addItem("Άνω Δεξιό (11–18)", "q1")
        self.zoning_quadrant_combo.addItem("Άνω Αριστερό (21–28)", "q2")
        self.zoning_quadrant_combo.addItem("Κάτω Αριστερό (31–38)", "q3")
        self.zoning_quadrant_combo.addItem("Κάτω Δεξιό (41–48)", "q4")
        self.primary_tools_layout.addWidget(self.zoning_quadrant_combo)

        self.zoning_register_button = QPushButton("Καταχώρηση")
        self.zoning_register_button.setCheckable(False)
        self.zoning_register_button.setFixedHeight(40)
        self.zoning_register_button.setEnabled(False)
        self.zoning_register_button.setToolTip("Καταχώρηση δοντιού στην τρέχουσα θέση της βούλας.")
        self.zoning_register_button.clicked.connect(self._on_zoning_register_button_clicked)
        self.zoning_register_button.setStyleSheet("""
            QPushButton {
                background-color: #e67e22;
                color: white;
                border-radius: 5px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:disabled {
                background-color: #b0b0b0;
                color: #f0f0f0;
            }
        """)
        self.primary_tools_layout.addWidget(self.zoning_register_button)

        self.zoning_skip_button = QPushButton("Παράλειψη")
        self.zoning_skip_button.setCheckable(False)
        self.zoning_skip_button.setFixedHeight(40)
        self.zoning_skip_button.setEnabled(False)
        self.zoning_skip_button.setToolTip("Παράλειψη τρέχοντος δοντιού ως Ελλείπον και μετάβαση στο επόμενο.")
        self.zoning_skip_button.clicked.connect(self._on_zoning_skip_button_clicked)
        self.zoning_skip_button.setStyleSheet("""
            QPushButton {
                background-color: #8e44ad;
                color: white;
                border-radius: 5px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:disabled {
                background-color: #b0b0b0;
                color: #f0f0f0;
            }
        """)
        self.primary_tools_layout.addWidget(self.zoning_skip_button)

        # 5. Crop
        self.crop_button = QPushButton("Αποκοπή")
        self.crop_button.setCheckable(True)
        self.crop_button.setFixedHeight(40)
        self.crop_button.clicked.connect(self.toggle_crop_mode)
        self.crop_button.clicked.connect(lambda: self._record_macro_step("αποκοπή"))
        self.primary_tools_layout.addWidget(self.crop_button)
        
        self.primary_tools_layout.addStretch(1) # Push to left

        
        # Performance Optimization: Debounce recalculations
        self.recalc_timer = QTimer()
        self.recalc_timer.setSingleShot(True)
        self.recalc_timer.setInterval(150)  # 150ms delay
        self.recalc_timer.timeout.connect(self.recalculate_fdi)

        self._results_text_refresh_timer = QTimer()
        self._results_text_refresh_timer.setSingleShot(True)
        self._results_text_refresh_timer.setInterval(120)
        self._results_text_refresh_timer.timeout.connect(self._refresh_results_text_from_current_state)

        self._bulk_scene_update = False
        
        # --- Bottom Toolbar (Tools) ---
        tools_container = QTabWidget()
        self.tools_container = tools_container
        try:
            tools_container.setDocumentMode(True)
        except Exception:
            pass
        try:
            tools_container.setMovable(False)
        except Exception:
            pass
        try:
            tools_container.setUsesScrollButtons(True)
        except Exception:
            pass
        try:
            tools_container.setStyleSheet("QTabWidget::pane{border:0;} QTabBar::tab{padding:4px 10px;}")
        except Exception:
            pass
        try:
            tools_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        except Exception:
            pass
        try:
            tools_container.setMinimumHeight(180)
        except Exception:
            pass
        self.tools_tabs = tools_container

        def _make_tab(key: str):
            w = QWidget()
            outer = QVBoxLayout(w)
            outer.setContentsMargins(0, 0, 0, 0)
            outer.setSpacing(0)
            try:
                w._outer_layout = outer
            except Exception:
                pass

            sc = QScrollArea()
            sc.setWidgetResizable(True)
            sc.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
            sc.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            try:
                sc.setFrameShape(QFrame.Shape.NoFrame)
            except Exception:
                pass

            inner = DraggableButtonRow(self, key)
            try:
                self._toolbar_rows[str(key or "").strip() or "default"] = inner
            except Exception:
                pass
            row = QHBoxLayout(inner)
            row.setContentsMargins(0, 0, 0, 0)
            row.setSpacing(6)
            try:
                row.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
            except Exception:
                pass
            sc.setWidget(inner)
            try:
                sc.setAcceptDrops(True)
            except Exception:
                pass
            try:
                vp = sc.viewport()
                if vp is not None:
                    vp.setAcceptDrops(True)
            except Exception:
                vp = None
            try:
                fwd = _DragDropForwarder(inner, sc)
                sc.installEventFilter(fwd)
                if vp is not None:
                    vp.installEventFilter(fwd)
                sc._dd_fwd = fwd
            except Exception:
                pass
            try:
                # INCREASE HEIGHT to allow wrapping or multi-line if needed, or keep it fixed but allow scroll
                sc.setFixedHeight(60) # Increased from 44 to 60 to ensure visibility of taller buttons or scrollbar
            except Exception:
                pass
            outer.addWidget(sc)
            return w, row, inner
        
        self.toggle_boxes_button = QPushButton("Εμφάνιση Πλαισίων" if self.view_mode == 1 else "Απόκρυψη Πλαισίων")
        self.toggle_boxes_button.clicked.connect(self.toggle_box_visibility)
        self.toggle_boxes_button.clicked.connect(lambda: self._record_macro_step("πλαίσια"))
        
        # --- TAB: VIEW (BASIC) ---
        tab_view, row_view, row_view_inner = _make_tab("view")
        row_view.addWidget(self.toggle_boxes_button) # Add it here
        
        self.hide_all_annotations_button = QPushButton("Απόκρυψη Όλων")
        self.hide_all_annotations_button.setCheckable(True)
        self.hide_all_annotations_button.setToolTip("Κρύβει τα πάντα (πλαίσια, γραμμές, ζώνες) για καθαρή εικόνα")
        self.hide_all_annotations_button.clicked.connect(self.toggle_all_annotations_visibility)
        row_view.addWidget(self.hide_all_annotations_button)

        self.center_view_button = QPushButton("Κεντράρισμα")
        self.center_view_button.clicked.connect(self.center_view)
        self.center_view_button.clicked.connect(lambda: self._record_macro_step("κεντράρισμα"))
        row_view.addWidget(self.center_view_button)
        
        # ... (rest of view buttons)

        # --- TAB: TOOLS (REMOVED - CLEANUP) ---
        # The tools are now in self.primary_tools_widget below the image
        # tab_tools, row_tools, row_tools_inner = _make_tab("tools")
        # self.tools_tabs.addTab(tab_tools, "Εργαλεία") 
        
        self.auto_fdi_checkbox = QCheckBox("Auto FDI")

        self.fit_height_button = QPushButton("Fit Ύψος")
        self.fit_height_button.setToolTip("Μεγιστοποίηση ύψους (με middle-drag για μετακίνηση).")
        self.fit_height_button.setCheckable(True)
        try:
            self.fit_height_button.blockSignals(True)
            self.fit_height_button.setChecked(str(getattr(self, "view_fit_mode", "scene") or "scene") == "height")
            self.fit_height_button.blockSignals(False)
        except Exception:
            try:
                self.fit_height_button.blockSignals(False)
            except Exception:
                pass
        self.fit_height_button.clicked.connect(self.toggle_fit_height)
        try:
            self.fit_height_button.clicked.connect(lambda: self._record_macro_step("fit height"))
        except Exception:
            pass
        row_view.addWidget(self.fit_height_button)

        self.pan_button = QPushButton("Μετακίνηση")
        self.pan_button.setToolTip("Μετακίνησε την εικόνα με σύρσιμο (Space+drag ή ενεργό toggle).")
        self.pan_button.setCheckable(True)
        self.pan_button.setChecked(False)
        self.pan_button.clicked.connect(self.toggle_manual_pan)
        try:
            self.pan_button.clicked.connect(lambda: self._record_macro_step("μετακίνηση"))
        except Exception:
            pass
        row_view.addWidget(self.pan_button)

        self.toolbar_layout_button = QPushButton("Διάταξη Κουμπιών…")
        self.toolbar_layout_button.setToolTip("Διαμόρφωση σειράς κουμπιών ανά tab.")
        self.toolbar_layout_button.clicked.connect(self._open_toolbar_layout_dialog)
        # row_view.addWidget(self.toolbar_layout_button) # REMOVED

        self.screen_layout_button = QPushButton("Θέση Εργαλείων…")
        self.screen_layout_button.setToolTip("Μετακίνησε την εργαλειοθήκη πάνω/κάτω στην οθόνη.")
        self.screen_layout_button.clicked.connect(self._open_screen_layout_dialog)
        # row_view.addWidget(self.screen_layout_button) # REMOVED

        self.transfer_prev_quick_button = QPushButton("Μεταφορά")
        self.transfer_prev_quick_button.setToolTip("Μεταφορά προηγούμενης ανάλυσης στην τρέχουσα εικόνα")
        self.transfer_prev_quick_button.clicked.connect(self.transfer_previous_analysis)
        try:
            self.transfer_prev_quick_button.clicked.connect(lambda: self._record_macro_step("μεταφορά προηγούμενης"))
        except Exception:
            pass
        self.transfer_prev_quick_button.setEnabled(False)
        # row_view.addWidget(self.transfer_prev_quick_button) # REMOVED

        self.change_overlay_quick_button = QPushButton("Αλλαγές")
        self.change_overlay_quick_button.setToolTip("Προεπισκόπηση αλλαγών σε σχέση με προηγούμενη ακτινογραφία")
        self.change_overlay_quick_button.setCheckable(True)
        self.change_overlay_quick_button.clicked.connect(self.toggle_change_overlay)
        try:
            self.change_overlay_quick_button.clicked.connect(lambda: self._record_macro_step("αλλαγές"))
        except Exception:
            pass
        self.change_overlay_quick_button.setEnabled(False)
        # row_view.addWidget(self.change_overlay_quick_button) # REMOVED

        self.hotspot_combo = QComboBox()
        self.hotspot_combo.setToolTip("Hotspots αλλαγών (κλικ σε marker ή /spot N)")
        # row_view.addWidget(self.hotspot_combo) # REMOVED



        self.jaw_lines_quick_button = QPushButton("Γραμμές")
        self.jaw_lines_quick_button.clicked.connect(lambda: tools_container.setCurrentWidget(tab_grid))
        self.jaw_lines_quick_button.clicked.connect(self.toggle_jaw_lines)
        # row_view.addWidget(self.jaw_lines_quick_button) # REMOVED

        self.lock_layout_quick_checkbox = QCheckBox("Κλείδωμα")
        self.lock_layout_quick_checkbox.blockSignals(True)
        self.lock_layout_quick_checkbox.setChecked(bool(self.layout_locked))
        self.lock_layout_quick_checkbox.blockSignals(False)
        # row_view.addWidget(self.lock_layout_quick_checkbox) # REMOVED

        self.corrections_mode_quick_button = QPushButton("Διορθώσεις")
        self.corrections_mode_quick_button.setCheckable(True)
        self.corrections_mode_quick_button.setToolTip("Χειροκίνητες διορθώσεις: χωρίς Auto FDI")
        self.corrections_mode_quick_button.clicked.connect(lambda: self._set_corrections_mode(bool(self.corrections_mode_quick_button.isChecked()), announce=True))
        # row_view.addWidget(self.corrections_mode_quick_button) # REMOVED

        self.corrections_mode_button = QPushButton("Διορθώσεις")
        self.corrections_mode_button.setCheckable(True)
        self.corrections_mode_button.setToolTip("Παγώνει Auto FDI για χειροκίνητες διορθώσεις")
        self.corrections_mode_button.clicked.connect(self.toggle_corrections_mode)
        # row_grid.addWidget(self.corrections_mode_button) # REMOVED for New Philosophy

        self.jaw_lines_button = QPushButton("Γραμμές")
        self.jaw_lines_button.clicked.connect(self.toggle_jaw_lines)
        # row_grid.addWidget(self.jaw_lines_button) # REMOVED for New Philosophy

        self.missing_tooth_button = QPushButton("Ελλείπον (κελί)")
        self.missing_tooth_button.setCheckable(True)
        self.missing_tooth_button.clicked.connect(self.toggle_missing_tooth_mode)
        # tab_tools, row_tools, row_tools_inner = _make_tab("tools")
        # row_tools.addWidget(self.missing_tooth_button) # REMOVED for New Philosophy
        
        # --- TAB: TOOLS (REMOVED - MOVED TO PRIMARY ROW) ---
        # The tools are now in self.primary_tools_widget below the image
        # tab_tools, row_tools, row_tools_inner = _make_tab("tools")
        # self.tools_tabs.addTab(tab_tools, "Εργαλεία") 
        
        self.auto_fdi_checkbox = QCheckBox("Auto FDI")
        self.auto_fdi_checkbox.blockSignals(True)
        self.auto_fdi_checkbox.setChecked(bool(self.auto_fdi_enabled))
        self.auto_fdi_checkbox.blockSignals(False)
        self.auto_fdi_checkbox.stateChanged.connect(lambda _: self.toggle_auto_fdi())
        # row_grid.addWidget(self.auto_fdi_checkbox) # REMOVED for New Philosophy

        self.lock_layout_checkbox = QCheckBox("Κλείδωμα Γραμμών")
        self.lock_layout_checkbox.blockSignals(True)
        self.lock_layout_checkbox.setChecked(bool(self.layout_locked))
        self.lock_layout_checkbox.blockSignals(False)
        self.lock_layout_checkbox.stateChanged.connect(lambda _: self.toggle_layout_lock())
        # row_grid.addWidget(self.lock_layout_checkbox) # REMOVED for New Philosophy




        tab_comm, row_comm, row_comm_inner = _make_tab("comm")
        self.export_session_btn = QPushButton("Εξαγωγή Συνεδρίας")
        self.export_session_btn.clicked.connect(self.export_session_report)
        row_comm.addWidget(self.export_session_btn)
        self.clear_comm_btn = QPushButton("Καθαρισμός")
        self.clear_comm_btn.clicked.connect(self._clear_comm)
        row_comm.addWidget(self.clear_comm_btn)
        self.ui_preset_panorama_btn = QPushButton("Πανόραμα")
        self.ui_preset_panorama_btn.setToolTip("Μεγάλη Πανοραμική")
        self.ui_preset_panorama_btn.clicked.connect(lambda: self._set_right_preset("panorama"))
        row_comm.addWidget(self.ui_preset_panorama_btn)
        self.ui_preset_chat_btn = QPushButton("Συνομιλία")
        self.ui_preset_chat_btn.setToolTip("Μεγάλο Chat")
        self.ui_preset_chat_btn.clicked.connect(lambda: self._set_right_preset("chat"))
        row_comm.addWidget(self.ui_preset_chat_btn)
        self.ui_preset_balance_btn = QPushButton("Ισορροπία")
        self.ui_preset_balance_btn.setToolTip("Ισορροπία 50/50")
        self.ui_preset_balance_btn.clicked.connect(lambda: self._set_right_preset("balance"))
        row_comm.addWidget(self.ui_preset_balance_btn)
        self.comm_chat_toggle = QCheckBox("Συνομιλία")
        self.comm_chat_toggle.blockSignals(True)
        self.comm_chat_toggle.setChecked(bool(getattr(self, "comm_chat_visible", False)))
        self.comm_chat_toggle.blockSignals(False)
        self.comm_chat_toggle.toggled.connect(self._toggle_comm_chat_visible)
        row_comm.addWidget(self.comm_chat_toggle)

        tab_ai, row_ai, row_ai_inner = _make_tab("ai")
        self.yolov8_seg_button = QPushButton("YOLOv8 Seg")
        self.yolov8_seg_button.clicked.connect(self.run_yolov8_segmentation)
        self.yolov8_seg_button.clicked.connect(lambda: self._record_macro_step("yolo"))
        row_ai.addWidget(self.yolov8_seg_button)

        self.auto_train_every_save_checkbox = QCheckBox("Auto-train κάθε αποθήκευση")
        self.auto_train_every_save_checkbox.setToolTip("Ξεκινά εκπαίδευση μετά από κάθε αποθήκευση/διόρθωση ανάλυσης")
        self.auto_train_every_save_checkbox.blockSignals(True)
        self.auto_train_every_save_checkbox.setChecked(bool(getattr(self, "auto_train_every_save", True)))
        self.auto_train_every_save_checkbox.blockSignals(False)
        self.auto_train_every_save_checkbox.stateChanged.connect(lambda *_: self.toggle_auto_train_every_save())
        row_ai.addWidget(self.auto_train_every_save_checkbox)

        self.auto_pipeline_checkbox = QCheckBox("Auto-ροή")
        self.auto_pipeline_checkbox.setToolTip("Αυτόματη ροή: ανάλυση→διόρθωση→αποθήκευση→sync→εκπαίδευση")
        self.auto_pipeline_checkbox.blockSignals(True)
        self.auto_pipeline_checkbox.setChecked(bool(getattr(self, "auto_pipeline_enabled", True)))
        self.auto_pipeline_checkbox.blockSignals(False)
        self.auto_pipeline_checkbox.stateChanged.connect(lambda *_: self.toggle_auto_pipeline_enabled())
        row_ai.addWidget(self.auto_pipeline_checkbox)

        self.auto_analyze_on_open_checkbox = QCheckBox("Auto-ανάλυση")
        self.auto_analyze_on_open_checkbox.setToolTip("Ξεκινά ανάλυση αυτόματα όταν ανοίγει/εισάγεται νέα εικόνα")
        self.auto_analyze_on_open_checkbox.blockSignals(True)
        self.auto_analyze_on_open_checkbox.setChecked(bool(getattr(self, "auto_analyze_on_open", True)))
        self.auto_analyze_on_open_checkbox.blockSignals(False)
        self.auto_analyze_on_open_checkbox.stateChanged.connect(lambda *_: self.toggle_auto_analyze_on_open())
        row_ai.addWidget(self.auto_analyze_on_open_checkbox)

        self.auto_sync_multiclass_checkbox = QCheckBox("Auto-sync")
        self.auto_sync_multiclass_checkbox.setToolTip("Συγχρονίζει αυτόματα τις διορθώσεις στο dataset (multi-class)")
        self.auto_sync_multiclass_checkbox.blockSignals(True)
        self.auto_sync_multiclass_checkbox.setChecked(bool(getattr(self, "auto_sync_multiclass_on_save", True)))
        self.auto_sync_multiclass_checkbox.blockSignals(False)
        self.auto_sync_multiclass_checkbox.stateChanged.connect(lambda *_: self.toggle_auto_sync_multiclass_on_save())
        row_ai.addWidget(self.auto_sync_multiclass_checkbox)

        self.auto_detect_retrain_checkbox = QCheckBox("Auto-retrain detect")
        self.auto_detect_retrain_checkbox.setToolTip("Ξεκινά αυτόματο retrain του multi-class μοντέλου (με throttling)")
        self.auto_detect_retrain_checkbox.blockSignals(True)
        self.auto_detect_retrain_checkbox.setChecked(bool(getattr(self, "auto_detect_retrain_enabled", True)))
        self.auto_detect_retrain_checkbox.blockSignals(False)
        self.auto_detect_retrain_checkbox.stateChanged.connect(lambda *_: self.toggle_auto_detect_retrain_enabled())
        row_ai.addWidget(self.auto_detect_retrain_checkbox)

        self.auto_toothcls_train_checkbox = QCheckBox("Auto-train toothcls")
        self.auto_toothcls_train_checkbox.setToolTip("Ξεκινά αυτόματο training του ToothCls (με throttling)")
        self.auto_toothcls_train_checkbox.blockSignals(True)
        self.auto_toothcls_train_checkbox.setChecked(bool(getattr(self, "auto_toothcls_train_enabled", True)))
        self.auto_toothcls_train_checkbox.blockSignals(False)
        self.auto_toothcls_train_checkbox.stateChanged.connect(lambda *_: self.toggle_auto_toothcls_train_enabled())
        row_ai.addWidget(self.auto_toothcls_train_checkbox)

        self.comm_ai_save_btn = QPushButton("Αποθήκευση AI")
        self.comm_ai_save_btn.clicked.connect(self._save_ai_prefs_from_ui)
        row_ai.addWidget(self.comm_ai_save_btn)
        self.comm_ai_prompt_btn = QPushButton("Prompt")
        self.comm_ai_prompt_btn.clicked.connect(self._edit_ai_prompt)
        row_ai.addWidget(self.comm_ai_prompt_btn)
        self.comm_ai_memory_btn = QPushButton("Μνήμη")
        self.comm_ai_memory_btn.clicked.connect(self._edit_ai_memory)
        row_ai.addWidget(self.comm_ai_memory_btn)
        self.comm_alias_presets_btn = QPushButton("Aliases")
        self.comm_alias_presets_btn.clicked.connect(self._install_default_aliases)
        row_ai.addWidget(self.comm_alias_presets_btn)

        tab_flow = QWidget()
        flow_layout = QVBoxLayout(tab_flow)
        flow_layout.setContentsMargins(6, 6, 6, 6)
        flow_layout.setSpacing(6)

        self.pipeline_step_label = QLabel("Βήμα: —")
        flow_layout.addWidget(self.pipeline_step_label)
        self.pipeline_status_label = QLabel("Κατάσταση: —")
        flow_layout.addWidget(self.pipeline_status_label)
        self.pipeline_progress_bar = QProgressBar()
        self.pipeline_progress_bar.setRange(0, 100)
        self.pipeline_progress_bar.setValue(0)
        self.pipeline_progress_bar.setTextVisible(True)
        flow_layout.addWidget(self.pipeline_progress_bar)

        self.training_status_label = QLabel("")
        self.training_status_label.setWordWrap(True)
        try:
            self.training_status_label.setVisible(False)
        except Exception:
            pass
        flow_layout.addWidget(self.training_status_label)
        self.training_progress_bar = QProgressBar()
        self.training_progress_bar.setRange(0, 100)
        self.training_progress_bar.setValue(0)
        self.training_progress_bar.setTextVisible(True)
        try:
            self.training_progress_bar.setVisible(False)
        except Exception:
            pass
        flow_layout.addWidget(self.training_progress_bar)

        self.pipeline_hint_label = QLabel("")
        self.pipeline_hint_label.setWordWrap(True)
        flow_layout.addWidget(self.pipeline_hint_label)

        self.pipeline_table = QTableWidget(len(getattr(self, "_pipeline_steps", []) or []), 2)
        self.pipeline_table.setHorizontalHeaderLabels(["Βήμα", "Κατάσταση"])
        try:
            self.pipeline_table.verticalHeader().setVisible(False)
        except Exception:
            pass
        try:
            self.pipeline_table.horizontalHeader().setStretchLastSection(True)
        except Exception:
            pass
        try:
            self.pipeline_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
            self.pipeline_table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        except Exception:
            pass
        flow_layout.addWidget(self.pipeline_table, 1)

        flow_btns = QHBoxLayout()
        self.pipeline_next_btn = QPushButton("Επόμενο Βήμα")
        self.pipeline_next_btn.clicked.connect(self.run_pipeline_next_step)
        flow_btns.addWidget(self.pipeline_next_btn)
        self.pipeline_eval_detect_btn = QPushButton("Αξιολόγηση Detect")
        self.pipeline_eval_detect_btn.clicked.connect(self.open_detect_evaluation_dialog)
        flow_btns.addWidget(self.pipeline_eval_detect_btn)
        self.pipeline_eval_toothcls_btn = QPushButton("Αξιολόγηση ToothCls")
        self.pipeline_eval_toothcls_btn.clicked.connect(self.open_toothcls_evaluation_dialog)
        flow_btns.addWidget(self.pipeline_eval_toothcls_btn)
        flow_layout.addLayout(flow_btns)

        flow_ctrl = QHBoxLayout()
        self.pipeline_require_confirm_checkbox = QCheckBox("Checkpoint πριν Sync/Training")
        self.pipeline_require_confirm_checkbox.setToolTip("Αν είναι ενεργό, το Sync/Training ξεκινά μόνο μετά από επιβεβαίωση.")
        self.pipeline_require_confirm_checkbox.blockSignals(True)
        self.pipeline_require_confirm_checkbox.setChecked(bool(getattr(self, "auto_pipeline_require_confirm", True)))
        self.pipeline_require_confirm_checkbox.blockSignals(False)
        self.pipeline_require_confirm_checkbox.stateChanged.connect(lambda *_: self.toggle_pipeline_require_confirm())
        flow_ctrl.addWidget(self.pipeline_require_confirm_checkbox)

        self.pipeline_confirm_btn = QPushButton("Επιβεβαίωση Διόρθωσης")
        self.pipeline_confirm_btn.setToolTip("Συνεχίζει τη ροή (Sync/Training) για την τρέχουσα εικόνα.")
        self.pipeline_confirm_btn.clicked.connect(self.confirm_pipeline_review)
        flow_ctrl.addWidget(self.pipeline_confirm_btn)

        self.pipeline_changes_btn = QPushButton("Λεπτομέρειες Αλλαγών")
        self.pipeline_changes_btn.setToolTip("Εμφανίζει αναλυτικά τι άλλαξε από το baseline στην τελευταία αποθήκευση.")
        self.pipeline_changes_btn.clicked.connect(self.open_pipeline_change_details)
        flow_ctrl.addWidget(self.pipeline_changes_btn)
        flow_ctrl.addStretch(1)
        flow_layout.addLayout(flow_ctrl)
        try:
            self._pipeline_set(
                "image",
                "Αναμονή εικόνας",
                self._pipeline_hint_for_step("image"),
                progress=0,
                step_status_updates={"image": "WAIT", "dups": "WAIT", "crop": "WAIT", "calib": "WAIT", "lines": "WAIT", "grid": "WAIT", "analysis": "WAIT", "review": "WAIT", "save": "WAIT", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
            )
        except Exception:
            pass

        for r in (row_view, row_comm, row_ai):
            r.addStretch(1)
        try:
            self._auto_assign_toolbar_object_names()
        except Exception:
            pass
        try:
            self._apply_tools_location()
        except Exception:
            pass
        try:
            if isinstance(getattr(self, "_default_button_order", None), dict):
                def _capture(row_obj):
                    try:
                        ws = row_obj._current_order_widgets()
                    except Exception:
                        ws = []
                    out = []
                    for w in ws:
                        try:
                            nm = str(w.objectName() or "").strip()
                        except Exception:
                            nm = ""
                        if nm:
                            out.append(nm)
                    return out
                if "view" not in self._default_button_order:
                    self._default_button_order["view"] = _capture(row_view_inner)
                # if "grid" not in self._default_button_order:
                #    self._default_button_order["grid"] = _capture(row_grid_inner) # REMOVED
                # if "tools" not in self._default_button_order:
                #    self._default_button_order["tools"] = _capture(row_tools_inner) # REMOVED
                if "comm" not in self._default_button_order:
                    self._default_button_order["comm"] = _capture(row_comm_inner)
                if "ai" not in self._default_button_order:
                    self._default_button_order["ai"] = _capture(row_ai_inner)
        except Exception:
            pass
        try:
            row_view_inner.apply_saved_order((getattr(self, "_button_order_prefs", None) or {}).get("view", []))
        except Exception:
            pass
        # try:
        #    row_grid_inner.apply_saved_order((getattr(self, "_button_order_prefs", None) or {}).get("grid", []))
        # except Exception:
        #    pass
        try:
            row_tools_inner.apply_saved_order((getattr(self, "_button_order_prefs", None) or {}).get("tools", []))
        except Exception:
            pass
        try:
            row_comm_inner.apply_saved_order((getattr(self, "_button_order_prefs", None) or {}).get("comm", []))
        except Exception:
            pass
        try:
            row_ai_inner.apply_saved_order((getattr(self, "_button_order_prefs", None) or {}).get("ai", []))
        except Exception:
            pass

        tools_container.addTab(tab_view, "Βασικά")
        # tools_container.addTab(tab_grid, "Πλέγμα") # REMOVED for New Philosophy
        # tools_container.addTab(tab_tools, "Εργαλεία") # REMOVED: Now in primary_tools_layout
        tools_container.addTab(tab_comm, "Συνομιλία")
        tools_container.addTab(tab_flow, "Ροή")
        tools_container.addTab(tab_ai, "AI")
        self._apply_tools_location()

        sliders_outer = getattr(tab_view, "_outer_layout", None)
        if sliders_outer is not None:
            sliders_sc = QScrollArea()
            sliders_sc.setWidgetResizable(True)
            sliders_sc.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
            sliders_sc.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            try:
                sliders_sc.setFrameShape(QFrame.Shape.NoFrame)
            except Exception:
                pass

            sliders_inner = QWidget()
            sliders_layout = QHBoxLayout(sliders_inner)
            sliders_layout.setContentsMargins(0, 0, 0, 0)
            sliders_layout.setSpacing(10)

            sliders_layout.addWidget(QLabel("Φωτισμός"))
            self.brightness_slider = QSlider(Qt.Orientation.Horizontal)
            self.brightness_slider.setRange(-100, 100)
            self.brightness_slider.setValue(0)
            try:
                self.brightness_slider.setMinimumWidth(220)
            except Exception:
                pass
            self.brightness_slider.valueChanged.connect(self.update_image_display)
            try:
                self.brightness_slider.valueChanged.connect(self._on_ai_slider_changed)
            except Exception:
                pass
            try:
                self.brightness_slider.sliderReleased.connect(lambda: self._record_macro_step(f"/set brightness {int(self.brightness_slider.value())}"))
            except Exception:
                pass
            try:
                self.brightness_slider.sliderReleased.connect(lambda: self._announce_action_done(f"Φωτισμός: {int(self.brightness_slider.value())}"))
            except Exception:
                pass
            sliders_layout.addWidget(self.brightness_slider)

            sliders_layout.addWidget(QLabel("Αντίθεση"))
            self.contrast_slider = QSlider(Qt.Orientation.Horizontal)
            self.contrast_slider.setRange(0, 200)
            self.contrast_slider.setValue(100)
            try:
                self.contrast_slider.setMinimumWidth(220)
            except Exception:
                pass
            self.contrast_slider.valueChanged.connect(self.update_image_display)
            try:
                self.contrast_slider.valueChanged.connect(self._on_ai_slider_changed)
            except Exception:
                pass
            try:
                self.contrast_slider.sliderReleased.connect(lambda: self._record_macro_step(f"/set contrast {int(self.contrast_slider.value())}"))
            except Exception:
                pass
            try:
                self.contrast_slider.sliderReleased.connect(lambda: self._announce_action_done(f"Αντίθεση: {int(self.contrast_slider.value())}"))
            except Exception:
                pass
            sliders_layout.addWidget(self.contrast_slider)
            sliders_layout.addStretch(1)

            sliders_sc.setWidget(sliders_inner)
            try:
                sliders_sc.setFixedHeight(44)
            except Exception:
                pass
            sliders_outer.addWidget(sliders_sc)

        # --- NEW: ANATOMICAL LINES CONTROL (MIDLINE & SPEE) ---
        line_ctrl_layout = QHBoxLayout()
        line_ctrl_layout.setContentsMargins(5, 5, 5, 5)
        
        self.toggle_midline_btn = QPushButton("Μέση Γραμμή")
        self.toggle_midline_btn.setCheckable(True)
        self.toggle_midline_btn.setToolTip("Εμφάνιση/Απόκρυψη Κάθετης Μέσης Γραμμής")
        self.toggle_midline_btn.clicked.connect(self.toggle_midline_visibility)
        line_ctrl_layout.addWidget(self.toggle_midline_btn)
        
        # toggle_spee_btn removed

        
        if sliders_outer:
            sliders_outer.insertLayout(1, line_ctrl_layout)
        
        # --- Communication Panel (Text / Voice) ---
        comm_actions = QHBoxLayout()
        self.layout_save_label = QLabel("")
        self.layout_save_label.setStyleSheet("color:#9aa0a6;font-size:10px;")
        comm_actions.addWidget(self.layout_save_label, 1)
        comm_actions_widget = QWidget()
        comm_actions_widget.setLayout(comm_actions)
        self.right_bottom_header_layout.addWidget(comm_actions_widget)

        self.comm_chat_tabs = QTabWidget()
        self.comm_chat_display = QTextEdit()
        self.comm_chat_display.setReadOnly(True)
        try:
            self.comm_chat_display.setMinimumHeight(90)
        except Exception:
            pass
        self.voice_chat_display = self.comm_chat_display
        self.comm_chat_tabs.addTab(self.comm_chat_display, "Chat")
        self.comm_chat_tabs.setVisible(bool(self.comm_chat_toggle.isChecked()))
        self.right_bottom_layout.addWidget(self.comm_chat_tabs)

        self.ai_live_row = QHBoxLayout()
        self.ai_live_label = QLabel("")
        self.ai_live_stop_btn = QPushButton("Διακοπή")
        self.ai_live_stop_btn.clicked.connect(self._stop_ai_stream)
        self.ai_live_row.addWidget(self.ai_live_label, 1)
        self.ai_live_row.addWidget(self.ai_live_stop_btn)
        self.ai_live_widget = QWidget()
        self.ai_live_widget.setLayout(self.ai_live_row)
        self.ai_live_widget.setVisible(False)
        self.right_bottom_footer_layout.addWidget(self.ai_live_widget)

        self.ai_pending_row = QHBoxLayout()
        self.ai_pending_label = QLabel("")
        self.ai_pending_run_btn = QPushButton("Εκτέλεση")
        self.ai_pending_cancel_btn = QPushButton("Άκυρο")
        self.ai_pending_run_btn.clicked.connect(self._run_pending_ai_command)
        self.ai_pending_cancel_btn.clicked.connect(self._cancel_pending_ai_command)
        self.ai_pending_row.addWidget(self.ai_pending_label, 1)
        self.ai_pending_row.addWidget(self.ai_pending_run_btn)
        self.ai_pending_row.addWidget(self.ai_pending_cancel_btn)
        self.ai_pending_widget = QWidget()
        self.ai_pending_widget.setLayout(self.ai_pending_row)
        self.ai_pending_widget.setVisible(False)
        self.right_bottom_footer_layout.addWidget(self.ai_pending_widget)

        self.learn_pending_row = QHBoxLayout()
        self.learn_pending_label = QLabel("")
        self.learn_pending_yes_btn = QPushButton("Θυμήσου")
        self.learn_pending_no_btn = QPushButton("Όχι")
        self.learn_pending_yes_btn.clicked.connect(self._accept_learn_alias)
        self.learn_pending_no_btn.clicked.connect(self._reject_learn_alias)
        self.learn_pending_row.addWidget(self.learn_pending_label, 1)
        self.learn_pending_row.addWidget(self.learn_pending_yes_btn)
        self.learn_pending_row.addWidget(self.learn_pending_no_btn)
        self.learn_pending_widget = QWidget()
        self.learn_pending_widget.setLayout(self.learn_pending_row)
        self.learn_pending_widget.setVisible(False)
        self.right_bottom_footer_layout.addWidget(self.learn_pending_widget)

        self.comm_tabs = QTabWidget()

        text_tab = QWidget()
        text_layout = QVBoxLayout(text_tab)
        self.comm_help_btn = QPushButton("Βοήθεια")
        self.comm_help_btn.clicked.connect(lambda: self._handle_text_command("/help"))
        self.comm_template_combo = QComboBox()
        self.comm_template_combo.setMinimumWidth(160)
        self.comm_template_run_btn = QPushButton("Εκτέλεση")
        self.comm_template_run_btn.clicked.connect(self._run_selected_template)
        self.comm_template_save_btn = QPushButton("Αποθήκευση Πρότυπου")
        self.comm_template_save_btn.clicked.connect(self._save_current_as_template)
        # AI controls
        self.comm_ai_toggle = QCheckBox("AI mode")
        self.comm_ai_toggle.setChecked(bool(self.comm_ai_enabled))
        self.comm_ai_toggle.stateChanged.connect(lambda _: self._toggle_ai_mode())
        self.comm_ai_backend_combo = QComboBox()
        self.comm_ai_backend_combo.setMinimumWidth(110)
        self.comm_ai_backend_combo.addItem("Υβριδικό", "hybrid")
        self.comm_ai_backend_combo.addItem("Τοπικό", "local")
        self.comm_ai_backend_combo.addItem("Cloud", "cloud")
        try:
            current = str(getattr(self, "comm_ai_backend_mode", "hybrid") or "hybrid")
            idx = self.comm_ai_backend_combo.findData(current)
            if idx >= 0:
                self.comm_ai_backend_combo.setCurrentIndex(idx)
        except Exception:
            pass
        self.comm_ai_backend_combo.currentIndexChanged.connect(lambda _: self._on_ai_backend_changed())
        self.comm_ai_auto_exec_toggle = QCheckBox("Auto-εκτέλεση")
        self.comm_ai_auto_exec_toggle.setChecked(bool(self.comm_ai_auto_execute))
        self.comm_ai_auto_exec_toggle.stateChanged.connect(lambda _: self._toggle_ai_auto_execute())
        self.comm_learning_toggle = QCheckBox("Μάθηση")
        self.comm_learning_toggle.setChecked(bool(self.comm_learning_enabled))
        self.comm_learning_toggle.stateChanged.connect(lambda _: self._toggle_learning_mode())
        self.comm_chatty_toggle = QCheckBox("Διάλογος")
        self.comm_chatty_toggle.setChecked(bool(self.comm_conversation_enabled))
        self.comm_chatty_toggle.stateChanged.connect(lambda _: self._toggle_chatty_mode())
        self.comm_live_toggle = QCheckBox("Ζωντανά")
        self.comm_live_toggle.setChecked(bool(self.comm_ai_stream_enabled))
        self.comm_live_toggle.stateChanged.connect(lambda _: self._toggle_live_mode())
        try:
            text_layout.setContentsMargins(0, 0, 0, 0)
        except Exception:
            pass
        try:
            text_layout.setSpacing(6)
        except Exception:
            pass

        text_top_widget = QWidget()
        text_top_grid = QGridLayout(text_top_widget)
        text_top_grid.setContentsMargins(0, 0, 0, 0)
        try:
            text_top_grid.setHorizontalSpacing(8)
            text_top_grid.setVerticalSpacing(6)
        except Exception:
            pass

        text_top_grid.addWidget(self.comm_help_btn, 0, 0)
        text_top_grid.addWidget(self.comm_template_combo, 0, 1, 1, 2)
        text_top_grid.addWidget(self.comm_template_run_btn, 0, 3)
        text_top_grid.addWidget(self.comm_template_save_btn, 0, 4)

        text_top_grid.addWidget(self.comm_ai_toggle, 1, 0)
        text_top_grid.addWidget(self.comm_ai_backend_combo, 1, 1)
        text_top_grid.addWidget(self.comm_ai_auto_exec_toggle, 1, 2)
        text_top_grid.addWidget(self.comm_learning_toggle, 2, 0)
        text_top_grid.addWidget(self.comm_chatty_toggle, 2, 1)
        text_top_grid.addWidget(self.comm_live_toggle, 2, 2)
        try:
            text_top_grid.setColumnStretch(2, 1)
        except Exception:
            pass

        text_layout.addWidget(text_top_widget)

        adv_row_w = QWidget()
        adv_row = QHBoxLayout(adv_row_w)
        adv_row.setContentsMargins(0, 0, 0, 0)
        adv_row.setSpacing(6)
        self.comm_advanced_btn = QPushButton("Προχωρημένα ▾")
        self.comm_advanced_btn.setCheckable(True)
        try:
            self.comm_advanced_btn.setChecked(bool(getattr(self, "_comm_advanced_expanded_pref", False)))
        except Exception:
            self.comm_advanced_btn.setChecked(False)
        self.comm_advanced_btn.clicked.connect(lambda *_: self._on_comm_advanced_toggled())
        adv_row.addWidget(self.comm_advanced_btn, 0)
        adv_row.addStretch(1)
        try:
            self.comm_advanced_row = adv_row_w
        except Exception:
            pass
        text_layout.addWidget(adv_row_w)

        ai_cfg_grid = QGridLayout()
        ai_cfg_grid.setContentsMargins(0, 0, 0, 0)
        ai_cfg_grid.addWidget(QLabel("AI URL:"), 0, 0)
        self.comm_llm_url_edit = QLineEdit()
        self.comm_llm_url_edit.setMinimumWidth(180)
        self.comm_llm_url_edit.setPlaceholderText("http://localhost:11434/api/chat")
        self.comm_llm_url_edit.setText(str(self.comm_llm_url or ""))
        ai_cfg_grid.addWidget(self.comm_llm_url_edit, 0, 1, 1, 7)
        ai_cfg_grid.addWidget(QLabel("Model:"), 1, 0)
        self.comm_llm_model_edit = QLineEdit()
        self.comm_llm_model_edit.setMinimumWidth(120)
        self.comm_llm_model_edit.setPlaceholderText("llama3.1:8b-instruct")
        self.comm_llm_model_edit.setText(str(self.comm_llm_model or ""))
        ai_cfg_grid.addWidget(self.comm_llm_model_edit, 1, 1, 1, 3)
        self.comm_ai_ollama_btn = QPushButton("Ollama")
        self.comm_ai_ollama_btn.clicked.connect(self._set_ollama_defaults)
        ai_cfg_grid.addWidget(self.comm_ai_ollama_btn, 1, 4)
        self.comm_ai_start_btn = QPushButton("Εκκίνηση")
        self.comm_ai_start_btn.clicked.connect(self._start_ollama_and_check)
        ai_cfg_grid.addWidget(self.comm_ai_start_btn, 1, 5)
        self.comm_ai_check_btn = QPushButton("Έλεγχος")
        self.comm_ai_check_btn.clicked.connect(self._check_ollama_connection)
        ai_cfg_grid.addWidget(self.comm_ai_check_btn, 1, 6)
        self.comm_ai_pull_btn = QPushButton("Pull")
        self.comm_ai_pull_btn.clicked.connect(self._start_ollama_pull)
        ai_cfg_grid.addWidget(self.comm_ai_pull_btn, 1, 7)
        self.comm_ai_help_btn = QPushButton("Οδηγίες")
        self.comm_ai_help_btn.clicked.connect(self._show_ollama_help)
        ai_cfg_grid.addWidget(self.comm_ai_help_btn, 1, 8)
        ai_cfg_grid.addWidget(QLabel("Status:"), 2, 0)
        self.ollama_status_label = QLabel("—")
        self.ollama_status_label.setMinimumWidth(260)
        ai_cfg_grid.addWidget(self.ollama_status_label, 2, 1, 1, 8)
        ai_cfg_widget = QWidget()
        ai_cfg_widget.setLayout(ai_cfg_grid)
        self.ai_cfg_scroll = QScrollArea()
        self.ai_cfg_scroll.setWidgetResizable(True)
        self.ai_cfg_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.ai_cfg_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.ai_cfg_scroll.setWidget(ai_cfg_widget)
        self.ai_cfg_scroll.setMaximumHeight(82)
        self.ai_cfg_scroll.setStyleSheet("QScrollArea{border:0;} QScrollBar:horizontal{height:10px;}")
        try:
            self.ai_cfg_scroll.setVisible(False)
        except Exception:
            pass
        text_layout.addWidget(self.ai_cfg_scroll)
        try:
            self._set_ollama_status("unknown", "")
        except Exception:
            pass
        try:
            self._start_ollama_status_timer()
        except Exception:
            pass

        cloud_cfg_grid = QGridLayout()
        cloud_cfg_grid.setContentsMargins(0, 0, 0, 0)
        cloud_cfg_grid.addWidget(QLabel("Cloud Base:"), 0, 0)
        self.comm_cloud_base_edit = QLineEdit()
        self.comm_cloud_base_edit.setMinimumWidth(180)
        self.comm_cloud_base_edit.setPlaceholderText("https://api.openai.com/v1")
        self.comm_cloud_base_edit.setText(str(getattr(self, "comm_cloud_api_base", "") or ""))
        cloud_cfg_grid.addWidget(self.comm_cloud_base_edit, 0, 1, 1, 7)
        cloud_cfg_grid.addWidget(QLabel("Cloud Model:"), 1, 0)
        self.comm_cloud_model_edit = QLineEdit()
        self.comm_cloud_model_edit.setMinimumWidth(120)
        self.comm_cloud_model_edit.setPlaceholderText("gpt-4o-mini")
        self.comm_cloud_model_edit.setText(str(getattr(self, "comm_cloud_model", "") or ""))
        cloud_cfg_grid.addWidget(self.comm_cloud_model_edit, 1, 1, 1, 3)
        self.comm_cloud_preset_btn = QPushButton("Cloud preset")
        self.comm_cloud_preset_btn.clicked.connect(self._set_cloud_defaults)
        cloud_cfg_grid.addWidget(self.comm_cloud_preset_btn, 1, 4)
        cloud_cfg_widget = QWidget()
        cloud_cfg_widget.setLayout(cloud_cfg_grid)
        self.cloud_cfg_scroll = QScrollArea()
        self.cloud_cfg_scroll.setWidgetResizable(True)
        self.cloud_cfg_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.cloud_cfg_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.cloud_cfg_scroll.setWidget(cloud_cfg_widget)
        self.cloud_cfg_scroll.setMaximumHeight(78)
        self.cloud_cfg_scroll.setStyleSheet("QScrollArea{border:0;} QScrollBar:horizontal{height:10px;}")
        try:
            self.cloud_cfg_scroll.setVisible(False)
        except Exception:
            pass
        text_layout.addWidget(self.cloud_cfg_scroll)
        try:
            self._update_comm_advanced_visibility()
        except Exception:
            pass

        text_input_row = QHBoxLayout()
        self.text_input = QLineEdit()
        self.text_input.setPlaceholderText("Πληκτρολόγησε εντολή ή μήνυμα…")
        self.text_input.returnPressed.connect(self._send_text_message)
        self.text_send_btn = QPushButton("Αποστολή")
        self.text_send_btn.clicked.connect(self._send_text_message)
        self.teach_btn = QPushButton("Εκμάθηση")
        self.teach_btn.setToolTip("Δίδαξε μια διαδικασία (macro) με φράση")
        self.teach_btn.clicked.connect(self._on_teach_button_clicked)
        text_input_row.addWidget(self.text_input, 1)
        text_input_row.addWidget(self.text_send_btn)
        text_input_row.addWidget(self.teach_btn)
        text_layout.addLayout(text_input_row)
        try:
            self._update_teach_button_ui()
        except Exception:
            pass
        self.comm_tabs.addTab(text_tab, "Κείμενο")

        voice_tab = QWidget()
        voice_layout = QVBoxLayout(voice_tab)
        self.voice_status = QLabel("Μικρόφωνο: ανενεργό")
        voice_layout.addWidget(self.voice_status)

        voice_info_row = QHBoxLayout()
        self.voice_device_label = QLabel("")
        voice_info_row.addWidget(self.voice_device_label, 1)
        self.voice_test_btn = QPushButton("Δοκιμή Μικροφώνου")
        self.voice_test_btn.clicked.connect(self._test_microphone)
        voice_info_row.addWidget(self.voice_test_btn)
        voice_layout.addLayout(voice_info_row)

        voice_mode_row = QHBoxLayout()
        self.voice_chat_mode_toggle = QCheckBox("Φωνητικό chat")
        self.voice_chat_mode_toggle.setChecked(bool(getattr(self, "comm_voice_chat_enabled", False)))
        self.voice_chat_mode_toggle.stateChanged.connect(lambda _: self._toggle_voice_chat_mode())
        voice_mode_row.addWidget(self.voice_chat_mode_toggle)
        self.voice_handsfree_toggle = QCheckBox("Hands-free")
        self.voice_handsfree_toggle.setChecked(bool(getattr(self, "comm_voice_handsfree", True)))
        self.voice_handsfree_toggle.stateChanged.connect(lambda _: self._save_voice_mode_prefs_from_ui())
        voice_mode_row.addWidget(self.voice_handsfree_toggle)
        self.voice_ptt_toggle = QCheckBox("Πατημένο")
        self.voice_ptt_toggle.setChecked(bool(getattr(self, "comm_voice_push_to_talk", False)))
        self.voice_ptt_toggle.stateChanged.connect(lambda _: self._save_voice_mode_prefs_from_ui())
        voice_mode_row.addWidget(self.voice_ptt_toggle)
        self.voice_continuous_toggle = QCheckBox("Συνεχές")
        self.voice_continuous_toggle.setChecked(bool(getattr(self, "comm_voice_continuous", True)))
        self.voice_continuous_toggle.stateChanged.connect(lambda _: self._save_voice_mode_prefs_from_ui())
        voice_mode_row.addWidget(self.voice_continuous_toggle)
        voice_mode_row.addStretch(1)
        voice_layout.addLayout(voice_mode_row)

        voice_row = QHBoxLayout()
        self.voice_toggle_btn = QPushButton("Έναρξη Καταγραφής")
        self.voice_toggle_btn.clicked.connect(self._toggle_voice_capture)
        try:
            self.voice_toggle_btn.installEventFilter(self)
        except Exception:
            pass
        self.voice_transcribe_btn = QPushButton("Μεταγραφή")
        self.voice_transcribe_btn.clicked.connect(self._transcribe_last_voice)
        self.voice_send_btn = QPushButton("Αποστολή")
        self.voice_send_btn.clicked.connect(self._send_voice_transcript)
        voice_row.addWidget(self.voice_toggle_btn)
        voice_row.addWidget(self.voice_transcribe_btn)
        voice_row.addWidget(self.voice_send_btn)
        voice_layout.addLayout(voice_row)

        self.voice_transcript = QLineEdit()
        self.voice_transcript.setReadOnly(True)
        self.voice_transcript.setPlaceholderText("Μεταγραφή θα εμφανιστεί εδώ…")
        voice_layout.addWidget(self.voice_transcript)

        voice_opts = QHBoxLayout()
        self.voice_auto_transcribe_toggle = QCheckBox("Auto-μεταγραφή")
        self.voice_auto_transcribe_toggle.setChecked(bool(getattr(self, "comm_voice_auto_transcribe", True)))
        self.voice_auto_transcribe_toggle.stateChanged.connect(lambda _: self._save_comm_prefs_from_ui())
        voice_opts.addWidget(self.voice_auto_transcribe_toggle)
        self.voice_auto_send_toggle = QCheckBox("Auto-αποστολή")
        self.voice_auto_send_toggle.setChecked(bool(getattr(self, "comm_voice_auto_send", True)))
        self.voice_auto_send_toggle.stateChanged.connect(lambda _: self._save_comm_prefs_from_ui())
        voice_opts.addWidget(self.voice_auto_send_toggle)
        self.voice_tts_toggle = QCheckBox("Ομιλία AI")
        self.voice_tts_toggle.setChecked(bool(getattr(self, "comm_tts_enabled", False)))
        self.voice_tts_toggle.stateChanged.connect(lambda _: self._save_comm_prefs_from_ui())
        voice_opts.addWidget(self.voice_tts_toggle)
        self.voice_action_tts_toggle = QCheckBox("Εκφώνηση ενεργειών")
        self.voice_action_tts_toggle.setChecked(bool(getattr(self, "comm_action_tts_enabled", False)))
        self.voice_action_tts_toggle.stateChanged.connect(lambda _: self._save_comm_prefs_from_ui())
        voice_opts.addWidget(self.voice_action_tts_toggle)
        self.voice_scan_tts_toggle = QCheckBox("Εκφώνηση σάρωσης")
        self.voice_scan_tts_toggle.setToolTip("Εκφωνεί αριθμούς δοντιών κατά τη σάρωση AI")
        self.voice_scan_tts_toggle.setChecked(bool(getattr(self, "comm_scan_tts_enabled", False)))
        self.voice_scan_tts_toggle.stateChanged.connect(lambda _: self._save_comm_prefs_from_ui())
        voice_opts.addWidget(self.voice_scan_tts_toggle)
        voice_opts.addStretch(1)
        voice_layout.addLayout(voice_opts)

        stt_row = QHBoxLayout()
        stt_row.addWidget(QLabel("STT API URL:"))
        self.comm_stt_url_edit = QLineEdit()
        self.comm_stt_url_edit.setPlaceholderText("http://localhost:8000/transcribe")
        self.comm_stt_url_edit.setText(str(self.comm_stt_url or ""))
        stt_row.addWidget(self.comm_stt_url_edit, 1)
        self.comm_stt_save_btn = QPushButton("Αποθήκευση")
        self.comm_stt_save_btn.clicked.connect(self._save_comm_prefs_from_ui)
        stt_row.addWidget(self.comm_stt_save_btn)
        voice_layout.addLayout(stt_row)

        lang_row = QHBoxLayout()
        lang_row.addWidget(QLabel("Γλώσσα:"))
        self.comm_stt_lang_edit = QLineEdit()
        self.comm_stt_lang_edit.setText(str(self.comm_stt_lang or "el"))
        lang_row.addWidget(self.comm_stt_lang_edit)
        voice_layout.addLayout(lang_row)

        stt_backend_row = QHBoxLayout()
        stt_backend_row.addWidget(QLabel("STT:"))
        self.comm_stt_backend_combo = QComboBox()
        self.comm_stt_backend_combo.addItem("API", "api")
        self.comm_stt_backend_combo.addItem("Whisper.cpp", "whispercpp")
        try:
            cur = str(getattr(self, "comm_stt_backend", "api") or "api")
            idx = self.comm_stt_backend_combo.findData(cur)
            if idx >= 0:
                self.comm_stt_backend_combo.setCurrentIndex(idx)
        except Exception:
            pass
        self.comm_stt_backend_combo.currentIndexChanged.connect(lambda _: self._on_voice_backend_changed())
        stt_backend_row.addWidget(self.comm_stt_backend_combo)
        stt_backend_row.addStretch(1)
        voice_layout.addLayout(stt_backend_row)

        whisper_cli_row = QHBoxLayout()
        whisper_cli_row.addWidget(QLabel("Whisper exe:"))
        self.comm_whisper_cli_edit = QLineEdit()
        self.comm_whisper_cli_edit.setPlaceholderText(r"π.χ. C:\tools\whisper-cli.exe")
        self.comm_whisper_cli_edit.setText(str(getattr(self, "comm_whispercpp_cli", "") or ""))
        whisper_cli_row.addWidget(self.comm_whisper_cli_edit, 1)
        self.comm_whisper_cli_browse = QPushButton("…")
        self.comm_whisper_cli_browse.clicked.connect(lambda: self._pick_path_for_edit(self.comm_whisper_cli_edit, "Επιλογή whisper.exe", "Exe (*.exe);;Όλα (*.*)"))
        whisper_cli_row.addWidget(self.comm_whisper_cli_browse)
        self.comm_whisper_install_btn = QPushButton("Εγκατάσταση")
        self.comm_whisper_install_btn.clicked.connect(self._install_embedded_whispercpp)
        whisper_cli_row.addWidget(self.comm_whisper_install_btn)
        voice_layout.addLayout(whisper_cli_row)

        whisper_model_row = QHBoxLayout()
        whisper_model_row.addWidget(QLabel("Whisper model:"))
        self.comm_whisper_model_edit = QLineEdit()
        self.comm_whisper_model_edit.setPlaceholderText(r"π.χ. models\ggml-base.bin")
        self.comm_whisper_model_edit.setText(str(getattr(self, "comm_whispercpp_model", "") or ""))
        whisper_model_row.addWidget(self.comm_whisper_model_edit, 1)
        self.comm_whisper_model_browse = QPushButton("…")
        self.comm_whisper_model_browse.clicked.connect(lambda: self._pick_path_for_edit(self.comm_whisper_model_edit, "Επιλογή Whisper model", "Model (*.bin *.gguf *.onnx);;Όλα (*.*)"))
        whisper_model_row.addWidget(self.comm_whisper_model_browse)
        voice_layout.addLayout(whisper_model_row)

        tts_backend_row = QHBoxLayout()
        tts_backend_row.addWidget(QLabel("TTS:"))
        self.comm_tts_backend_combo = QComboBox()
        self.comm_tts_backend_combo.addItem("Qt", "qt")
        self.comm_tts_backend_combo.addItem("Google Cloud (Online)", "gtts")
        self.comm_tts_backend_combo.addItem("Piper", "piper")
        self.comm_tts_backend_combo.addItem("Edge-TTS", "edge-tts")
        try:
            cur = str(getattr(self, "comm_tts_backend", "qt") or "qt")
            idx = self.comm_tts_backend_combo.findData(cur)
            if idx >= 0:
                self.comm_tts_backend_combo.setCurrentIndex(idx)
        except Exception:
            pass
        self.comm_tts_backend_combo.currentIndexChanged.connect(lambda _: self._on_voice_backend_changed())
        tts_backend_row.addWidget(self.comm_tts_backend_combo)
        tts_backend_row.addStretch(1)
        voice_layout.addLayout(tts_backend_row)

        edge_tts_row = QHBoxLayout()
        edge_tts_row.addWidget(QLabel("Edge Voice:"))
        self.comm_edge_tts_voice_edit = QLineEdit()
        self.comm_edge_tts_voice_edit.setPlaceholderText("π.χ. el-GR-AthinaNeural")
        self.comm_edge_tts_voice_edit.setText(str(getattr(self, "comm_edge_tts_voice", "el-GR-AthinaNeural") or "el-GR-AthinaNeural"))
        edge_tts_row.addWidget(self.comm_edge_tts_voice_edit, 1)
        voice_layout.addLayout(edge_tts_row)

        piper_cli_row = QHBoxLayout()
        piper_cli_row.addWidget(QLabel("Piper exe:"))
        self.comm_piper_cli_edit = QLineEdit()
        self.comm_piper_cli_edit.setPlaceholderText(r"π.χ. C:\tools\piper.exe")
        self.comm_piper_cli_edit.setText(str(getattr(self, "comm_piper_cli", "") or ""))
        piper_cli_row.addWidget(self.comm_piper_cli_edit, 1)
        self.comm_piper_cli_browse = QPushButton("…")
        self.comm_piper_cli_browse.clicked.connect(lambda: self._pick_path_for_edit(self.comm_piper_cli_edit, "Επιλογή piper.exe", "Exe (*.exe);;Όλα (*.*)"))
        piper_cli_row.addWidget(self.comm_piper_cli_browse)
        self.comm_piper_install_btn = QPushButton("Εγκατάσταση")
        self.comm_piper_install_btn.clicked.connect(self._install_embedded_piper)
        piper_cli_row.addWidget(self.comm_piper_install_btn)
        voice_layout.addLayout(piper_cli_row)

        piper_voice_row = QHBoxLayout()
        piper_voice_row.addWidget(QLabel("Piper voice:"))
        self.comm_piper_voice_edit = QLineEdit()
        self.comm_piper_voice_edit.setPlaceholderText(r"π.χ. el_GR-voice.onnx")
        self.comm_piper_voice_edit.setText(str(getattr(self, "comm_piper_voice_model", "") or ""))
        piper_voice_row.addWidget(self.comm_piper_voice_edit, 1)
        self.comm_piper_voice_browse = QPushButton("…")
        self.comm_piper_voice_browse.clicked.connect(lambda: self._pick_path_for_edit(self.comm_piper_voice_edit, "Επιλογή Piper voice model", "ONNX (*.onnx);;Όλα (*.*)"))
        piper_voice_row.addWidget(self.comm_piper_voice_browse)
        voice_layout.addLayout(piper_voice_row)

        self.right_bottom_footer_layout.addWidget(self.comm_tabs)
        try:
            self.comm_ai_toggle.setChecked(bool(self.comm_ai_enabled))
            self.comm_ai_auto_exec_toggle.setChecked(bool(self.comm_ai_auto_execute))
            self.comm_learning_toggle.setChecked(bool(self.comm_learning_enabled))
            self.comm_chatty_toggle.setChecked(bool(self.comm_conversation_enabled))
            self.comm_live_toggle.setChecked(bool(self.comm_ai_stream_enabled))
        except Exception:
            pass
        self._update_ai_pending_ui()
        self._update_learn_pending_ui()
        self._refresh_templates_ui()
        self._update_known_commands()
        try:
            self._update_voice_backend_ui()
        except Exception:
            pass
        try:
            self._update_microphone_status()
        except Exception:
            pass
        
        try:
            self.main_splitter.addWidget(self.right_widget)
            try:
                self.main_splitter.setStretchFactor(0, 1)
                self.main_splitter.setStretchFactor(1, 3)
            except Exception:
                pass
            try:
                self._apply_main_splitter_prefs()
            except Exception:
                pass
        except Exception:
            main_layout.addWidget(self.right_widget, 3)
        try:
            self._wire_ui_action_announcements()
        except Exception:
            pass
        
        if self.radiograph_path and os.path.isdir(self.radiograph_path):
            self.load_images_from_directory()

    def _session_log(self, event_type: str, data=None):
        evt = {
            "ts": datetime.now().isoformat(timespec="milliseconds"),
            "type": str(event_type or "").strip() or "event",
            "data": data if isinstance(data, dict) else {},
        }
        try:
            self._session_events.append(evt)
        except Exception:
            pass
        try:
            with open(self._session_file_path, "a", encoding="utf-8") as f:
                f.write(json.dumps(evt, ensure_ascii=False) + "\n")
        except Exception:
            pass

    def _trace_log(self, event_type: str, data=None):
        try:
            if not bool(getattr(self, "_trace_recording_active", False)):
                return
        except Exception:
            return
        evt = {
            "ts": datetime.now().isoformat(timespec="milliseconds"),
            "type": str(event_type or "").strip() or "event",
            "data": data if isinstance(data, dict) else {},
        }
        try:
            evt["data"]["patient_id"] = str(getattr(self, "origin_patient_id", None) or "")
        except Exception:
            pass
        try:
            evt["data"]["image_path"] = str(getattr(self, "current_image_path", "") or "")
        except Exception:
            pass
        try:
            self._trace_events.append(evt)
        except Exception:
            pass
        try:
            p = getattr(self, "_trace_file_path", None)
            if p:
                with open(p, "a", encoding="utf-8") as f:
                    f.write(json.dumps(evt, ensure_ascii=False) + "\n")
        except Exception:
            pass

    def _start_trace_recording(self):
        if bool(getattr(self, "_trace_recording_active", False)):
            return
        started_at = datetime.now()
        rid = started_at.strftime("%Y%m%d_%H%M%S")
        pid = str(self.origin_patient_id) if self.origin_patient_id is not None else "general"
        rec_dir = Path("data/recordings")
        rec_dir.mkdir(parents=True, exist_ok=True)
        trace_path = rec_dir / f"record_{pid}_{rid}.jsonl"
        stdout_path = rec_dir / f"record_{pid}_{rid}.stdout.txt"
        try:
            with open(trace_path, "w", encoding="utf-8") as f:
                f.write("")
        except Exception:
            pass
        try:
            with open(stdout_path, "w", encoding="utf-8") as f:
                f.write("")
        except Exception:
            pass
        self._trace_started_at = started_at
        self._trace_file_path = trace_path
        self._trace_stdout_path = stdout_path
        self._trace_events = []
        self._trace_recording_active = True
        try:
            if getattr(self, "record_button", None) is not None:
                self.record_button.setChecked(True)
                self.record_button.setText("Stop")
        except Exception:
            pass
        self._trace_log(
            "record_started",
            {
                "session_file": str(getattr(self, "_session_file_path", "")),
                "trace_file": str(trace_path),
                "stdout_file": str(stdout_path),
                "model_path": str(getattr(self, "model_path", "") or ""),
                "toothdet_model_path": str(getattr(self, "toothdet_model_path", "") or ""),
                "toothcls_model_path": str(getattr(self, "toothcls_model_path", "") or ""),
            },
        )
        try:
            self.results_text_edit.append(f"⏺️ Record: {trace_path}")
        except Exception:
            pass

    def _stop_trace_recording(self):
        if not bool(getattr(self, "_trace_recording_active", False)):
            return
        ended_at = datetime.now()
        started_at = getattr(self, "_trace_started_at", None)
        try:
            dur_s = (ended_at - started_at).total_seconds() if started_at else None
        except Exception:
            dur_s = None
        self._trace_log("record_stopped", {"duration_s": float(dur_s) if dur_s is not None else None})
        self._trace_recording_active = False
        try:
            if getattr(self, "record_button", None) is not None:
                self.record_button.setChecked(False)
                self.record_button.setText("Record")
        except Exception:
            pass
        pid = str(self.origin_patient_id) if self.origin_patient_id is not None else "general"
        rid = started_at.strftime("%Y%m%d_%H%M%S") if started_at else datetime.now().strftime("%Y%m%d_%H%M%S")
        rec_dir = Path("data/recordings")
        report_path = rec_dir / f"record_{pid}_{rid}.report.json"
        try:
            try:
                events = list(getattr(self, "_trace_events", None) or [])
            except Exception:
                events = []
            if not events:
                try:
                    p0 = getattr(self, "_trace_file_path", None)
                    if p0:
                        with open(p0, "r", encoding="utf-8", errors="ignore") as f:
                            for ln in f.read().splitlines():
                                ln = ln.strip()
                                if not ln:
                                    continue
                                try:
                                    events.append(json.loads(ln))
                                except Exception:
                                    continue
                except Exception:
                    events = []
            expected_titles = {
                "Q1": "Q1 (Άνω Δεξιά)",
                "Q2": "Q2 (Άνω Αριστερά)",
                "Q3": "Q3 (Κάτω Αριστερά)",
                "Q4": "Q4 (Κάτω Δεξιά)",
            }
            phases_seen = set()
            bad_phase_titles = []
            upper_span = False
            lower_span = False
            try:
                for ev in events:
                    if not isinstance(ev, dict):
                        continue
                    tp = str(ev.get("type") or "")
                    data = ev.get("data") if isinstance(ev.get("data"), dict) else {}
                    if tp == "scan_phase":
                        ph = str(data.get("phase") or "").strip().upper()
                        if ph:
                            phases_seen.add(ph)
                        ttl = data.get("title")
                        if ph in expected_titles and ttl and str(ttl) != expected_titles.get(ph):
                            bad_phase_titles.append({"phase": ph, "title": str(ttl), "expected": expected_titles.get(ph)})
                    if tp == "scan_overlay_span":
                        ph = str(data.get("phase") or "").strip().upper()
                        if ph in ("Q1", "Q2"):
                            upper_span = True
                        if ph in ("Q3", "Q4"):
                            lower_span = True
            except Exception:
                pass
            all_phases_ok = phases_seen.issuperset({"Q1", "Q2", "Q3", "Q4"})
            bar_ok = bool(upper_span) and bool(lower_span)
            labels_ok = len(bad_phase_titles) == 0
            training_saved = False
            training_paths = {}
            spacing_keys = []
            try:
                if hasattr(self, "feedback_manager") and self.feedback_manager:
                    src_path = str(getattr(self, "current_image_path", "") or "").strip()
                    payload = self._collect_scene_training_payload()
                    if src_path and isinstance(payload, dict) and payload.get("boxes"):
                        try:
                            ok_json, json_out = analysis_to_training_json(src_path, payload)
                            if ok_json and json_out:
                                training_paths["radiographs_json"] = str(json_out)
                        except Exception:
                            pass
                        try:
                            ok_fb = bool(self.feedback_manager.save_feedback(src_path, payload))
                        except Exception:
                            ok_fb = False
                        training_saved = bool(ok_fb) or ("radiographs_json" in training_paths)
                        try:
                            if bool(training_saved):
                                try:
                                    self._auto_toothcls_save_count = int(getattr(self, "_auto_toothcls_save_count", 0) or 0) + 1
                                except Exception:
                                    self._auto_toothcls_save_count = 1
                                try:
                                    self._schedule_prefs_save(0)
                                except Exception:
                                    pass
                                try:
                                    self._maybe_start_toothcls_training(force=False)
                                except Exception:
                                    pass
                        except Exception:
                            pass
            except Exception:
                training_saved = False
            try:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict) and ts:
                    spacing_keys = [str(k) for k in ts.keys() if str(k).strip()]
                q1 = getattr(self, "_q1_spacing_template", None)
                if isinstance(q1, dict) and isinstance(q1.get("deltas_px"), list) and ("q1" not in spacing_keys):
                    spacing_keys.append("q1")
                spacing_keys = sorted(set(spacing_keys))
            except Exception:
                spacing_keys = []
            try:
                if bool(training_saved):
                    if training_paths:
                        self.results_text_edit.append(f"✅ Record: Καταγράφηκε δείγμα εκπαίδευσης ({', '.join(sorted(training_paths.keys()))})")
                    else:
                        self.results_text_edit.append("✅ Record: Καταγράφηκε δείγμα εκπαίδευσης")
                else:
                    self.results_text_edit.append("⚠️ Record: Δεν καταγράφηκε δείγμα εκπαίδευσης")
            except Exception:
                pass
            try:
                if spacing_keys:
                    self.results_text_edit.append(f"ℹ️ Templates θέσεων: {', '.join(spacing_keys)}")
            except Exception:
                pass
            try:
                fm = getattr(self, "feedback_manager", None)
                if fm is not None:
                    at = bool(getattr(fm, "auto_train", False))
                    thr = int(getattr(fm, "feedback_threshold", 0) or 0)
                    cnt = int(getattr(fm, "feedback_count", 0) or 0)
                    pend = bool(getattr(fm, "_train_pending", False))
                    self.results_text_edit.append(f"ℹ️ Auto-train toothdet: {'ενεργό' if at else 'ανενεργό'} (count={cnt} / thr={thr}, pending={pend})")
            except Exception:
                pass
            rep = {
                "started_at": started_at.isoformat(timespec="seconds") if started_at else None,
                "ended_at": ended_at.isoformat(timespec="seconds"),
                "duration_s": float(dur_s) if dur_s is not None else None,
                "patient_id": pid,
                "image_path": str(getattr(self, "current_image_path", "") or ""),
                "session_file": str(getattr(self, "_session_file_path", "")),
                "trace_file": str(getattr(self, "_trace_file_path", "")),
                "stdout_file": str(getattr(self, "_trace_stdout_path", "")),
                "criteria": {
                    "scan_visited_all_quadrants": bool(all_phases_ok),
                    "scan_bar_covered_upper_and_lower": bool(bar_ok),
                    "scan_phase_labels_consistent": bool(labels_ok),
                    "training_sample_saved": bool(training_saved),
                    "training_outputs": training_paths,
                    "tooth_spacing_templates": spacing_keys,
                    "phases_seen": sorted([p for p in phases_seen if p], key=lambda x: x),
                    "label_mismatches": bad_phase_titles,
                },
            }
            with open(report_path, "w", encoding="utf-8") as f:
                json.dump(rep, f, ensure_ascii=False, indent=2)
        except Exception:
            report_path = None
        try:
            if report_path:
                self.results_text_edit.append(f"✅ Record report: {report_path}")
        except Exception:
            pass

    def _toggle_trace_recording(self):
        try:
            active = bool(getattr(self, "_trace_recording_active", False))
        except Exception:
            active = False
        if active:
            self._stop_trace_recording()
        else:
            self._start_trace_recording()

    def _collect_scene_training_payload(self) -> dict:
        if not getattr(self, "scene", None):
            return {}
        out = {"boxes": [], "statuses": [], "fdi": [], "implants": [], "last_updated_by": []}
        rects_map = {}
        for item in self.scene.items():
            if isinstance(item, EditableRectItem):
                r = item.rect()
                pos = item.scenePos()
                x1 = pos.x() + r.x()
                y1 = pos.y() + r.y()
                x2 = x1 + r.width()
                y2 = y1 + r.height()
                statuses = item.data(Qt.ItemDataRole.UserRole)
                if not isinstance(statuses, list):
                    statuses = []
                last_updated_by = item.get_last_updated_by() if hasattr(item, "get_last_updated_by") else ""
                implant = item.get_implant() if hasattr(item, "get_implant") else {}
                rects_map[item] = {"rect": [float(x1), float(y1), float(x2), float(y2)], "label": "?", "statuses": statuses, "implant": implant, "last_updated_by": last_updated_by}
        for item in self.scene.items():
            if isinstance(item, EditableTextItem):
                if hasattr(item, "rect_item") and item.rect_item in rects_map:
                    rects_map[item.rect_item]["label"] = str(item.toPlainText() or "").strip() or "?"
        for v in rects_map.values():
            out["boxes"].append(v["rect"])
            out["fdi"].append(v.get("label", "?"))
            out["statuses"].append(v.get("statuses", []))
            out["implants"].append(v.get("implant", {}))
            out["last_updated_by"].append(v.get("last_updated_by", ""))
        return out

    def _get_current_user_id(self) -> str:
        try:
            u = str(getpass.getuser() or "").strip()
            if u:
                return u
        except Exception:
            pass
        try:
            u = str(os.environ.get("USERNAME") or os.environ.get("USER") or "").strip()
            if u:
                return u
        except Exception:
            pass
        return "unknown"

    def _schedule_autosave_current_analysis(self, reason: str = ""):
        try:
            if not bool(getattr(self, "auto_save_manual_edits", True)):
                return
        except Exception:
            return
        try:
            if getattr(self, "origin_patient_id", None) is None:
                return
        except Exception:
            return
        try:
            if not str(getattr(self, "current_image_path", "") or "").strip():
                return
        except Exception:
            return
        try:
            self._autosave_reason = str(reason or "").strip()
        except Exception:
            self._autosave_reason = ""
        try:
            self._autosave_timer.start(3500)
        except Exception:
            pass

    def _autosave_current_analysis(self):
        if not str(getattr(self, "current_image_path", "") or "").strip():
            return
        try:
            self._autosave_in_progress = True
            self._save_silent = True
            who = self._get_current_user_id()
            rs = str(getattr(self, "_autosave_reason", "") or "").strip()
            note = f"auto:{rs}" if rs else "auto"
            self._save_silent_notes = f"{note} | user:{who}"
        except Exception:
            try:
                self._autosave_in_progress = True
                self._save_silent = True
                self._save_silent_notes = "auto"
            except Exception:
                pass
        try:
            self.save_edited_results(checked=False)
        except Exception:
            pass
        try:
            self._autosave_in_progress = False
        except Exception:
            pass

    def closeEvent(self, event):
        try:
            try:
                from PyQt6.QtCore import QProcess
            except Exception:
                QProcess = None
            try:
                p = getattr(self, "_analysis_proc", None)
                if p is not None and QProcess is not None:
                    try:
                        self._analysis_abort_reason = "close"
                    except Exception:
                        pass
                    try:
                        p.setProperty("stoma_abort_reason", "close")
                    except Exception:
                        pass
                    try:
                        if p.state() != QProcess.ProcessState.NotRunning:
                            try:
                                p.terminate()
                            except Exception:
                                pass
                            try:
                                p.waitForFinished(1500)
                            except Exception:
                                pass
                            try:
                                if p.state() != QProcess.ProcessState.NotRunning:
                                    p.kill()
                                    p.waitForFinished(800)
                            except Exception:
                                pass
                    except Exception:
                        pass
                    try:
                        p.deleteLater()
                    except Exception:
                        pass
                self._analysis_proc = None
            except Exception:
                pass
            try:
                w = getattr(self, "_analysis_watchdog", None)
                if w is not None:
                    w.stop()
                    w.deleteLater()
                self._analysis_watchdog = None
            except Exception:
                pass
            try:
                tmr = getattr(self, "_analysis_prog_timer", None)
                if tmr is not None:
                    tmr.stop()
                    tmr.deleteLater()
                self._analysis_prog_timer = None
            except Exception:
                pass
            try:
                if bool(getattr(self, "_voice_running", False)):
                    self._stop_voice_capture()
            except Exception:
                pass
            try:
                self._stop_ai_stream()
            except Exception:
                pass
            try:
                t = getattr(self, "_ollama_status_timer", None)
                if t is not None:
                    t.stop()
                    t.deleteLater()
                self._ollama_status_timer = None
            except Exception:
                pass

            try:
                t = getattr(self, "_autosave_timer", None)
                if t is not None:
                    t.stop()
                self._autosave_timer = None
            except Exception:
                pass
            try:
                t = getattr(self, "recalc_timer", None)
                if t is not None:
                    t.stop()
                self.recalc_timer = None
            except Exception:
                pass
            try:
                t = getattr(self, "_layout_save_timer", None)
                if t is not None:
                    t.stop()
                    t.deleteLater()
                self._layout_save_timer = None
            except Exception:
                pass
            try:
                t = getattr(self, "_prefs_save_timer", None)
                if t is not None:
                    t.stop()
                    t.deleteLater()
                self._prefs_save_timer = None
            except Exception:
                pass

            try:
                t = getattr(self, "_scan_timer", None)
                if t is not None:
                    t.stop()
                    t.deleteLater()
                self._scan_timer = None
            except Exception:
                pass
            try:
                t = getattr(self, "_ai_q1_scan_timer", None)
                if t is not None:
                    t.stop()
                    t.deleteLater()
                self._ai_q1_scan_timer = None
            except Exception:
                pass
            try:
                t = getattr(self, "_speak_actions_timer", None)
                if t is not None:
                    t.stop()
                    t.deleteLater()
                self._speak_actions_timer = None
            except Exception:
                pass

            for name in (
                "_ollama_status_worker",
                "ollama_install_worker",
                "ollama_tags_worker",
                "ollama_pull_worker",
                "whisper_install_worker",
                "piper_install_worker",
                "piper_tts_worker",
                "ai_worker",
                "stt_worker",
                "worker",
                "verify_worker",
                "training_thread",
                "detect_training_thread",
                "toothcls_training_thread",
                "image_loader",
                "change_overlay_worker",
            ):
                w = getattr(self, name, None)
                if w is not None and hasattr(w, "isRunning") and w.isRunning():
                    try:
                        if hasattr(w, "request_stop"):
                            w.request_stop()
                    except Exception:
                        pass
                    try:
                        w.requestInterruption()
                    except Exception:
                        pass
                    try:
                        w.quit()
                    except Exception:
                        pass
                    try:
                        w.wait(2000)
                    except Exception:
                        pass
                    try:
                        if w.isRunning():
                            w.terminate()
                            w.wait(500)
                    except Exception:
                        pass
            try:
                fm = getattr(self, "feedback_manager", None)
                if fm is not None:
                    try:
                        t = getattr(fm, "_train_pending_timer", None)
                        if t is not None:
                            t.stop()
                            t.deleteLater()
                    except Exception:
                        pass
                    try:
                        fm.deleteLater()
                    except Exception:
                        pass
                self.feedback_manager = None
            except Exception:
                pass
        except Exception:
            pass
        super().closeEvent(event)

    def _clear_comm(self):
        try:
            try:
                self.comm_chat_display.clear()
            except Exception:
                pass
            try:
                if hasattr(self, "voice_chat_display") and self.voice_chat_display is not None:
                    self.voice_chat_display.clear()
            except Exception:
                pass
            self._announce_action_done("Καθαρίστηκε το ιστορικό επικοινωνίας")
        except Exception:
            pass

    def _toggle_comm_chat_visible(self, checked: bool):
        try:
            self.comm_chat_visible = bool(checked)
            if hasattr(self, "comm_chat_tabs") and self.comm_chat_tabs is not None:
                self.comm_chat_tabs.setVisible(bool(checked))
            self._save_viewer_prefs()
        except Exception:
            pass
        try:
            self._announce_action_done("Συνομιλία: εμφανής" if bool(getattr(self, "comm_chat_visible", False)) else "Συνομιλία: κρυφή")
        except Exception:
            pass

    def export_session_report(self):
        try:
            default_name = f"session_report_{self._session_started_at.strftime('%Y%m%d_%H%M%S')}.json"
            file_path, _ = QFileDialog.getSaveFileName(self, "Εξαγωγή Συνεδρίας", default_name, "JSON (*.json)")
            if not file_path:
                return
            events = list(self._session_events) if isinstance(getattr(self, "_session_events", None), list) else []
            counts: dict[str, int] = {}
            for e in events:
                et = str((e or {}).get("type") or "event")
                counts[et] = counts.get(et, 0) + 1
            duration_s = (datetime.now() - self._session_started_at).total_seconds() if getattr(self, "_session_started_at", None) else None
            report = {
                "started_at": self._session_started_at.isoformat(timespec="seconds") if getattr(self, "_session_started_at", None) else None,
                "duration_seconds": duration_s,
                "counts": counts,
                "events": events,
                "log_file": str(getattr(self, "_session_file_path", "")),
            }
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(report, f, ensure_ascii=False, indent=2)
            self._announce_action_done(f"Εξαγωγή συνεδρίας: {file_path}")
        except Exception as e:
            try:
                try:
                    self._announce_action_failed(f"Εξαγωγή συνεδρίας: {e}")
                except Exception:
                    pass
                QMessageBox.warning(self, "Εξαγωγή Συνεδρίας", f"Αποτυχία εξαγωγής: {e}")
            except Exception:
                pass

    def _append_comm(self, role: str, text: str, room: str | None = None):
        ts = datetime.now().strftime("%H:%M:%S")
        target = None
        if str(room or "").strip().lower() == "voice":
            try:
                if hasattr(self, "voice_chat_display") and self.voice_chat_display is not None:
                    target = self.voice_chat_display
            except Exception:
                target = None
        if target is None:
            target = self.comm_chat_display
        target.append(f"[{ts}] {role}: {text}")
        try:
            if str(room or "").strip().lower() == "voice" and hasattr(self, "comm_chat_tabs") and self.comm_chat_tabs is not None:
                self.comm_chat_tabs.setCurrentIndex(1)
        except Exception:
            pass
        try:
            sink = getattr(self, "external_chat_sink", None)
            if sink is not None and hasattr(sink, "append_message"):
                sink.append_message(role, text, room=room)
        except Exception:
            pass
        try:
            self._session_log("chat", {"role": role, "text": text})
        except Exception:
            pass
        try:
            self._maybe_speak_comm(role, text)
        except Exception:
            pass
        try:
            self._maybe_speak_action_comm(role, text)
        except Exception:
            pass

    def _announce_action_done(self, text: str, elapsed_ms: float | None = None, room: str | None = None):
        try:
            now = float(time.perf_counter())
            key = ("done", str(room or ""), str(text or "").strip())
            cache = getattr(self, "_announce_recent", None)
            if not isinstance(cache, dict):
                cache = {}
                self._announce_recent = cache
            last = cache.get(key)
            if isinstance(last, (int, float)) and (now - float(last)) < 0.7:
                return
            cache[key] = now
        except Exception:
            pass
        try:
            if bool(getattr(self, "comm_action_tts_enabled", False)):
                self._speak_actions_active = True
                if getattr(self, "_speak_actions_timer", None) is None:
                    self._speak_actions_timer = QTimer(self)
                    self._speak_actions_timer.setSingleShot(True)
                    self._speak_actions_timer.timeout.connect(self._deactivate_action_speech)
                self._speak_actions_timer.start(2500)
        except Exception:
            pass
        msg = str(text or "").strip()
        if elapsed_ms is not None:
            try:
                msg = f"{msg} ({float(elapsed_ms):.0f}ms)"
            except Exception:
                pass
        self._append_comm("Σύστημα", f"Ολοκληρώθηκε: {msg}" if msg else "Ολοκληρώθηκε.", room=room)

    def _announce_action_failed(self, text: str, room: str | None = None):
        try:
            now = float(time.perf_counter())
            key = ("fail", str(room or ""), str(text or "").strip())
            cache = getattr(self, "_announce_recent", None)
            if not isinstance(cache, dict):
                cache = {}
                self._announce_recent = cache
            last = cache.get(key)
            if isinstance(last, (int, float)) and (now - float(last)) < 0.7:
                return
            cache[key] = now
        except Exception:
            pass
        try:
            if bool(getattr(self, "comm_action_tts_enabled", False)):
                self._speak_actions_active = True
                if getattr(self, "_speak_actions_timer", None) is None:
                    self._speak_actions_timer = QTimer(self)
                    self._speak_actions_timer.setSingleShot(True)
                    self._speak_actions_timer.timeout.connect(self._deactivate_action_speech)
                self._speak_actions_timer.start(2500)
        except Exception:
            pass
        msg = str(text or "").strip()
        self._append_comm("Σύστημα", f"Αποτυχία: {msg}" if msg else "Αποτυχία.", room=room)

    def _announce_action_start(self, text: str, room: str | None = None):
        try:
            now = float(time.perf_counter())
            key = ("start", str(room or ""), str(text or "").strip())
            cache = getattr(self, "_announce_recent", None)
            if not isinstance(cache, dict):
                cache = {}
                self._announce_recent = cache
            last = cache.get(key)
            if isinstance(last, (int, float)) and (now - float(last)) < 0.7:
                return
            cache[key] = now
        except Exception:
            pass
        try:
            if bool(getattr(self, "comm_action_tts_enabled", False)):
                self._speak_actions_active = True
                if getattr(self, "_speak_actions_timer", None) is None:
                    self._speak_actions_timer = QTimer(self)
                    self._speak_actions_timer.setSingleShot(True)
                    self._speak_actions_timer.timeout.connect(self._deactivate_action_speech)
                self._speak_actions_timer.start(2500)
        except Exception:
            pass
        msg = str(text or "").strip()
        self._append_comm("Σύστημα", f"Εκκίνηση: {msg}" if msg else "Εκκίνηση.", room=room)

    def _maybe_auto_train_after_analysis(self):
        return

    def _maybe_auto_analyze_current_image(self):
        try:
            if bool(getattr(self, "_manual_scan_active", False)) or bool(getattr(self, "_manual_scan_block_ai", False)):
                return
            if not bool(getattr(self, "auto_pipeline_enabled", True)):
                return
            if not bool(getattr(self, "auto_analyze_on_open", True)):
                return
        except Exception:
            return
        img_path = str(getattr(self, "current_image_path", "") or "").strip()
        if not img_path:
            return
        try:
            base = os.path.splitext(img_path)[0]
            if os.path.exists(base + "_analysis.json"):
                return
        except Exception:
            pass
        try:
            proc = getattr(self, "_analysis_proc", None)
            if proc is not None:
                try:
                    from PyQt6.QtCore import QProcess
                    if proc.state() != QProcess.ProcessState.NotRunning:
                        return
                except Exception:
                    pass
        except Exception:
            pass
        try:
            last = str(getattr(self, "_auto_analyze_last_image", "") or "")
            if last and os.path.normpath(last) == os.path.normpath(img_path):
                return
        except Exception:
            pass
        try:
            self._auto_analyze_last_image = img_path
        except Exception:
            pass
        try:
            self.results_text_edit.append("Auto-ροή: ξεκινά αυτόματη ανάλυση…")
        except Exception:
            pass
        try:
            QTimer.singleShot(120, self.run_pipeline_next_step)
        except Exception:
            try:
                self.run_pipeline_next_step()
            except Exception:
                pass

    def _auto_pipeline_after_save(self, saved_data: dict, force: bool = False):
        try:
            if not bool(getattr(self, "auto_pipeline_enabled", True)):
                return
            if bool(getattr(self, "_autosave_in_progress", False)):
                return
        except Exception:
            return
        try:
            if (not bool(force)) and bool(getattr(self, "auto_pipeline_require_confirm", True)):
                self._pipeline_waiting_confirm = True
                self._pipeline_pending_after_save_data = saved_data if isinstance(saved_data, dict) else None
                try:
                    headline = str(getattr(self, "_pipeline_last_change_summary", "") or "").strip()
                    details = getattr(self, "_pipeline_last_change_details", None)
                    if not isinstance(details, list):
                        details = []
                    det = "\n".join([str(x) for x in details if str(x).strip()][:6]).strip()
                    if headline and det:
                        hint = headline + "\n" + det + "\n\n" + "Πάτα «Επιβεβαίωση Διόρθωσης» στη Ροή για να ξεκινήσει Sync/Training."
                    elif headline:
                        hint = headline + "\n\n" + "Πάτα «Επιβεβαίωση Διόρθωσης» στη Ροή για να ξεκινήσει Sync/Training."
                    else:
                        hint = "Πάτα «Επιβεβαίωση Διόρθωσης» στη Ροή για να ξεκινήσει Sync/Training."
                except Exception:
                    hint = "Πάτα «Επιβεβαίωση Διόρθωσης» στη Ροή για να ξεκινήσει Sync/Training."
                self._pipeline_set(
                    "review",
                    "Checkpoint: αναμονή επιβεβαίωσης",
                    hint,
                    progress=75,
                    step_status_updates={"save": "OK", "review": "TODO", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
                )
                return
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-ροή: επόμενο βήμα → sync/εκπαίδευση.")
        except Exception:
            pass
        try:
            self._pipeline_set(
                "sync",
                "Η ανάλυση αποθηκεύτηκε — sync/εκπαίδευση",
                self._pipeline_hint_for_step("sync"),
                progress=75,
                step_status_updates={"save": "OK", "sync": "RUN", "train": "WAIT", "eval": "WAIT"},
            )
        except Exception:
            pass

        pid = None
        try:
            src_path = str((saved_data or {}).get("image_path") or self.current_image_path or "")
            p = Path(src_path)
            parts = [x.lower() for x in p.parts]
            if "radiographs" in parts:
                idx = parts.index("radiographs")
                if idx + 1 < len(p.parts):
                    pid = str(p.parts[idx + 1]).strip()
        except Exception:
            pid = None
        if not pid:
            try:
                pid0 = getattr(self, "origin_patient_id", None)
                pid0 = str(pid0).strip() if pid0 is not None else ""
                if pid0 and pid0.lower() != "general":
                    pid = pid0
            except Exception:
                pass

        if bool(getattr(self, "auto_sync_multiclass_on_save", True)):
            if not pid:
                try:
                    self._pipeline_set(
                        "sync",
                        "Παράλειψη sync: άγνωστος ασθενής",
                        "Άνοιξε την πανοραμική μέσα από τον ασθενή (Patients) ή αποθήκευσέ την στο data/radiographs/<patient_id>/ για ασφαλές sync ανά ασθενή.",
                        progress=75,
                        step_status_updates={"sync": "WAIT", "train": "WAIT"},
                    )
                except Exception:
                    pass
                return
            try:
                rad_root = os.path.join(self.project_root, "data", "radiographs")
                if not os.path.isdir(rad_root):
                    self._pipeline_set(
                        "sync",
                        "Παράλειψη sync: λείπει data/radiographs",
                        "Δεν βρέθηκε ο φάκελος data/radiographs. Δημιούργησέ τον ή άνοιξε viewer από Patients για να γίνεται σωστό sync.",
                        progress=75,
                        step_status_updates={"sync": "WAIT", "train": "WAIT"},
                    )
                    return
            except Exception:
                pass
            try:
                holdout_cfg = ensure_holdout_config(self.project_root, ratio=0.15, seed=42)
                holdout_ids = holdout_cfg.get("patient_ids", []) if isinstance(holdout_cfg, dict) else []
            except Exception:
                holdout_ids = []
            try:
                try:
                    self._pipeline_set(
                        "sync",
                        "Sync dataset σε εξέλιξη",
                        self._pipeline_hint_for_step("sync"),
                        progress=80,
                        step_status_updates={"sync": "RUN"},
                    )
                except Exception:
                    pass
                sync_res = sync_annotations_to_training(
                    self.project_root,
                    overwrite_labels=True,
                    include_inverted=True,
                    patient_ids=[pid],
                    exclude_patient_ids=holdout_ids,
                    dst_split="train",
                )
                try:
                    added = int((sync_res or {}).get("added", 0) or 0)
                    updated = int((sync_res or {}).get("updated", 0) or 0)
                except Exception:
                    added = 0
                    updated = 0
                self.results_text_edit.append(f"Sync (multi-class): +{added} / ενημερώθηκαν {updated}")
                try:
                    self._pipeline_set(
                        "train",
                        "Sync ολοκληρώθηκε — αναμονή/εκκίνηση εκπαίδευσης",
                        self._pipeline_hint_for_step("train"),
                        progress=85,
                        step_status_updates={"sync": "OK", "train": "TODO"},
                    )
                except Exception:
                    pass
            except Exception as e:
                self.results_text_edit.append(f"⚠️ Sync (multi-class) απέτυχε: {e}")
                try:
                    self._pipeline_set(
                        "sync",
                        f"Σφάλμα sync: {e}",
                        "Έλεγξε τα αρχεία ανάλυσης και δοκίμασε ξανά αποθήκευση/sync.",
                        progress=75,
                        step_status_updates={"sync": "ERR"},
                    )
                except Exception:
                    pass

        try:
            self._auto_detect_save_count = int(getattr(self, "_auto_detect_save_count", 0) or 0) + 1
        except Exception:
            self._auto_detect_save_count = 1
        try:
            self._auto_toothcls_save_count = int(getattr(self, "_auto_toothcls_save_count", 0) or 0) + 1
        except Exception:
            self._auto_toothcls_save_count = 1
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass

        self._maybe_start_detect_retrain(force=bool(force))
        self._maybe_start_toothcls_training(force=bool(force))

    def _on_train_model_button_clicked(self):
        # Auto-save before training to ensure persistence
        try:
            self._save_silent = True
            self._save_silent_notes = "Auto-save before training"
            self.save_edited_results()
        except Exception as e:
            print(f"Auto-save failed: {e}")
        finally:
            try:
                self._save_silent = False
                self._save_silent_notes = ""
            except Exception:
                pass

        if not getattr(self, "current_image_path", None):
            return
        base = os.path.splitext(str(self.current_image_path))[0]
        json_path = base + "_analysis.json"
        if not os.path.exists(json_path):
            try:
                QMessageBox.information(self, "Εκπαίδευση", "Πρώτα κάνε «Αποθήκευση» (Ctrl+S) για να γραφτεί το _analysis.json.")
            except Exception:
                pass
            return
        saved_data = None
        try:
            saved_data = getattr(self, "_last_saved_analysis_data", None)
        except Exception:
            saved_data = None
        if not isinstance(saved_data, dict):
            try:
                with open(json_path, "r", encoding="utf-8") as f:
                    saved_data = json.load(f) or {}
            except Exception:
                saved_data = {}

        baseline = None
        try:
            baseline = getattr(self, "_last_ai_results_before_corrections", None)
        except Exception:
            baseline = None
        if not isinstance(baseline, dict):
            try:
                baseline = getattr(self, "_pipeline_baseline_data", None)
            except Exception:
                baseline = None
        if not isinstance(baseline, dict):
            baseline = {}

        try:
            rep = self._pipeline_build_full_change_report(baseline, saved_data)
            self._pipeline_last_change_report = rep
            try:
                self._pipeline_last_change_summary = str((rep or {}).get("summary") or "").strip()
                self._pipeline_last_change_details = [str(x) for x in ((rep or {}).get("details") or []) if str(x).strip()]
            except Exception:
                pass
        except Exception:
            pass

        try:
            self._pipeline_set(
                "sync",
                "Εκπαίδευση: ξεκινά Sync/Training από διορθώσεις",
                self._pipeline_hint_for_step("sync"),
                progress=75,
                step_status_updates={"review": "OK", "sync": "RUN", "train": "WAIT"},
            )
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Εκπαίδευση: ξεκινά sync dataset και retrain από τις χειροκίνητες διορθώσεις.")
        except Exception:
            pass
        try:
            self._auto_pipeline_after_save(saved_data, force=True)
            # Visual feedback
            self._blink_ghosts()
        except Exception as e:
            try:
                self._pipeline_set("sync", f"Σφάλμα εκκίνησης: {e}", "Δοκίμασε ξανά μετά από αποθήκευση.", progress=75, step_status_updates={"sync": "ERR"})
            except Exception:
                pass

    def _maybe_start_detect_retrain(self, force: bool = False):
        try:
            if not bool(getattr(self, "auto_detect_retrain_enabled", True)):
                return
        except Exception:
            return

        if getattr(self, "detect_training_worker", None) is not None:
            return
        if getattr(self, "training_worker", None) is not None:
            self._auto_detect_pending = True
            return
        if getattr(self, "toothcls_training_worker", None) is not None:
            self._auto_detect_pending = True
            return

        try:
            now = time.time()
        except Exception:
            now = 0.0
        try:
            thr = int(getattr(self, "auto_detect_retrain_threshold", 8) or 8)
            cnt = int(getattr(self, "_auto_detect_save_count", 0) or 0)
            min_iv = int(getattr(self, "auto_detect_min_interval_s", 0) or 0)
            last = float(getattr(self, "_auto_detect_last_train_ts", 0.0) or 0.0)
        except Exception:
            thr = 8
            cnt = 0
            min_iv = 0
            last = 0.0

        if not force:
            if cnt < max(1, thr):
                return
            if min_iv > 0 and last > 0.0 and now > 0.0 and (now - last) < float(min_iv):
                self._auto_detect_pending = True
                return

        stats = dataset_quality_check(self.project_root)
        if not (stats or {}).get("ok", False):
            try:
                self.results_text_edit.append(f"❌ Auto-retrain detect: dataset μη έτοιμο ({(stats or {}).get('reasons')})")
            except Exception:
                pass
            return

        params = choose_training_params(stats)
        run_name = "detect_autotrain_" + datetime.now().strftime("%Y%m%d_%H%M%S")
        base_model = None
        try:
            base_model = get_current_model(self.project_root, "detect")
        except Exception:
            base_model = None

        self.detect_training_thread = QThread()
        self.detect_training_worker = TrainingWorker(
            self.project_root,
            run_name=run_name,
            epochs=int(params.get("epochs", 30) or 30),
            batch_size=int(params.get("batch", 8) or 8), # Increased default batch size
            imgsz=int(params.get("imgsz", 640) or 640),
            lr0=params.get("lr0"),
            model_path=base_model,
        )
        self.detect_training_worker.moveToThread(self.detect_training_thread)

        self.detect_training_thread.started.connect(self.detect_training_worker.run)
        self.detect_training_worker.log_message.connect(self.results_text_edit.append)
        try:
            self.detect_training_worker.progress.connect(self._training_ui_set_progress)
        except Exception:
            pass
        self.detect_training_worker.results.connect(self.on_detect_training_results)
        self.detect_training_worker.finished.connect(self.detect_training_thread.quit)
        self.detect_training_worker.finished.connect(self.detect_training_worker.deleteLater)
        self.detect_training_worker.finished.connect(self.on_detect_training_finished)
        self.detect_training_thread.finished.connect(self.detect_training_thread.deleteLater)

        try:
            self.results_text_edit.append(f"Auto-retrain detect: {run_name}")
        except Exception:
            pass
        try:
            self._training_ui_show(f"Εκπαίδευση Detect: {run_name}")
        except Exception:
            pass
        try:
            self._pipeline_set(
                "train",
                "Detect retrain σε εξέλιξη",
                self._pipeline_hint_for_step("train"),
                progress=90,
                step_status_updates={"train": "RUN"},
            )
        except Exception:
            pass

        try:
            self._auto_detect_last_train_ts = float(now) if now else time.time()
            self._auto_detect_save_count = 0
            self._auto_detect_pending = False
            self._schedule_prefs_save(0)
        except Exception:
            pass

        self.detect_training_thread.start()

    def on_detect_training_results(self, res: dict):
        try:
            self._last_detect_training_res = res or {}
        except Exception:
            self._last_detect_training_res = {}

    def on_detect_training_finished(self):
        res = getattr(self, "_last_detect_training_res", None) or {}
        try:
            if res.get("success") and res.get("best_model") and os.path.exists(str(res.get("best_model"))):
                secured = None
                try:
                    secured = register_model(
                        self.project_root,
                        str(res.get("best_model")),
                        kind="detect",
                        run_name=str(res.get("run_dir") or "detect_autotrain"),
                        metrics=(res.get("holdout_eval") or {}).get("metrics") if isinstance(res.get("holdout_eval"), dict) else (res.get("metrics") or {}),
                        params={},
                        data_stats={},
                        run_dir=str(res.get("run_dir") or ""),
                    )
                except Exception:
                    secured = None
                chosen = secured if secured and os.path.exists(secured) else str(res.get("best_model"))
                try:
                    self.model_path = chosen
                    self.detect_model_path = chosen
                except Exception:
                    pass
                try:
                    prefs = AppPrefs(Path(self.project_root))
                    prefs.set("selected_detect_model_path", chosen)
                    prefs.set("selected_model_path", chosen)
                except Exception:
                    pass
                try:
                    m = (res.get("holdout_eval") or {}).get("metrics", {}) if isinstance(res.get("holdout_eval"), dict) else {}
                    if isinstance(m, dict) and m:
                        self.results_text_edit.append(
                            f"Detect retrain ολοκληρώθηκε — HOLDOUT mAP50={float(m.get('map50', 0.0)):.3f}"
                        )
                except Exception:
                    self.results_text_edit.append("Detect retrain ολοκληρώθηκε.")
        except Exception:
            pass
        try:
            self._pipeline_set(
                "eval",
                "Detect retrain ολοκληρώθηκε — έτοιμο για αξιολόγηση",
                self._pipeline_hint_for_step("eval"),
                progress=95,
                step_status_updates={"train": "OK", "eval": "TODO"},
            )
        except Exception:
            pass

        self.detect_training_worker = None
        self.detect_training_thread = None
        try:
            self._training_ui_hide_if_idle()
        except Exception:
            pass
        self._kick_auto_pipeline_queue()

    def _maybe_start_toothcls_training(self, force: bool = False):
        try:
            if not bool(getattr(self, "auto_toothcls_train_enabled", True)):
                return
            if bool(getattr(self, "_autosave_in_progress", False)):
                return
        except Exception:
            return

        if getattr(self, "toothcls_training_worker", None) is not None:
            return
        if getattr(self, "training_worker", None) is not None:
            self._auto_toothcls_pending = True
            return
        if getattr(self, "detect_training_worker", None) is not None:
            self._auto_toothcls_pending = True
            return

        try:
            now = time.time()
        except Exception:
            now = 0.0
        try:
            thr = int(getattr(self, "auto_toothcls_train_threshold", 30) or 30)
            cnt = int(getattr(self, "_auto_toothcls_save_count", 0) or 0)
            min_iv = int(getattr(self, "auto_toothcls_min_interval_s", 0) or 0)
            last = float(getattr(self, "_auto_toothcls_last_train_ts", 0.0) or 0.0)
        except Exception:
            thr = 30
            cnt = 0
            min_iv = 0
            last = 0.0

        if not force:
            if cnt < max(1, thr):
                return
            if min_iv > 0 and last > 0.0 and now > 0.0 and (now - last) < float(min_iv):
                self._auto_toothcls_pending = True
                return

        run_name = "toothcls_autotrain_" + datetime.now().strftime("%Y%m%d_%H%M%S")
        base_model = None
        try:
            base_model = get_current_model(self.project_root, "toothcls")
        except Exception:
            base_model = None

        self.toothcls_training_thread = QThread()
        self.toothcls_training_worker = ToothClsTrainingWorker(
            project_root=self.project_root,
            run_name=run_name,
            epochs=30,
            batch_size=32,
            imgsz=224,
            model_path=base_model,
        )
        self.toothcls_training_worker.moveToThread(self.toothcls_training_thread)

        self.toothcls_training_thread.started.connect(self.toothcls_training_worker.run)
        self.toothcls_training_worker.log_message.connect(self.results_text_edit.append)
        try:
            self.toothcls_training_worker.progress.connect(self._training_ui_set_progress)
        except Exception:
            pass
        self.toothcls_training_worker.results.connect(self.on_toothcls_training_results)
        self.toothcls_training_worker.finished.connect(self.toothcls_training_thread.quit)
        self.toothcls_training_worker.finished.connect(self.toothcls_training_worker.deleteLater)
        self.toothcls_training_worker.finished.connect(self.on_toothcls_training_finished)
        self.toothcls_training_thread.finished.connect(self.toothcls_training_thread.deleteLater)

        try:
            self.results_text_edit.append(f"Auto-train toothcls: {run_name}")
        except Exception:
            pass
        try:
            self._training_ui_show(f"Εκπαίδευση ToothCls: {run_name}")
        except Exception:
            pass
        try:
            self._pipeline_set(
                "train",
                "ToothCls training σε εξέλιξη",
                self._pipeline_hint_for_step("train"),
                progress=90,
                step_status_updates={"train": "RUN"},
            )
        except Exception:
            pass

        try:
            self._auto_toothcls_last_train_ts = float(now) if now else time.time()
            self._auto_toothcls_save_count = 0
            self._auto_toothcls_pending = False
            self._schedule_prefs_save(0)
        except Exception:
            pass

        self.toothcls_training_thread.start()

    def on_toothcls_training_results(self, res: dict):
        try:
            self._last_toothcls_training_res = res or {}
        except Exception:
            self._last_toothcls_training_res = {}

    def on_toothcls_training_finished(self):
        res = getattr(self, "_last_toothcls_training_res", None) or {}
        try:
            if res.get("success") and res.get("best_model") and os.path.exists(str(res.get("best_model"))):
                metrics = {}
                try:
                    he = (res or {}).get("holdout_eval") or {}
                    metrics = (he or {}).get("metrics", {}) or {}
                except Exception:
                    metrics = {}
                secured = None
                try:
                    secured = register_model(
                        self.project_root,
                        str(res.get("best_model")),
                        kind="toothcls",
                        run_name=str(res.get("run_dir") or "toothcls_autotrain"),
                        metrics=metrics,
                        params={},
                        data_stats={"dataset": res.get("dataset", {})},
                        run_dir=str(res.get("run_dir") or ""),
                    )
                except Exception:
                    secured = None
                chosen = secured if secured and os.path.exists(secured) else str(res.get("best_model"))
                try:
                    self.toothcls_model_path = chosen
                except Exception:
                    pass
                try:
                    prefs = AppPrefs(Path(self.project_root))
                    prefs.set("selected_toothcls_model_path", chosen)
                except Exception:
                    pass
                try:
                    v1 = float(metrics.get("top1", metrics.get("metrics/top1", 0.0) or 0.0))
                    self.results_text_edit.append(f"ToothCls ολοκληρώθηκε — HOLDOUT top1={v1:.3f}")
                except Exception:
                    self.results_text_edit.append("ToothCls ολοκληρώθηκε.")
        except Exception:
            pass
        try:
            self._pipeline_set(
                "eval",
                "ToothCls ολοκληρώθηκε — έτοιμο για αξιολόγηση",
                self._pipeline_hint_for_step("eval"),
                progress=95,
                step_status_updates={"train": "OK", "eval": "TODO"},
            )
        except Exception:
            pass

        self.toothcls_training_worker = None
        self.toothcls_training_thread = None
        try:
            self._training_ui_hide_if_idle()
        except Exception:
            pass
        self._kick_auto_pipeline_queue()

    def _kick_auto_pipeline_queue(self):
        if bool(getattr(self, "_auto_detect_pending", False)):
            self._auto_detect_pending = False
            try:
                self._maybe_start_detect_retrain(force=True)
            except Exception:
                pass
        if bool(getattr(self, "_auto_toothcls_pending", False)):
            self._auto_toothcls_pending = False
            try:
                self._maybe_start_toothcls_training(force=True)
            except Exception:
                pass

    def _training_ui_show(self, title: str):
        try:
            if getattr(self, "training_status_label", None) is not None:
                self.training_status_label.setText(str(title or "").strip())
                self.training_status_label.setVisible(True)
        except Exception:
            pass
        try:
            if getattr(self, "training_progress_bar", None) is not None:
                self.training_progress_bar.setValue(0)
                self.training_progress_bar.setVisible(True)
        except Exception:
            pass

    def _training_ui_set_progress(self, value: int):
        try:
            v = int(value)
        except Exception:
            v = 0
        try:
            v = max(0, min(100, v))
        except Exception:
            pass
        try:
            if getattr(self, "training_progress_bar", None) is not None:
                if not self.training_progress_bar.isVisible():
                    self.training_progress_bar.setVisible(True)
                self.training_progress_bar.setValue(int(v))
        except Exception:
            pass

    def _training_ui_hide_if_idle(self):
        busy = bool(getattr(self, "training_worker", None)) or bool(getattr(self, "detect_training_worker", None)) or bool(getattr(self, "toothcls_training_worker", None))
        if busy:
            return
        try:
            if getattr(self, "training_status_label", None) is not None:
                self.training_status_label.setVisible(False)
        except Exception:
            pass
        try:
            if getattr(self, "training_progress_bar", None) is not None:
                self.training_progress_bar.setVisible(False)
                self.training_progress_bar.setValue(0)
        except Exception:
            pass

    def _pipeline_render(self):
        tbl = getattr(self, "pipeline_table", None)
        if tbl is None:
            return
        try:
            for i, (k, title) in enumerate(getattr(self, "_pipeline_steps", []) or []):
                st = (getattr(self, "_pipeline_state", {}) or {}).get("step_status", {}).get(k, "—")
                tbl.setItem(i, 0, QTableWidgetItem(str(title)))
                tbl.setItem(i, 1, QTableWidgetItem(str(st)))
        except Exception:
            pass

    def _pipeline_set(self, current_key: str, status_line: str, hint: str = "", progress: int | None = None, step_status_updates: dict | None = None):
        try:
            ps = getattr(self, "_pipeline_state", None)
            if not isinstance(ps, dict):
                return
        except Exception:
            return
        try:
            ps["current"] = str(current_key or "idle")
        except Exception:
            pass
        try:
            if isinstance(step_status_updates, dict):
                s0 = ps.get("step_status", {})
                if not isinstance(s0, dict):
                    s0 = {}
                for k, v in step_status_updates.items():
                    s0[str(k)] = str(v)
                ps["step_status"] = s0
        except Exception:
            pass

        try:
            if hasattr(self, "pipeline_step_label") and self.pipeline_step_label is not None:
                title = None
                for k, t in (getattr(self, "_pipeline_steps", []) or []):
                    if str(k) == str(current_key):
                        title = t
                        break
                self.pipeline_step_label.setText(f"Βήμα: {title or str(current_key)}")
        except Exception:
            pass
        try:
            if hasattr(self, "pipeline_status_label") and self.pipeline_status_label is not None:
                self.pipeline_status_label.setText(f"Κατάσταση: {status_line}")
        except Exception:
            pass
        try:
            if hasattr(self, "pipeline_hint_label") and self.pipeline_hint_label is not None:
                self.pipeline_hint_label.setText(str(hint or "").strip())
        except Exception:
            pass
        try:
            if progress is not None and hasattr(self, "pipeline_progress_bar") and self.pipeline_progress_bar is not None:
                self.pipeline_progress_bar.setValue(int(max(0, min(100, int(progress)))))
        except Exception:
            pass
        try:
            if hasattr(self, "pipeline_confirm_btn") and self.pipeline_confirm_btn is not None:
                self.pipeline_confirm_btn.setEnabled(bool(getattr(self, "_pipeline_waiting_confirm", False)))
        except Exception:
            pass
        try:
            if hasattr(self, "pipeline_changes_btn") and self.pipeline_changes_btn is not None:
                rep = getattr(self, "_pipeline_last_change_report", None)
                self.pipeline_changes_btn.setEnabled(bool(isinstance(rep, dict) and isinstance(rep.get("rows"), list) and len(rep.get("rows")) > 0))
        except Exception:
            pass

        try:
            self._pipeline_render()
        except Exception:
            pass
        try:
            self._trace_log(
                "pipeline",
                {
                    "current": str(current_key or ""),
                    "status": str(status_line or ""),
                    "hint": str(hint or ""),
                    "progress": int(progress) if progress is not None else None,
                    "updates": step_status_updates if isinstance(step_status_updates, dict) else {},
                },
            )
        except Exception:
            pass

        hint0 = str(hint or "").strip()
        if hint0:
            try:
                last = str(ps.get("last_hint") or "")
            except Exception:
                last = ""
            if hint0 != last:
                try:
                    ps["last_hint"] = hint0
                except Exception:
                    pass
                try:
                    self._append_comm("AI", hint0)
                except Exception:
                    pass

    def _pipeline_hint_for_step(self, step_key: str) -> str:
        sk = str(step_key or "")
        if sk == "image":
            return "Επίλεξε/φόρτωσε πανοραμική. Αν είναι νέα, θα ξεκινήσει αυτόματη ανάλυση."
        if sk == "dups":
            return "Έλεγχος διπλοτύπων: θα επισημανθούν πιθανές ίδιες εικόνες στον ίδιο φάκελο."
        if sk == "crop":
            return "Αποκοπή (αν χρειάζεται): πάτα «Αποκοπή» και τράβηξε πλαίσιο. Θα δημιουργηθεί νέο *_crop_ αρχείο."
        if sk == "calib":
            return "Βαθμονόμηση: πάτα «Βαθμονόμηση (Χάρακας)» και όρισε mm στις γραμμές."
        if sk == "lines":
            return "Γραμμές: πάτα «Διαχωριστικές Γραμμές» για άνω/κάτω και μέση γραμμή. Ρύθμισέ τες αν χρειάζεται."
        if sk == "grid":
            return "Πλέγμα: πάτα «Πλέγμα (Πλήρες)» για αυτόματες γραμμές/κελιά και διόρθωσέ το αν χρειάζεται."
        if sk == "analysis":
            return "Η ανάλυση τρέχει. Περίμενε να ολοκληρωθεί και μετά διόρθωσε τα πλαίσια/καταστάσεις."
        if sk == "review":
            return "Διόρθωση: διπλό κλικ σε δόντι για statuses/σημειώσεις. Όταν τελειώσεις πάτα Αποθήκευση (Ctrl+S)."
        if sk == "save":
            return "Αποθήκευση: θα γραφτεί το _analysis.json και θα ενημερωθεί το training pipeline."
        if sk == "sync":
            return "Sync: μεταφορά των διορθώσεων στο dataset εκπαίδευσης (χωρίς holdout leakage)."
        if sk == "train":
            return "Εκπαίδευση: θα τρέξουν retrain jobs σε ουρά. Μπορείς να συνεχίσεις εργασία σε άλλες εικόνες."
        if sk == "eval":
            return "Αξιολόγηση: άνοιξε τα dialogs αξιολόγησης για Detect και ToothCls."
        return ""

    def _pipeline_by_fdi_from_data(self, data: dict) -> dict:
        if not isinstance(data, dict):
            return {}
        boxes = data.get("boxes", []) or []
        fdis = data.get("fdi", None)
        if not isinstance(fdis, list):
            fdis = list(data.get("labels", []) or [])
        statuses_list = data.get("statuses", None)
        if not isinstance(statuses_list, list):
            statuses_list = [[] for _ in range(len(boxes))]
        notes_list = data.get("notes", None)
        if not isinstance(notes_list, list):
            notes_list = ["" for _ in range(len(boxes))]
        scores = data.get("scores", None)
        if not isinstance(scores, list):
            scores = [None for _ in range(len(boxes))]

        out = {}
        n = max(len(boxes), len(fdis), len(statuses_list), len(notes_list))
        for i in range(n):
            fdi = fdis[i] if i < len(fdis) else None
            fdi = str(fdi or "").strip()
            if not fdi or fdi == "?":
                continue
            box = boxes[i] if i < len(boxes) else None
            st = statuses_list[i] if i < len(statuses_list) else []
            note = notes_list[i] if i < len(notes_list) else ""
            sc = scores[i] if i < len(scores) else None
            out[fdi] = {"box": box, "statuses": st, "note": str(note or ""), "score": sc}
        return out

    def _pipeline_summarize_changes(self, baseline_data: dict | None, new_data: dict | None) -> tuple[str, list[str]]:
        if not isinstance(baseline_data, dict):
            baseline_data = {}
        if not isinstance(new_data, dict):
            new_data = {}
        try:
            bmap = self._pipeline_by_fdi_from_data(baseline_data)
            pmap = self._pipeline_by_fdi_from_data(new_data)
        except Exception:
            bmap = {}
            pmap = {}
        try:
            rep = build_report(bmap, pmap, iou_threshold=0.5)
        except Exception:
            rep = {"summary": {}, "per_fdi": []}
        summ = rep.get("summary", {}) if isinstance(rep, dict) else {}
        per = rep.get("per_fdi", []) if isinstance(rep, dict) else []
        if not isinstance(per, list):
            per = []

        notes_changed = 0
        for fdi in sorted(set(bmap.keys()) | set(pmap.keys())):
            bnote = str((bmap.get(fdi) or {}).get("note") or "").strip()
            pnote = str((pmap.get(fdi) or {}).get("note") or "").strip()
            if bnote != pnote:
                notes_changed += 1

        try:
            extra = int(summ.get("extra", 0) or 0)
            missing = int(summ.get("missing", 0) or 0)
            moved = int(summ.get("moved_iou_below_threshold", 0) or 0)
            status_changed = int(summ.get("status_changed", 0) or 0)
        except Exception:
            extra = 0
            missing = 0
            moved = 0
            status_changed = 0

        headline = f"Αλλαγές: +{extra} / -{missing}, μετατοπίσεις {moved}, αλλαγές κατάστασης {status_changed}, αλλαγές σημειώσεων {notes_changed}."
        details = []
        for row in per:
            if not isinstance(row, dict):
                continue
            fdi = str(row.get("fdi") or "").strip()
            if not fdi:
                continue
            if row.get("missing"):
                details.append(f"{fdi}: αφαιρέθηκε")
                continue
            if row.get("extra"):
                details.append(f"{fdi}: προστέθηκε")
                continue
            add_st = row.get("status_added", []) if isinstance(row.get("status_added"), list) else []
            rem_st = row.get("status_removed", []) if isinstance(row.get("status_removed"), list) else []
            iou = row.get("iou")
            parts = []
            if isinstance(iou, (int, float)) and float(iou) < 0.5:
                parts.append(f"μετατόπιση IoU {float(iou):.2f}")
            if add_st:
                parts.append("+" + ", ".join([str(x) for x in add_st if str(x).strip()]))
            if rem_st:
                parts.append("-" + ", ".join([str(x) for x in rem_st if str(x).strip()]))
            bnote = str((bmap.get(fdi) or {}).get("note") or "").strip()
            pnote = str((pmap.get(fdi) or {}).get("note") or "").strip()
            if bnote != pnote:
                parts.append("σημείωση")
            if parts:
                details.append(f"{fdi}: " + " | ".join(parts))
            if len(details) >= 6:
                break

        return headline, details

    def _pipeline_build_full_change_report(self, baseline_data: dict | None, new_data: dict | None) -> dict:
        if not isinstance(baseline_data, dict):
            baseline_data = {}
        if not isinstance(new_data, dict):
            new_data = {}
        bmap = self._pipeline_by_fdi_from_data(baseline_data)
        pmap = self._pipeline_by_fdi_from_data(new_data)
        rep = build_report(bmap, pmap, iou_threshold=0.5)
        headline, _details = self._pipeline_summarize_changes(baseline_data, new_data)
        per = rep.get("per_fdi", []) if isinstance(rep, dict) else []
        if not isinstance(per, list):
            per = []

        rows = []
        for row in per:
            if not isinstance(row, dict):
                continue
            fdi = str(row.get("fdi") or "").strip()
            if not fdi:
                continue
            missing = bool(row.get("missing"))
            extra = bool(row.get("extra"))
            iou = row.get("iou")
            add_st = row.get("status_added", []) if isinstance(row.get("status_added"), list) else []
            rem_st = row.get("status_removed", []) if isinstance(row.get("status_removed"), list) else []
            bnote = str((bmap.get(fdi) or {}).get("note") or "").strip()
            pnote = str((pmap.get(fdi) or {}).get("note") or "").strip()
            note_changed = (bnote != pnote)

            changed = False
            if missing or extra:
                changed = True
            if isinstance(iou, (int, float)) and float(iou) < 0.5:
                changed = True
            if add_st or rem_st:
                changed = True
            if note_changed:
                changed = True
            if not changed:
                continue

            parts = []
            if missing:
                parts.append("αφαιρέθηκε")
            if extra:
                parts.append("προστέθηκε")
            if isinstance(iou, (int, float)) and float(iou) < 0.5:
                parts.append(f"μετατόπιση IoU {float(iou):.2f}")
            if add_st:
                parts.append("+" + ", ".join([str(x) for x in add_st if str(x).strip()]))
            if rem_st:
                parts.append("-" + ", ".join([str(x) for x in rem_st if str(x).strip()]))
            if note_changed:
                parts.append("σημείωση")

            rows.append(
                {
                    "fdi": fdi,
                    "missing": missing,
                    "extra": extra,
                    "iou": float(iou) if isinstance(iou, (int, float)) else None,
                    "status_added": [str(x) for x in add_st if str(x).strip()],
                    "status_removed": [str(x) for x in rem_st if str(x).strip()],
                    "note_before": bnote,
                    "note_after": pnote,
                    "line": f"{fdi}: " + " | ".join(parts),
                }
            )

        return {"headline": headline, "rows": rows}

    def open_pipeline_change_details(self):
        rep = getattr(self, "_pipeline_last_change_report", None)
        if not isinstance(rep, dict):
            try:
                QMessageBox.information(self, "Λεπτομέρειες Αλλαγών", "Δεν υπάρχουν διαθέσιμες αλλαγές ακόμη. Κάνε αποθήκευση πρώτα.")
            except Exception:
                pass
            return
        rows = rep.get("rows", [])
        if not isinstance(rows, list) or not rows:
            try:
                QMessageBox.information(self, "Λεπτομέρειες Αλλαγών", "Δεν βρέθηκαν αλλαγές σε σχέση με το baseline.")
            except Exception:
                pass
            return

        dlg = QDialog(self)
        dlg.setWindowTitle("Λεπτομέρειες Αλλαγών")
        dlg.resize(820, 520)
        lay = QVBoxLayout(dlg)
        lay.addWidget(QLabel(str(rep.get("headline") or "").strip()))

        controls = QHBoxLayout()
        controls.addWidget(QLabel("Φίλτρο:"))
        filter_combo = QComboBox()
        filter_combo.addItem("Όλα", "all")
        filter_combo.addItem("Προσθήκες", "added")
        filter_combo.addItem("Αφαιρέσεις", "removed")
        filter_combo.addItem("Μετατοπίσεις", "moved")
        filter_combo.addItem("Καταστάσεις", "status")
        filter_combo.addItem("Σημειώσεις", "notes")
        controls.addWidget(filter_combo)
        q = QLineEdit()
        q.setPlaceholderText("Αναζήτηση (FDI ή κείμενο)…")
        controls.addWidget(q, 1)
        lay.addLayout(controls)

        lw = QListWidget()
        all_rows = [r for r in rows if isinstance(r, dict)]

        def refresh_list():
            try:
                lw.clear()
            except Exception:
                return
            mode = None
            try:
                mode = str(filter_combo.currentData() or "all")
            except Exception:
                mode = "all"
            term = ""
            try:
                term = str(q.text() or "").strip().lower()
            except Exception:
                term = ""

            for r in all_rows:
                fdi = str(r.get("fdi") or "").strip()
                missing = bool(r.get("missing"))
                extra = bool(r.get("extra"))
                iou = r.get("iou")
                moved = bool(isinstance(iou, (int, float)) and float(iou) < 0.5)
                st_add = r.get("status_added", []) if isinstance(r.get("status_added"), list) else []
                st_rem = r.get("status_removed", []) if isinstance(r.get("status_removed"), list) else []
                status_changed = bool(st_add or st_rem)
                nb = str(r.get("note_before") or "").strip()
                na = str(r.get("note_after") or "").strip()
                notes_changed = (nb != na)

                if mode == "added" and not extra:
                    continue
                if mode == "removed" and not missing:
                    continue
                if mode == "moved" and not moved:
                    continue
                if mode == "status" and not status_changed:
                    continue
                if mode == "notes" and not notes_changed:
                    continue

                line = str(r.get("line") or "").strip()
                if not line:
                    continue
                hay = f"{fdi} {line} {nb} {na}".lower()
                if term and term not in hay:
                    continue

                badges = []
                if extra:
                    badges.append("[+]")
                if missing:
                    badges.append("[-]")
                if moved:
                    badges.append("[M]")
                if status_changed:
                    badges.append("[S]")
                if notes_changed:
                    badges.append("[N]")
                prefix = (" ".join(badges) + " ") if badges else ""
                item = QListWidgetItem(prefix + line)
                try:
                    item.setData(Qt.ItemDataRole.UserRole, {"fdi": fdi, "missing": missing, "extra": extra})
                except Exception:
                    pass
                try:
                    if missing:
                        item.setForeground(QColor("#b00020"))
                    elif extra:
                        item.setForeground(QColor("#0b6e4f"))
                    elif moved:
                        item.setForeground(QColor("#8a6d00"))
                except Exception:
                    pass
                try:
                    tip_parts = []
                    if moved and isinstance(iou, (int, float)):
                        tip_parts.append(f"IoU: {float(iou):.2f}")
                    if status_changed:
                        a0 = ", ".join([str(x) for x in st_add if str(x).strip()])
                        r0 = ", ".join([str(x) for x in st_rem if str(x).strip()])
                        if a0:
                            tip_parts.append(f"+status: {a0}")
                        if r0:
                            tip_parts.append(f"-status: {r0}")
                    if notes_changed:
                        if nb:
                            tip_parts.append(f"note πριν: {nb}")
                        if na:
                            tip_parts.append(f"note μετά: {na}")
                    if tip_parts:
                        item.setToolTip("\n".join(tip_parts))
                except Exception:
                    pass
                lw.addItem(item)

        refresh_list()
        lay.addWidget(lw, 1)
        try:
            lw.itemClicked.connect(lambda it: self._focus_change_item(it, open_details=False))
        except Exception:
            pass
        try:
            lw.itemDoubleClicked.connect(lambda it: self._focus_change_item(it, open_details=True))
        except Exception:
            pass

        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        btns.rejected.connect(dlg.reject)
        btns.accepted.connect(dlg.accept)
        lay.addWidget(btns)
        try:
            q.textChanged.connect(lambda *_: refresh_list())
        except Exception:
            pass
        try:
            filter_combo.currentIndexChanged.connect(lambda *_: refresh_list())
        except Exception:
            pass
        dlg.exec()

    def _rebuild_fdi_item_cache(self):
        sc = getattr(self, "scene", None)
        if sc is None:
            self._fdi_item_cache = {}
            self._fdi_item_cache_image_path = getattr(self, "current_image_path", None)
            return
        out = {}
        try:
            for it in sc.items():
                if not isinstance(it, EditableRectItem):
                    continue
                try:
                    lab = it.get_label_text()
                except Exception:
                    lab = None
                fdi = str(lab or "").strip()
                if not fdi or fdi == "?":
                    continue
                if fdi not in out:
                    out[fdi] = it
        except Exception:
            out = {}
        self._fdi_item_cache = out
        self._fdi_item_cache_image_path = getattr(self, "current_image_path", None)

    def _find_rect_item_by_fdi(self, fdi: str):
        fdi0 = str(fdi or "").strip()
        if not fdi0:
            return None
        try:
            if getattr(self, "_fdi_item_cache_image_path", None) != getattr(self, "current_image_path", None):
                self._rebuild_fdi_item_cache()
            cache = getattr(self, "_fdi_item_cache", None)
            if isinstance(cache, dict) and fdi0 in cache:
                it = cache.get(fdi0)
                if it is not None and getattr(it, "scene", None) and it.scene() is not None:
                    return it
        except Exception:
            pass
        try:
            self._rebuild_fdi_item_cache()
            cache = getattr(self, "_fdi_item_cache", None)
            if isinstance(cache, dict):
                return cache.get(fdi0)
        except Exception:
            pass
        return None

    def _focus_rect_item(self, rect_item, open_details: bool = False):
        if rect_item is None:
            return False
        try:
            rect_item.setSelected(True)
        except Exception:
            pass
        try:
            br = rect_item.sceneBoundingRect()
            pad = max(40.0, min(180.0, max(br.width(), br.height()) * 1.2))
            r2 = br.adjusted(-pad, -pad, pad, pad)
            self.view.fitInView(r2, Qt.AspectRatioMode.KeepAspectRatio)
        except Exception:
            try:
                self.view.centerOn(rect_item.sceneBoundingRect().center())
            except Exception:
                pass
        if open_details:
            try:
                rect_item.open_details_dialog()
            except Exception:
                pass
        return True

    def _focus_change_item(self, item: QListWidgetItem, open_details: bool = False):
        if item is None:
            return
        try:
            payload = item.data(Qt.ItemDataRole.UserRole)
        except Exception:
            payload = None
        fdi = None
        missing = False
        try:
            if isinstance(payload, dict):
                fdi = str(payload.get("fdi") or "").strip()
                missing = bool(payload.get("missing"))
        except Exception:
            fdi = None
            missing = False
        if missing:
            try:
                QMessageBox.information(self, "Πλοήγηση", "Το δόντι αφαιρέθηκε στη νέα ανάλυση· δεν υπάρχει box για εστίαση.")
            except Exception:
                pass
            return
        rect_item = self._find_rect_item_by_fdi(fdi)
        if rect_item is None:
            try:
                QMessageBox.information(self, "Πλοήγηση", f"Δεν βρέθηκε box για FDI {fdi}.")
            except Exception:
                pass
            return
        self._focus_rect_item(rect_item, open_details=open_details)

    def _pipeline_is_calibrated(self) -> bool:
        try:
            return bool(getattr(self, "pixel_to_mm_scale", None) or getattr(self, "pixel_to_mm_scale_x", None) or getattr(self, "pixel_to_mm_scale_y", None))
        except Exception:
            return False

    def _pipeline_has_lines(self) -> bool:
        try:
            jl = getattr(self, "jaw_separator_line", None)
            vl = getattr(self, "vertical_separator_line", None)
            if jl is None or vl is None:
                return False
            if getattr(jl, "scene", None) and jl.scene() is None:
                return False
            if getattr(vl, "scene", None) and vl.scene() is None:
                return False
            return True
        except Exception:
            return False

    def _pipeline_has_grid(self) -> bool:
        try:
            h = getattr(self, "grid_lines_h", None) or []
            if not isinstance(h, list) or len(h) < 2:
                return False
            vu = getattr(self, "grid_lines_v_upper", None) or []
            vl = getattr(self, "grid_lines_v_lower", None) or []
            vc = getattr(self, "grid_lines_v", None) or []
            return (isinstance(vu, list) and len(vu) > 0) or (isinstance(vl, list) and len(vl) > 0) or (isinstance(vc, list) and len(vc) > 0)
        except Exception:
            return False

    def _pipeline_check_duplicates_in_folder(self, image_path: str) -> list[str]:
        p0 = str(image_path or "").strip()
        if not p0 or (not os.path.exists(p0)):
            return []
        try:
            if os.path.isdir(p0):
                return []
        except Exception:
            pass
        try:
            if os.path.normpath(str(getattr(self, "_pipeline_dups_checked_path", "") or "")) == os.path.normpath(p0):
                cached = getattr(self, "_pipeline_dups_cached", None)
                return cached if isinstance(cached, list) else []
        except Exception:
            pass

        folder = None
        try:
            folder = os.path.dirname(p0)
        except Exception:
            folder = None
        if not folder or (not os.path.isdir(folder)):
            return []
        try:
            cur_size = os.path.getsize(p0)
        except Exception:
            cur_size = None
        if cur_size is None:
            return []

        def sha1_file(path: str) -> str | None:
            try:
                h = hashlib.sha1()
                with open(path, "rb") as f:
                    for chunk in iter(lambda: f.read(1024 * 1024), b""):
                        h.update(chunk)
                return h.hexdigest()
            except Exception:
                return None

        cur_hash = sha1_file(p0)
        if not cur_hash:
            return []

        exts = (".jpg", ".jpeg", ".png", ".bmp", ".tif", ".tiff", ".dcm")
        dups = []
        try:
            for fn in os.listdir(folder):
                fp = os.path.join(folder, fn)
                if not os.path.isfile(fp):
                    continue
                if os.path.normpath(fp) == os.path.normpath(p0):
                    continue
                if not str(fn).lower().endswith(exts):
                    continue
                try:
                    if os.path.getsize(fp) != cur_size:
                        continue
                except Exception:
                    continue
                h = sha1_file(fp)
                if h and h == cur_hash:
                    dups.append(fp)
        except Exception:
            dups = []
        try:
            self._pipeline_dups_checked_path = p0
            self._pipeline_dups_cached = list(dups)
        except Exception:
            pass
        return dups

    def run_pipeline_next_step(self):
        try:
            if not getattr(self, "current_image_path", None):
                self._pipeline_set("image", "Αναμονή εικόνας", self._pipeline_hint_for_step("image"), progress=0)
                return
        except Exception:
            return
        try:
            if bool(getattr(self, "_manual_scan_active", False)) or bool(getattr(self, "_manual_scan_block_ai", False)):
                self._pipeline_set("analysis", "Auto-ροή: παύση (χειροκίνητη σάρωση)", "Ολοκλήρωσε τη χειροκίνητη σάρωση και μετά συνέχισε την ροή.", progress=0, step_status_updates={"analysis": "WAIT"})
                return
        except Exception:
            return
        try:
            if bool(getattr(self, "_pipeline_waiting_confirm", False)) and bool(getattr(self, "auto_pipeline_require_confirm", True)):
                self._pipeline_set(
                    "review",
                    "Checkpoint: αναμονή επιβεβαίωσης",
                    "Πάτα «Επιβεβαίωση Διόρθωσης» στη Ροή για να ξεκινήσει Sync/Training.",
                    progress=75,
                )
                return
        except Exception:
            pass

        try:
            ps = getattr(self, "_pipeline_state", None) or {}
            st = ps.get("step_status", {}) if isinstance(ps, dict) else {}
            if not isinstance(st, dict):
                st = {}
        except Exception:
            st = {}

        try:
            if st.get("dups") in ("WAIT", "TODO", "RUN", "—") or (not str(st.get("dups") or "").strip()):
                self._pipeline_set("dups", "Έλεγχος διπλοτύπων", self._pipeline_hint_for_step("dups"), progress=5, step_status_updates={"image": "OK", "dups": "RUN"})
                img0 = str(getattr(self, "current_image_path", "") or "").strip()
                dups = self._pipeline_check_duplicates_in_folder(img0)
                if dups:
                    hint = "Βρέθηκαν πιθανά διπλότυπα:\n" + "\n".join([os.path.basename(p) for p in dups][:6])
                    self._pipeline_set("dups", f"Βρέθηκαν διπλότυπα ({len(dups)})", hint, progress=6, step_status_updates={"dups": "WARN", "crop": "TODO", "calib": "TODO", "lines": "TODO", "grid": "TODO", "analysis": "WAIT"})
                    return
                self._pipeline_set("dups", "Δεν βρέθηκαν διπλότυπα", "", progress=6, step_status_updates={"dups": "OK", "crop": "TODO", "calib": "TODO", "lines": "TODO", "grid": "TODO", "analysis": "WAIT"})
                QTimer.singleShot(0, self.run_pipeline_next_step)
                return
        except Exception:
            pass

        try:
            if bool(getattr(self, "crop_button", None)) and bool(getattr(self, "crop_button").isChecked()):
                self._pipeline_set("crop", "Αποκοπή σε εξέλιξη", self._pipeline_hint_for_step("crop"), progress=8, step_status_updates={"crop": "RUN"})
                return
        except Exception:
            pass
        try:
            if not bool(getattr(self, "_pipeline_prompted_crop", False)):
                self._pipeline_prompted_crop = True
                self._pipeline_set("crop", "Έλεγχος αποκοπής (αν χρειάζεται)", self._pipeline_hint_for_step("crop"), progress=8, step_status_updates={"crop": "TODO"})
                return
        except Exception:
            pass
        try:
            if st.get("crop") not in ("OK", "SKIP"):
                self._pipeline_set("crop", "Αποκοπή: ολοκληρώθηκε/παραλείφθηκε", "", progress=9, step_status_updates={"crop": "OK"})
        except Exception:
            pass

        if not self._pipeline_is_calibrated():
            try:
                if hasattr(self, "calibration_button") and self.calibration_button is not None and (not bool(self.calibration_button.isChecked())):
                    self.calibration_button.setChecked(True)
                    self.toggle_calibration_mode()
            except Exception:
                pass
            self._pipeline_set("calib", "Βαθμονόμηση απαιτείται", self._pipeline_hint_for_step("calib"), progress=12, step_status_updates={"calib": "TODO"})
            return
        else:
            try:
                if st.get("calib") != "OK":
                    self._pipeline_set("calib", "Βαθμονόμηση: OK", "", progress=13, step_status_updates={"calib": "OK"})
            except Exception:
                pass

        if not self._pipeline_has_lines():
            try:
                self.toggle_jaw_lines()
            except Exception:
                pass
            self._pipeline_set("lines", "Γραμμές: δημιουργήθηκαν", self._pipeline_hint_for_step("lines"), progress=18, step_status_updates={"lines": "OK"})
            QTimer.singleShot(0, self.run_pipeline_next_step)
            return
        else:
            try:
                if st.get("lines") != "OK":
                    self._pipeline_set("lines", "Γραμμές: OK", "", progress=18, step_status_updates={"lines": "OK"})
            except Exception:
                pass

        if not self._pipeline_has_grid():
            try:
                if hasattr(self, "grid_button") and self.grid_button is not None and (not bool(self.grid_button.isChecked())):
                    self.grid_button.setChecked(True)
                self.toggle_grid_mode()
            except Exception:
                pass
            self._pipeline_set("grid", "Πλέγμα: δημιουργήθηκε", self._pipeline_hint_for_step("grid"), progress=25, step_status_updates={"grid": "OK"})
            QTimer.singleShot(0, self.run_pipeline_next_step)
            return
        else:
            try:
                if st.get("grid") != "OK":
                    self._pipeline_set("grid", "Πλέγμα: OK", "", progress=25, step_status_updates={"grid": "OK"})
            except Exception:
                pass

        img_path = str(getattr(self, "current_image_path", "") or "").strip()
        has_saved = False
        try:
            base = os.path.splitext(img_path)[0]
            has_saved = os.path.exists(base + "_analysis.json")
        except Exception:
            has_saved = False

        if not has_saved and (getattr(self, "analysis_results", None) is None):
            try:
                if not bool(getattr(self, "_pipeline_waiting_hide_grid_before_analysis", False)):
                    self._pipeline_waiting_hide_grid_before_analysis = True
                    self._pipeline_set(
                        "analysis",
                        "Έτοιμο για ανάλυση — κλείσε το Πλέγμα",
                        "Ξετσέκαρε το Πλέγμα όταν είσαι έτοιμος/η. Μόλις το κλείσεις, θα ξεκινήσει η ανάλυση.",
                        progress=15,
                        step_status_updates={"image": "OK", "dups": st.get("dups") or "OK", "crop": "OK", "calib": "OK", "lines": "OK", "grid": "OK", "analysis": "TODO", "review": "WAIT", "save": "WAIT", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
                    )
                    return
                return
            except Exception:
                pass

        try:
            if hasattr(self, "save_analysis_button") and self.save_analysis_button is not None and bool(self.save_analysis_button.isEnabled()):
                self._pipeline_set("save", "Αποθήκευση σε εξέλιξη", self._pipeline_hint_for_step("save"), progress=70, step_status_updates={"save": "RUN"})
                self.save_edited_results()
                return
        except Exception:
            pass

        try:
            if bool(getattr(self, "_auto_detect_pending", False)) or bool(getattr(self, "_auto_toothcls_pending", False)):
                self._pipeline_set("train", "Εκκίνηση εκπαίδευσης από ουρά", self._pipeline_hint_for_step("train"), progress=85, step_status_updates={"train": "RUN"})
                self._kick_auto_pipeline_queue()
                return
        except Exception:
            pass

        self._pipeline_set("eval", "Έτοιμο για αξιολόγηση", self._pipeline_hint_for_step("eval"), progress=100, step_status_updates={"eval": "TODO"})

    def open_detect_evaluation_dialog(self):
        try:
            from app.widgets.evaluation_dialog import EvaluationDialog
            mp = getattr(self, "detect_model_path", None) or getattr(self, "model_path", None)
            dlg = EvaluationDialog(str(self.project_root), str(mp or ""), self)
            dlg.exec()
        except Exception as e:
            try:
                QMessageBox.critical(self, "Σφάλμα", str(e))
            except Exception:
                pass

    def open_toothcls_evaluation_dialog(self):
        try:
            from app.widgets.toothcls_evaluation_dialog import ToothClsEvaluationDialog
            mp = getattr(self, "toothcls_model_path", None) or get_current_model(self.project_root, "toothcls")
            if not mp:
                try:
                    prefs = AppPrefs(Path(self.project_root))
                    mp = prefs.get("selected_toothcls_model_path")
                except Exception:
                    mp = None
            dlg = ToothClsEvaluationDialog(str(self.project_root), str(mp or ""), self)
            dlg.exec()
        except Exception as e:
            try:
                QMessageBox.critical(self, "Σφάλμα", str(e))
            except Exception:
                pass

    def _apply_auto_train_policy(self):
        fm = getattr(self, "feedback_manager", None)
        if fm is None:
            return
        every = bool(getattr(self, "auto_train_every_save", False))
        try:
            fm.auto_train = bool(every)
        except Exception:
            pass
        try:
            fm.feedback_threshold = 1 if every else 3
        except Exception:
            pass
        try:
            fm.min_train_interval_s = 0 if every else 3600
        except Exception:
            pass
        try:
            if hasattr(self, "auto_train_every_save_checkbox") and self.auto_train_every_save_checkbox is not None:
                self.auto_train_every_save_checkbox.blockSignals(True)
                self.auto_train_every_save_checkbox.setChecked(bool(every))
                self.auto_train_every_save_checkbox.blockSignals(False)
        except Exception:
            pass

    def toggle_auto_train_every_save(self):
        try:
            if hasattr(self, "auto_train_every_save_checkbox") and self.auto_train_every_save_checkbox is not None:
                self.auto_train_every_save = bool(self.auto_train_every_save_checkbox.isChecked())
            else:
                self.auto_train_every_save = not bool(getattr(self, "auto_train_every_save", True))
        except Exception:
            self.auto_train_every_save = True
        try:
            self._apply_auto_train_policy()
        except Exception:
            pass
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-train σε κάθε αποθήκευση: ενεργό" if bool(self.auto_train_every_save) else "Auto-train σε κάθε αποθήκευση: ανενεργό")
        except Exception:
            pass

    def toggle_auto_pipeline_enabled(self):
        try:
            if hasattr(self, "auto_pipeline_checkbox") and self.auto_pipeline_checkbox is not None:
                self.auto_pipeline_enabled = bool(self.auto_pipeline_checkbox.isChecked())
            else:
                self.auto_pipeline_enabled = not bool(getattr(self, "auto_pipeline_enabled", True))
        except Exception:
            self.auto_pipeline_enabled = True
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-ροή: ενεργή" if bool(self.auto_pipeline_enabled) else "Auto-ροή: ανενεργή")
        except Exception:
            pass

    def toggle_auto_analyze_on_open(self):
        try:
            if hasattr(self, "auto_analyze_on_open_checkbox") and self.auto_analyze_on_open_checkbox is not None:
                self.auto_analyze_on_open = bool(self.auto_analyze_on_open_checkbox.isChecked())
            else:
                self.auto_analyze_on_open = not bool(getattr(self, "auto_analyze_on_open", True))
        except Exception:
            self.auto_analyze_on_open = True
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-ανάλυση: ενεργή" if bool(self.auto_analyze_on_open) else "Auto-ανάλυση: ανενεργή")
        except Exception:
            pass

    def toggle_auto_sync_multiclass_on_save(self):
        try:
            if hasattr(self, "auto_sync_multiclass_checkbox") and self.auto_sync_multiclass_checkbox is not None:
                self.auto_sync_multiclass_on_save = bool(self.auto_sync_multiclass_checkbox.isChecked())
            else:
                self.auto_sync_multiclass_on_save = not bool(getattr(self, "auto_sync_multiclass_on_save", True))
        except Exception:
            self.auto_sync_multiclass_on_save = True
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-sync dataset: ενεργό" if bool(self.auto_sync_multiclass_on_save) else "Auto-sync dataset: ανενεργό")
        except Exception:
            pass

    def toggle_auto_detect_retrain_enabled(self):
        try:
            if hasattr(self, "auto_detect_retrain_checkbox") and self.auto_detect_retrain_checkbox is not None:
                self.auto_detect_retrain_enabled = bool(self.auto_detect_retrain_checkbox.isChecked())
            else:
                self.auto_detect_retrain_enabled = not bool(getattr(self, "auto_detect_retrain_enabled", True))
        except Exception:
            self.auto_detect_retrain_enabled = True
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-retrain detect: ενεργό" if bool(self.auto_detect_retrain_enabled) else "Auto-retrain detect: ανενεργό")
        except Exception:
            pass

    def toggle_auto_toothcls_train_enabled(self):
        try:
            if hasattr(self, "auto_toothcls_train_checkbox") and self.auto_toothcls_train_checkbox is not None:
                self.auto_toothcls_train_enabled = bool(self.auto_toothcls_train_checkbox.isChecked())
            else:
                self.auto_toothcls_train_enabled = not bool(getattr(self, "auto_toothcls_train_enabled", True))
        except Exception:
            self.auto_toothcls_train_enabled = True
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Auto-train toothcls: ενεργό" if bool(self.auto_toothcls_train_enabled) else "Auto-train toothcls: ανενεργό")
        except Exception:
            pass

    def toggle_pipeline_require_confirm(self):
        try:
            if hasattr(self, "pipeline_require_confirm_checkbox") and self.pipeline_require_confirm_checkbox is not None:
                self.auto_pipeline_require_confirm = bool(self.pipeline_require_confirm_checkbox.isChecked())
            else:
                self.auto_pipeline_require_confirm = not bool(getattr(self, "auto_pipeline_require_confirm", True))
        except Exception:
            self.auto_pipeline_require_confirm = True
        try:
            self._schedule_prefs_save(0)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", "Checkpoint πριν Sync/Training: ενεργό" if bool(self.auto_pipeline_require_confirm) else "Checkpoint πριν Sync/Training: ανενεργό")
        except Exception:
            pass

    def confirm_pipeline_review(self):
        try:
            if not bool(getattr(self, "_pipeline_waiting_confirm", False)):
                self._pipeline_set(
                    "review",
                    "Δεν υπάρχει εκκρεμής επιβεβαίωση",
                    "Κάνε πρώτα αποθήκευση μετά από διόρθωση για να ενεργοποιηθεί το checkpoint.",
                    progress=60,
                )
                return
        except Exception:
            return
        try:
            data = getattr(self, "_pipeline_pending_after_save_data", None) or getattr(self, "_last_saved_analysis_data", None)
            if not isinstance(data, dict):
                data = {"image_path": getattr(self, "current_image_path", None)}
        except Exception:
            data = {"image_path": getattr(self, "current_image_path", None)}
        try:
            self._pipeline_waiting_confirm = False
            self._pipeline_pending_after_save_data = None
        except Exception:
            pass
        try:
            self._pipeline_set(
                "sync",
                "Επιβεβαιώθηκε — ξεκινά Sync/Training",
                self._pipeline_hint_for_step("sync"),
                progress=75,
                step_status_updates={"review": "OK", "sync": "RUN", "train": "WAIT"},
            )
        except Exception:
            pass
        try:
            self._auto_pipeline_after_save(data, force=True)
        except Exception:
            pass

    def _wire_ui_action_announcements(self):
        try:
            from PyQt6.QtWidgets import QAbstractButton
        except Exception:
            QAbstractButton = None
        if QAbstractButton is None:
            return
        exclude = set()
        for name in (
            "add_image_button",
            "manage_duplicates_button",
            "analyze_button",
            "verify_button",
            "export_button",
            "save_analysis_button",
            "history_button",
            "clear_analysis_button",
            "export_session_btn",
            "clear_comm_btn",
            "toggle_boxes_button",
            "center_view_button",
            "crop_button",
            "grid_button",
            "magic_wand_button",
            "jaw_lines_button",
            "missing_tooth_button",
            "calibration_button",
            "auto_fdi_checkbox",
            "lock_layout_checkbox",
            "lock_layout_quick_checkbox",
        ):
            w = getattr(self, name, None)
            if w is not None:
                exclude.add(w)
        try:
            for btn in self.findChildren(QAbstractButton):
                if btn in exclude:
                    continue
                if getattr(btn, "_announce_hooked", False):
                    continue
                try:
                    btn._announce_hooked = True
                except Exception:
                    pass
                def _make_handler(b):
                    def _h(*_args):
                        try:
                            label = str(b.text() or "").strip()
                            if not label:
                                return
                            if hasattr(b, "isCheckable") and bool(b.isCheckable()):
                                st = False
                                try:
                                    st = bool(b.isChecked())
                                except Exception:
                                    st = False
                                self._announce_action_done(f"{label}: {'ενεργό' if st else 'ανενεργό'}")
                            else:
                                self._announce_action_done(label)
                        except Exception:
                            pass
                    return _h
                try:
                    if hasattr(btn, "toggled") and bool(getattr(btn, "isCheckable", lambda: False)()):
                        btn.toggled.connect(_make_handler(btn))
                    elif hasattr(btn, "clicked"):
                        btn.clicked.connect(_make_handler(btn))
                except Exception:
                    pass
        except Exception:
            pass

    def _deactivate_action_speech(self):
        try:
            self._speak_actions_active = False
        except Exception:
            pass

    def _sanitize_action_tts_text(self, text: str) -> str:
        s = str(text or "")
        try:
            key = self._normalize_phrase_key(s)
        except Exception:
            key = s.lower()
        try:
            if ("δοντι" in key or "ελλειπ" in key) and ("προσθε" in key or "ενημερω" in key or "καταχωρ" in key):
                return "Καταχωρήθηκε."
        except Exception:
            pass
        try:
            def _repl(m):
                raw = str(m.group(0) or "")
                trimmed = raw.rstrip(").,;:]}\"'")
                suffix = raw[len(trimmed):] if len(trimmed) <= len(raw) else ""
                base = os.path.basename(trimmed.replace("/", "\\"))
                return (base or trimmed) + suffix
            s = re.sub(r"[A-Za-z]:\\\\[^\s\"<>]+", _repl, s)
        except Exception:
            return str(text or "")
        return s

    def _maybe_speak_action_comm(self, role: str, text: str):
        if str(role or "") != "Σύστημα":
            return
        if not bool(getattr(self, "comm_action_tts_enabled", False)):
            return
        if not bool(getattr(self, "_speak_actions_active", False)):
            return
        if bool(getattr(self, "_voice_running", False)):
            return
        s = self._sanitize_action_tts_text(str(text or "")).strip()
        if not s:
            return
        try:
            self._session_log("tts_action", {"role": str(role or ""), "raw": str(text or "")[:240], "sanitized": str(s)[:240]})
        except Exception:
            pass
        low = s.lower()
        if low.startswith("εντολές:") or low.startswith("χρήση:"):
            return
        if "http://" in low or "https://" in low:
            return
        if len(s) > 240:
            s = s[:240]
        self._tts_say_text(s)

    def _tts_say_text(self, text: str):
        txt = str(text or "").strip()
        if not txt:
            return
        backend = str(getattr(self, "comm_tts_backend", "qt") or "qt").strip().lower()
        if backend == "gtts":
            self._speak_gtts_thread(str(text or ""))
            return
        if backend == "piper":
            cli = str(getattr(self, "comm_piper_cli", "") or "").strip()
            voice = str(getattr(self, "comm_piper_voice_model", "") or "").strip()
            if cli and voice and os.path.exists(cli) and os.path.exists(voice):
                try:
                    self._stop_piper_tts_playback()
                except Exception:
                    pass
                try:
                    self._tts_speaking = True
                except Exception:
                    pass
                self._start_piper_tts(txt)
                return
            backend = "qt"
        if getattr(self, "_tts_engine", None) is None:
            self._init_tts_engine()
        if getattr(self, "_tts_engine", None) is None:
            return
        if getattr(self, "_tts_kind", "") == "qt":
            try:
                self._tts_engine.stop()
            except Exception:
                pass
            self._apply_tts_settings()
            try:
                self._tts_speaking = True
            except Exception:
                pass
            self._tts_engine.say(txt)

    def _stop_piper_tts_playback(self):
        try:
            s = getattr(self, "_piper_sound", None)
            if s is not None:
                try:
                    s.stop()
                except Exception:
                    pass
        except Exception:
            pass
        try:
            self._tts_speaking = False
        except Exception:
            pass

    def _normalize_confirm_key(self, text: str) -> str:
        try:
            return self._normalize_phrase_key(text)
        except Exception:
            return str(text or "").strip().lower()

    def _handle_command_confirmation_input(self, text: str) -> bool:
        action = str(getattr(self, "_pending_confirm_action", "") or "").strip()
        cmd = str(getattr(self, "_pending_confirm_command", "") or "").strip()
        prompt = str(getattr(self, "_pending_confirm_prompt", "") or "").strip()
        if not action or not cmd:
            return False
        k = self._normalize_confirm_key(text)
        low = str(text or "").strip().lower()
        is_yes = (k in ("ναι", "yes", "ok", "οκ", "ενταξει", "εντάξει")) or ("ναι" in low) or ("εκτελε" in k) or ("execute" in k)
        is_no = (k in ("οχι", "όχι", "no", "cancel", "ακυρο", "άκυρο", "ακυρωση", "ακύρωση", "stop")) or ("όχι" in low) or ("ακυρ" in k) or ("σταματ" in k)
        always = ("πάντα" in low) or ("always" in low)
        if is_yes:
            try:
                counts = getattr(self, "comm_confirm_counts", None)
                if not isinstance(counts, dict):
                    counts = {}
                    self.comm_confirm_counts = counts
                cur = int(counts.get(action, 0) or 0)
                nxt = max(cur, int(getattr(self, "comm_confirm_threshold", 1) or 1)) if always else (cur + 1)
                counts[action] = int(nxt)
                self.comm_confirm_counts = counts
                self._schedule_prefs_save(0)
            except Exception:
                pass
            try:
                self._pending_confirm_action = ""
                self._pending_confirm_command = ""
                self._pending_confirm_prompt = ""
            except Exception:
                pass
            self._append_comm("Σύστημα", "OK, εκτελώ.")
            self._handle_text_command(cmd)
            return True
        if is_no:
            try:
                self._pending_confirm_action = ""
                self._pending_confirm_command = ""
                self._pending_confirm_prompt = ""
            except Exception:
                pass
            self._append_comm("Σύστημα", "OK, ακυρώθηκε.")
            return True
        if prompt:
            self._append_comm("Σύστημα", prompt)
            return True
        self._append_comm("Σύστημα", "Απάντησε «ναι» για εκτέλεση ή «όχι» για ακύρωση.")
        return True

    def _maybe_request_command_confirmation(self, action: str, command_to_execute: str, purpose: str, detail: str) -> bool:
        if not bool(getattr(self, "comm_confirm_new_commands", True)):
            return False
        a = str(action or "").strip()
        cmd = str(command_to_execute or "").strip()
        if not a or not cmd:
            return False
        counts = getattr(self, "comm_confirm_counts", None)
        if not isinstance(counts, dict):
            counts = {}
            self.comm_confirm_counts = counts
        th = int(getattr(self, "comm_confirm_threshold", 1) or 1)
        cur = int(counts.get(a, 0) or 0)
        if cur >= th:
            return False
        try:
            self._pending_confirm_action = a
            self._pending_confirm_command = cmd
        except Exception:
            pass
        msg = str(purpose or "").strip()
        det = str(detail or "").strip()
        prompt = "Απάντησε «ναι» για εκτέλεση ή «όχι» για ακύρωση. Μπορείς επίσης «ναι, πάντα»."
        full = (msg + ("\n" + det if det else "") + "\n" + prompt).strip()
        try:
            self._pending_confirm_prompt = prompt
        except Exception:
            pass
        self._append_comm("Σύστημα", full)
        return True

    def _init_tts_engine(self):
        self._tts_engine = None
        self._tts_kind = "none"
        try:
            from PyQt6.QtTextToSpeech import QTextToSpeech
            self._tts_engine = QTextToSpeech(self)
            self._tts_kind = "qt"
            
            # --- Auto-select Greek voice if available ---
            try:
                # If no specific voice is forced by prefs yet, or if current pref is invalid
                if not getattr(self, "comm_tts_voice_id", ""):
                    best_greek = None
                    first_greek = None
                    for v in self._tts_engine.availableVoices():
                        name = str(v.name() or "").lower()
                        loc = v.locale()
                        loc_name = str(loc.name() if hasattr(loc, "name") else loc).lower()
                        if "el" in loc_name or "gr" in loc_name or "greek" in name:
                            if first_greek is None:
                                first_greek = v
                            
                            # Prefer Stefanos as it is the standard Greek voice on Windows
                            if "stefanos" in name:
                                best_greek = v
                                break
                                
                            # Check for female
                            is_female = False
                            try:
                                g = v.gender()
                                # QVoice.Gender.Female check (using string or value to be safe)
                                if str(g) == "QVoice.Gender.Female" or (hasattr(g, "name") and g.name == "Female") or g == 1:
                                    is_female = True
                            except Exception:
                                pass
                            
                            if "female" in name:
                                is_female = True

                            if is_female and not best_greek:
                                best_greek = v
                    
                    final_voice = best_greek or first_greek
                    if final_voice:
                        self._tts_engine.setVoice(final_voice)
                        # Auto-adjust rate for Greek to be slower and clearer
                        try:
                            # If rate is effectively default (0.0), slow it down for clarity
                            if abs(float(getattr(self, "comm_tts_rate", 0.0))) < 0.05:
                                self.comm_tts_rate = -0.15
                        except Exception:
                            pass
            except Exception:
                pass
            # --------------------------------------------

            self._apply_tts_settings()
            try:
                if not bool(getattr(self, "_tts_state_connected", False)):
                    self._tts_engine.stateChanged.connect(self._on_qt_tts_state_changed)
                    self._tts_state_connected = True
            except Exception:
                pass
        except Exception:
            self._tts_engine = None
            self._tts_kind = "none"

    def _apply_tts_settings(self):
        try:
            if getattr(self, "_tts_kind", "") == "qt" and getattr(self, "_tts_engine", None) is not None:
                self._tts_engine.setRate(float(getattr(self, "comm_tts_rate", 0.0) or 0.0))
                self._tts_engine.setVolume(float(getattr(self, "comm_tts_volume", 1.0) or 1.0))
        except Exception:
            pass

    def _get_tts_voice_choices(self) -> list[tuple[str, str]]:
        try:
            if getattr(self, "_tts_engine", None) is None:
                self._init_tts_engine()
            
            out = []
            
            # Add Google Cloud option if libraries are available
            if TTSWorker:
                out.append(("Google Cloud Greek (Online - Πιο φυσική)", "google_el"))
            
            eng = getattr(self, "_tts_engine", None)
            if eng is not None and getattr(self, "_tts_kind", "") == "qt":
                try:
                    voices = list(eng.availableVoices() or [])
                except Exception:
                    voices = []
                for v in voices:
                    try:
                        name = str(v.name() or "").strip()
                        loc = v.locale()
                        loc_name = str(loc.name() if hasattr(loc, "name") else loc).strip()
                        key = f"{name}|{loc_name}"
                        label = f"{name} ({loc_name})" if loc_name else name
                        if name:
                            out.append((label, key))
                    except Exception:
                        continue
            
            out.sort(key=lambda x: x[0].lower())
            return out
        except Exception:
            return []

    def _set_tts_voice_choice(self, key: str):
        k = str(key or "")
        try:
            self.comm_tts_voice_id = k
        except Exception:
            pass
        if not k:
            try:
                self._schedule_prefs_save()
            except Exception:
                pass
            return
            
        # Handle Google Cloud TTS selection
        if k == "google_el":
            try:
                self.comm_tts_backend = "gtts"
                self.comm_tts_enabled = True
                if hasattr(self, "comm_tts_backend_combo") and self.comm_tts_backend_combo is not None:
                    # Try to find gtts if it exists in combo, else just ignore
                    pass
                if hasattr(self, "voice_tts_toggle") and self.voice_tts_toggle is not None:
                    self.voice_tts_toggle.setChecked(True)
                self._save_viewer_prefs()
            except Exception:
                self._schedule_prefs_save()
            return

        try:
            if getattr(self, "_tts_engine", None) is None:
                self._init_tts_engine()
            eng = getattr(self, "_tts_engine", None)
            if eng is None or getattr(self, "_tts_kind", "") != "qt":
                return
            want_name = ""
            want_loc = ""
            try:
                want_name, want_loc = k.split("|", 1)
            except Exception:
                want_name = k
                want_loc = ""
            chosen = None
            try:
                voices = list(eng.availableVoices() or [])
            except Exception:
                voices = []
            for v in voices:
                try:
                    name = str(v.name() or "").strip()
                    loc = v.locale()
                    loc_name = str(loc.name() if hasattr(loc, "name") else loc).strip()
                    if name == want_name and (not want_loc or loc_name == want_loc):
                        chosen = v
                        break
                except Exception:
                    continue
            if chosen is None:
                return
            try:
                eng.setVoice(chosen)
            except Exception:
                pass
            try:
                self.comm_tts_backend = "qt"
                self.comm_tts_enabled = True
                self._apply_tts_settings()
                if hasattr(self, "comm_tts_backend_combo") and self.comm_tts_backend_combo is not None:
                    idx = self.comm_tts_backend_combo.findData("qt")
                    if idx >= 0:
                        self.comm_tts_backend_combo.setCurrentIndex(idx)
                if hasattr(self, "voice_tts_toggle") and self.voice_tts_toggle is not None:
                    self.voice_tts_toggle.setChecked(True)
            except Exception:
                pass
            try:
                self._save_viewer_prefs()
            except Exception:
                self._schedule_prefs_save()
        except Exception:
            pass
            
    def _speak_gtts_thread(self, text: str):
        if not TTSWorker:
            return
        
        # Stop existing worker if any
        if getattr(self, "_gtts_worker", None):
            try:
                self._gtts_worker.stop()
                self._gtts_worker.quit()
                self._gtts_worker.wait()
            except Exception:
                pass
        
        self._tts_speaking = True
        self._gtts_worker = TTSWorker(text, lang='el')
        self._gtts_worker.finished.connect(self._on_gtts_finished)
        self._gtts_worker.error.connect(self._on_gtts_error)
        self._gtts_worker.start()

    def _on_gtts_finished(self):
        self._tts_speaking = False
        self._maybe_schedule_voice_chat_resume(400)
        self._gtts_worker = None

    def _on_gtts_error(self, err):
        print(f"GTTS Error: {err}")
        self._tts_speaking = False
        self._maybe_schedule_voice_chat_resume(400)
        self._gtts_worker = None

    def _on_qt_tts_state_changed(self, state):
        try:
            from PyQt6.QtTextToSpeech import QTextToSpeech
            if state == QTextToSpeech.State.Ready:
                self._tts_speaking = False
                self._maybe_schedule_voice_chat_resume(400)
            elif state == QTextToSpeech.State.Error:
                self._tts_speaking = False
                self._maybe_schedule_voice_chat_resume(400)
            else:
                self._tts_speaking = True
        except Exception:
            pass

    def _maybe_speak_comm(self, role: str, text: str):
        if str(role or "") != "AI":
            return
        if not bool(getattr(self, "comm_tts_enabled", False)):
            return
        if bool(getattr(self, "_voice_running", False)):
            return
        try:
            self._tts_last_text = str(text or "")
        except Exception:
            self._tts_last_text = ""
        backend = str(getattr(self, "comm_tts_backend", "qt") or "qt").strip().lower()
        if backend == "piper":
            try:
                self._tts_speaking = True
            except Exception:
                pass
            self._start_piper_tts(str(text or ""))
            return
        if getattr(self, "_tts_engine", None) is None:
            self._init_tts_engine()
        if getattr(self, "_tts_engine", None) is None:
            return
        if getattr(self, "_tts_kind", "") == "qt":
            try:
                self._tts_engine.stop()
            except Exception:
                pass
            self._apply_tts_settings()
            try:
                self._tts_speaking = True
            except Exception:
                pass
            self._tts_engine.say(str(text or ""))

    def _ensure_voice_chat_tts_ready(self):
        try:
            self.comm_tts_enabled = True
            try:
                if hasattr(self, "voice_tts_toggle") and self.voice_tts_toggle is not None:
                    self.voice_tts_toggle.setChecked(True)
            except Exception:
                pass
        except Exception:
            pass
        try:
            if getattr(self, "_tts_engine", None) is None:
                self._init_tts_engine()
            if getattr(self, "_tts_engine", None) is not None and getattr(self, "_tts_kind", "") == "qt":
                chosen = None
                found_stefanos = False
                try:
                    voices = list(self._tts_engine.availableVoices() or [])
                except Exception:
                    voices = []
                try:
                    pref = str(getattr(self, "comm_tts_voice_id", "") or "").strip()
                    if pref:
                        want_name = ""
                        want_loc = ""
                        try:
                            want_name, want_loc = pref.split("|", 1)
                        except Exception:
                            want_name = pref
                            want_loc = ""
                        for v in voices:
                            try:
                                name = str(v.name() or "").strip()
                                loc = v.locale()
                                loc_name = str(loc.name() if hasattr(loc, "name") else loc).strip()
                                if name == want_name and (not want_loc or loc_name == want_loc):
                                    chosen = v
                                    break
                            except Exception:
                                continue
                except Exception:
                    pass
                # Force Piper for clearer Greek speech if no specific voice is selected
                # The following system voice auto-detection is disabled to prioritize Piper (Rapunzelina)
                if chosen is None:
                    pass
                
                # if chosen is None:
                #     for v in voices:
                #         try:
                #             if "stefanos" in str(v.name() or "").lower():
                #                 chosen = v
                #                 found_stefanos = True
                #                 break
                #         except Exception:
                #             continue
                # if chosen is None:
                #     for v in voices:
                #         try:
                #             loc = v.locale()
                #             loc_name = str(loc.name() if hasattr(loc, "name") else loc).lower()
                #             nm = str(v.name() or "").lower()
                #             if loc_name.startswith("el") and ("male" in nm or "stefanos" in nm):
                #                 chosen = v
                #                 if "stefanos" in nm:
                #                     found_stefanos = True
                #                 break
                #         except Exception:
                #             continue
                # if chosen is None:
                #     for v in voices:
                #         try:
                #             loc = v.locale()
                #             loc_name = str(loc.name() if hasattr(loc, "name") else loc).lower()
                #             if loc_name.startswith("el"):
                #                 chosen = v
                #                 break
                #         except Exception:
                #             continue
                if chosen is not None:
                    try:
                        self._tts_engine.setVoice(chosen)
                    except Exception:
                        pass
                    try:
                        self.comm_tts_backend = "qt"
                        self.comm_tts_rate = -0.25
                        self._apply_tts_settings()
                        if hasattr(self, "comm_tts_backend_combo") and self.comm_tts_backend_combo is not None:
                            idx = self.comm_tts_backend_combo.findData("qt")
                            if idx >= 0:
                                self.comm_tts_backend_combo.setCurrentIndex(idx)
                    except Exception:
                        pass
                    return True
                try:
                    if bool(getattr(self, "comm_voice_chat_enabled", False)) and not bool(getattr(self, "_tts_warned_no_male_el", False)):
                        self._tts_warned_no_male_el = True
                        if not found_stefanos:
                            self._append_comm("Σύστημα", "Ενεργοποίηση βελτιωμένης ελληνικής φωνής (Piper)...", room="voice")
                except Exception:
                    pass
        except Exception:
            pass
        try:
            self.comm_tts_backend = "piper"
            try:
                if hasattr(self, "comm_tts_backend_combo") and self.comm_tts_backend_combo is not None:
                    idx = self.comm_tts_backend_combo.findData("piper")
                    if idx >= 0:
                        self.comm_tts_backend_combo.setCurrentIndex(idx)
            except Exception:
                pass
        except Exception:
            pass
        try:
            if getattr(self, "comm_piper_length_scale", None) is None:
                self.comm_piper_length_scale = 1.12
        except Exception:
            pass
        try:
            cli = str(getattr(self, "comm_piper_cli", "") or "").strip()
            voice = str(getattr(self, "comm_piper_voice_model", "") or "").strip()
            try:
                if hasattr(self, "comm_piper_cli_edit") and self.comm_piper_cli_edit is not None:
                    cli = str(self.comm_piper_cli_edit.text() or "").strip() or cli
                if hasattr(self, "comm_piper_voice_edit") and self.comm_piper_voice_edit is not None:
                    voice = str(self.comm_piper_voice_edit.text() or "").strip() or voice
            except Exception:
                pass
            try:
                if voice and voice.endswith("-low.onnx"):
                    med = voice.replace("-low.onnx", "-medium.onnx")
                    if os.path.exists(med):
                        voice = med
                        try:
                            if hasattr(self, "comm_piper_voice_edit") and self.comm_piper_voice_edit is not None:
                                self.comm_piper_voice_edit.setText(voice)
                        except Exception:
                            pass
            except Exception:
                pass
            ok = bool(cli and voice and os.path.exists(cli) and os.path.exists(voice))
            if ok:
                self.comm_piper_cli = cli
                self.comm_piper_voice_model = voice
                return True
        except Exception:
            pass
        try:
            w = getattr(self, "piper_install_worker", None)
            if w is not None and hasattr(w, "isRunning") and w.isRunning():
                return False
        except Exception:
            pass
        try:
            self._install_embedded_piper()
        except Exception:
            pass
        return False

    def _speak_text(self, text: str):
        txt = str(text or "")
        try:
            txt = re.sub(r"\s+", " ", txt).strip()
        except Exception:
            txt = str(txt or "").strip()
        try:
            if len(txt) > 420:
                txt = txt[:420]
        except Exception:
            pass
        if not txt:
            return
        try:
            if not bool(getattr(self, "comm_tts_enabled", False)):
                return
            if bool(getattr(self, "_voice_running", False)):
                return
        except Exception:
            pass
        backend = str(getattr(self, "comm_tts_backend", "qt") or "qt").strip().lower()
        if backend == "edge-tts":
            self._start_edge_tts(txt)
            return
        if backend == "piper":
            self._start_piper_tts(txt)
            return
        if getattr(self, "_tts_engine", None) is None:
            self._init_tts_engine()
        if getattr(self, "_tts_engine", None) is None:
            return
        try:
            self._tts_engine.stop()
        except Exception:
            pass
        self._apply_tts_settings()
        try:
            self._tts_speaking = True
        except Exception:
            pass
        try:
            self._tts_engine.say(txt)
        except Exception:
            pass


    def _start_edge_tts(self, text: str):
        try:
            if hasattr(self, "comm_edge_tts_voice_edit"):
                self.comm_edge_tts_voice = str(self.comm_edge_tts_voice_edit.text() or "").strip()
        except Exception:
            pass

        voice = str(getattr(self, "comm_edge_tts_voice", "el-GR-AthinaNeural") or "el-GR-AthinaNeural").strip()

        try:
            self._stop_piper_tts_playback()
        except Exception:
            pass
            
        try:
            if getattr(self, "_tts_engine", None):
                self._tts_engine.stop()
        except Exception:
            pass
            
        try:
            w = getattr(self, "edge_tts_worker", None)
            if w and hasattr(w, "isRunning") and w.isRunning():
                return
        except Exception:
            pass
            
        self.edge_tts_worker = EdgeTTSSpeakWorker(voice, text, parent=self)
        
        # Reuse piper done logic which plays generic audio file
        # But we need to make sure we don't trigger piper-specific checks that might fail
        # _on_piper_tts_done takes (wav_path, elapsed_ms, request_id)
        # We can pass 0 as request_id for now or manage a request id for edge tts too
        
        self.edge_tts_worker.finished.connect(lambda p, ms: self._on_piper_tts_done(p, ms, 0))
        self.edge_tts_worker.error.connect(lambda e: self._on_piper_tts_error(e))
        self.edge_tts_worker.start()

    def _start_piper_tts(self, text: str):
        try:
            try:
                if hasattr(self, "comm_piper_cli_edit"):
                    self.comm_piper_cli = str(self.comm_piper_cli_edit.text() or "").strip()
                if hasattr(self, "comm_piper_voice_edit"):
                    self.comm_piper_voice_model = str(self.comm_piper_voice_edit.text() or "").strip()
            except Exception:
                pass

            cli = str(getattr(self, "comm_piper_cli", "") or "").strip()
            voice = str(getattr(self, "comm_piper_voice_model", "") or "").strip()
            if not (cli and voice and os.path.exists(cli) and os.path.exists(voice)):
                if bool(getattr(self, "comm_voice_chat_enabled", False)):
                    try:
                        self._tts_pending_text = str(text or "").strip()
                    except Exception:
                        self._tts_pending_text = str(text or "").strip()
                    self._ensure_voice_chat_tts_ready()
                    return
                self._on_piper_tts_error("Δεν βρέθηκε piper.exe ή voice model.")
                return

            try:
                self._stop_piper_tts_playback()
            except Exception:
                pass
            try:
                rid = int(getattr(self, "_piper_tts_request_id", 0) or 0) + 1
                self._piper_tts_request_id = int(rid)
            except Exception:
                rid = 1
                self._piper_tts_request_id = 1
            try:
                self._piper_tts_last_text = str(text or "").strip()
            except Exception:
                pass
            try:
                self._session_log(
                    "tts_request",
                    {
                        "backend": "piper",
                        "request_id": int(rid),
                        "text": str(text or "")[:240],
                        "manual_scan_active": bool(getattr(self, "_manual_scan_active", False)),
                        "manual_scan_paused": bool(getattr(self, "_manual_scan_paused", False)),
                        "manual_scan_fdi": int(getattr(self, "_manual_scan_current_fdi", 0) or 0),
                    },
                )
            except Exception:
                pass

            w = getattr(self, "piper_tts_worker", None)
            if w is not None and hasattr(w, "isRunning") and w.isRunning():
                try:
                    w.requestInterruption()
                except Exception:
                    pass
                try:
                    w.wait(200)
                except Exception:
                    pass
                try:
                    if w.isRunning():
                        w.terminate()
                        w.wait(200)
                except Exception:
                    pass

            self.piper_tts_worker = PiperSpeakWorker(
                getattr(self, "comm_piper_cli", ""),
                getattr(self, "comm_piper_voice_model", ""),
                str(text or ""),
                volume=float(getattr(self, "comm_tts_volume", 1.0) or 1.0),
                length_scale=getattr(self, "comm_piper_length_scale", None),
                parent=self,
            )
            try:
                self.piper_tts_worker.setProperty("stoma_tts_request_id", int(rid))
            except Exception:
                pass
            self.piper_tts_worker.finished.connect(lambda wav_path, elapsed_ms, _rid=int(rid): self._on_piper_tts_done(wav_path, elapsed_ms, _rid))
            self.piper_tts_worker.error.connect(lambda message, _rid=int(rid): self._on_piper_tts_error(message, _rid))
            self.piper_tts_worker.start()
        except Exception:
            pass

    def _on_piper_tts_done(self, wav_path: str, elapsed_ms: float, request_id: int | None = None):
        try:
            try:
                cur = int(getattr(self, "_piper_tts_request_id", 0) or 0)
            except Exception:
                cur = 0
            try:
                if request_id is not None and int(request_id) != int(cur):
                    self._session_log("tts_drop", {"backend": "piper", "reason": "stale", "request_id": int(request_id), "current_id": int(cur)})
                    return
            except Exception:
                pass
            try:
                from PyQt6.QtMultimedia import QSoundEffect
            except Exception:
                try:
                    import winsound
                    winsound.PlaySound(str(wav_path), winsound.SND_FILENAME | winsound.SND_ASYNC)
                    self._session_log("tts_finished", {"backend": "piper", "player": "winsound", "elapsed_ms": float(elapsed_ms)})
                    try:
                        self._tts_speaking = False
                    except Exception:
                        pass
                    self._maybe_schedule_voice_chat_resume(2200)
                    return
                except Exception:
                    self._append_comm("Σύστημα", "TTS Piper: Δεν είναι διαθέσιμο το playback (QtMultimedia/winsound).")
                    try:
                        self._tts_speaking = False
                    except Exception:
                        pass
                    self._maybe_schedule_voice_chat_resume(600)
                    return
            try:
                self._stop_piper_tts_playback()
            except Exception:
                pass

            self._piper_sound = QSoundEffect(self)
            self._piper_sound.setSource(QUrl.fromLocalFile(str(wav_path)))
            self._piper_sound.setLoopCount(1)
            try:
                self._piper_sound.setVolume(float(getattr(self, "comm_tts_volume", 1.0) or 1.0))
            except Exception:
                pass
            try:
                self._tts_speaking = True
            except Exception:
                pass
            try:
                self._piper_sound.playingChanged.connect(self._on_piper_playing_changed)
            except Exception:
                pass
            self._piper_sound.play()
            self._session_log("tts_finished", {"backend": "piper", "elapsed_ms": float(elapsed_ms)})
        except Exception:
            pass

    def _on_piper_playing_changed(self):
        try:
            s = getattr(self, "_piper_sound", None)
            if s is None:
                return
            try:
                playing = bool(s.isPlaying())
            except Exception:
                playing = False
            if not playing:
                self._tts_speaking = False
                self._maybe_schedule_voice_chat_resume(450)
        except Exception:
            pass

    def _on_piper_tts_error(self, message: str, request_id: int | None = None):
        try:
            try:
                cur = int(getattr(self, "_piper_tts_request_id", 0) or 0)
            except Exception:
                cur = 0
            try:
                if request_id is not None and int(request_id) != int(cur):
                    self._session_log("tts_drop", {"backend": "piper", "reason": "stale_error", "request_id": int(request_id), "current_id": int(cur)})
                    return
            except Exception:
                pass
            self._append_comm("Σύστημα", f"TTS Piper σφάλμα: {message}")
            self._session_log("tts_error", {"backend": "piper", "message": str(message or "")})
            try:
                self._tts_speaking = False
            except Exception:
                pass
            try:
                self._maybe_schedule_voice_chat_resume(600)
            except Exception:
                pass
        except Exception:
            pass

    def _direct_command_from_text(self, text: str):
        raw = str(text or "").strip()
        if not raw:
            return None
        if raw.startswith("/"):
            return raw
        key = self._normalize_phrase_key(raw)
        if not key:
            return None
        try:
            alias = (self.comm_aliases or {}).get(key)
            if alias:
                return str(alias).strip()
        except Exception:
            pass

        try:
            macros = getattr(self, "comm_macros", None)
            if isinstance(macros, dict):
                m = macros.get(raw.strip()) or macros.get(key)
                if isinstance(m, list) and m:
                    return f"/macro run {raw.strip()}"
        except Exception:
            pass

        stop = {
            "βαλε", "βάλε", "βαλτο", "βάλτο", "ενεργοποιησε", "ενεργοποίησε", "ανοιξε", "άνοιξε",
            "κανε", "κάνε", "ξεκινα", "ξεκίνα", "δειξε", "δείξε", "κρυψε", "κρύψε",
            "το", "την", "τα", "το", "στην", "στο", "σε", "μου", "παρακαλω", "παρακαλώ",
            "please", "plz",
        }
        tokens = [t for t in re.split(r"[^\w]+", key) if t]
        kept = [t for t in tokens if t not in stop]
        if not kept:
            return None

        try:
            mnum = re.search(r"(-?\d{1,4})", key)
            num = int(mnum.group(1)) if mnum else None
        except Exception:
            num = None

        if num is not None:
            if any(t.startswith(("φωτεινοτ", "φωτισμ", "brightness")) for t in kept):
                return f"/set brightness {num}"
            if any(t.startswith(("αντιθεσ", "contrast")) for t in kept):
                return f"/set contrast {num}"
            if any(t.startswith(("goto", "πηγαιν")) for t in kept):
                return f"/goto {num}"
            if any(t.startswith(("spot", "hotspot", "αλλαγ")) for t in kept):
                return f"/spot {num}"

        if any(t.startswith(("προσθηκ", "εισαγωγ", "φορτωσ", "ανεβασ")) for t in kept):
            if any(t.startswith(("ακτινογραφ", "ακτινο", "εικο", "dcm", "dicom", "radiograph", "image")) for t in kept):
                return "προσθήκη ακτινογραφίας"
        if any(t.startswith(("διπλοτυπ", "duplicate")) for t in kept):
            return "διπλότυπα"
        if ("ιδια" in kept or "ίδια" in kept) and any(t.startswith(("διαδικασ", "process", "procedure")) for t in kept):
            return raw

        if any(t.startswith(("επαληθευ", "verify")) for t in kept):
            return "επαλήθευση"
        if any(t.startswith(("εξαγωγ", "export")) for t in kept):
            if any(t.startswith(("αναλυ", "analysis")) for t in kept):
                return "εξαγωγή"
            try:
                if getattr(self, "analysis_results", None):
                    return "εξαγωγή"
            except Exception:
                pass
        if (any(t.startswith(("αποθηκευ", "save")) for t in kept)) and (any(t.startswith(("αναλυ", "analysis")) for t in kept)):
            return "αποθήκευση ανάλυσης"
        if any(t.startswith(("αποθηκευ", "save")) for t in kept):
            try:
                if getattr(self, "analysis_results", None):
                    return "αποθήκευση ανάλυσης"
            except Exception:
                pass
        if (any(t.startswith(("καθαρισ", "clear")) for t in kept)) and (any(t.startswith(("αναλυ", "analysis", "πλαισι", "boxes")) for t in kept)):
            return "καθαρισμός ανάλυσης"
        if any(t.startswith(("ιστορ", "history")) for t in kept):
            return "ιστορικό"
        if any(t.startswith(("yolo", "seg")) for t in kept):
            return "yolo"
        if any(t.startswith(("γραμμ", "jaw", "separator")) for t in kept):
            return "γραμμές"
        if ("auto" in kept and "fdi" in kept) or ("fdi" in kept and "auto" in kept):
            return "auto fdi"
        if any(t.startswith(("κλειδω", "lock")) for t in kept):
            return "κλείδωμα"

        if any(t.startswith(("εκπαιδευ", "εκπαίδευ", "training", "train")) for t in kept):
            if any(t.startswith(("μοντελ", "μοντέλ", "model")) for t in kept) or "τωρα" in kept or "τώρα" in kept:
                return "εκπαίδευση μοντέλου"

        if any(t.startswith(("επαναφορ", "realign", "align")) for t in kept) and ("label" in kept or "labels" in kept or "labels" in raw.lower() or "label" in raw.lower()):
            return "επαναφορά labels"

        if any(t.startswith(("μεταφορ", "transfer")) for t in kept) and any(t.startswith(("προηγ", "previous")) for t in kept):
            return "μεταφορά προηγούμενης"

        if any(t.startswith(("αλλαγ", "changes", "heatmap")) for t in kept):
            return "αλλαγές"

        if "πλεγμα" in kept or "grid" in kept:
            return "πλέγμα"
        if "αναλυση" in kept or "analyze" in kept:
            return "ανάλυση"
        if "κεντραρισμα" in kept or "κεντραρε" in kept or "κεντραρω" in kept or "center" in kept:
            return "κεντράρισμα"
        if "μαγικο" in kept or "wand" in kept:
            return "μαγικό"
        if "αποκοπη" in kept or "crop" in kept:
            return "αποκοπή"
        if "βαθμονομηση" in kept or "calib" in kept or "ruler" in kept:
            return "βαθμονόμηση"
        if "επομενη" in kept or "next" in kept:
            return "επόμενη"
        if "προηγουμενη" in kept or "prev" in kept:
            return "προηγούμενη"
        if "πλαισια" in kept or "boxes" in kept:
            return "πλαίσια"

        return None

    def _send_text_message(self):
        txt = self.text_input.text().strip()
        if not txt:
            return
        self._ai_last_origin = "text"
        self._ai_last_user_text = str(txt)
        self._update_known_commands()
        self._maybe_suggest_command(txt)
        self._append_comm("Χρήστης", txt)
        try:
            if self._handle_command_confirmation_input(txt):
                self.text_input.clear()
                return
        except Exception:
            pass
        try:
            if self._handle_post_analysis_flow_input(txt):
                self.text_input.clear()
                return
        except Exception:
            pass
        direct = self._direct_command_from_text(txt)
        if direct:
            self._handle_text_command(direct)
        elif getattr(self, "comm_ai_enabled", False):
            self._send_ai_message(txt)
        else:
            self._handle_text_command(txt)
        self.text_input.clear()

    def _toggle_ai_mode(self):
        try:
            self.comm_ai_enabled = bool(self.comm_ai_toggle.isChecked())
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "AI mode: ενεργό" if self.comm_ai_enabled else "AI mode: ανενεργό")
        except Exception:
            pass
        try:
            self._update_comm_advanced_visibility()
        except Exception:
            pass

    def _toggle_ai_auto_execute(self):
        try:
            self.comm_ai_auto_execute = bool(self.comm_ai_auto_exec_toggle.isChecked())
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "AI auto-εκτέλεση: ενεργή" if self.comm_ai_auto_execute else "AI auto-εκτέλεση: ανενεργή")
        except Exception:
            pass

    def _toggle_learning_mode(self):
        try:
            self.comm_learning_enabled = bool(self.comm_learning_toggle.isChecked())
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Μάθηση: ενεργή" if self.comm_learning_enabled else "Μάθηση: ανενεργή")
            if not self.comm_learning_enabled:
                self._learn_pending_phrase = ""
                self._learn_pending_command = ""
                self._update_learn_pending_ui()
        except Exception:
            pass

    def _toggle_chatty_mode(self):
        try:
            self.comm_conversation_enabled = bool(self.comm_chatty_toggle.isChecked())
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Διάλογος: ενεργός" if self.comm_conversation_enabled else "Διάλογος: ανενεργός")
        except Exception:
            pass

    def _toggle_live_mode(self):
        try:
            self.comm_ai_stream_enabled = bool(self.comm_live_toggle.isChecked())
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Ζωντανά: ενεργό" if self.comm_ai_stream_enabled else "Ζωντανά: ανενεργό")
        except Exception:
            pass

    def _on_ai_backend_changed(self):
        try:
            if hasattr(self, "comm_ai_backend_combo") and self.comm_ai_backend_combo is not None:
                self.comm_ai_backend_mode = str(self.comm_ai_backend_combo.currentData() or "hybrid")
            self._save_viewer_prefs()
        except Exception:
            pass
        try:
            self._update_comm_advanced_visibility()
        except Exception:
            pass

    def _on_comm_advanced_toggled(self):
        try:
            self._comm_advanced_expanded_pref = bool(self.comm_advanced_btn.isChecked())
        except Exception:
            self._comm_advanced_expanded_pref = False
        try:
            self._update_comm_advanced_visibility()
        except Exception:
            pass
        try:
            self._schedule_prefs_save(250)
        except Exception:
            pass

    def _update_comm_advanced_visibility(self):
        try:
            btn = getattr(self, "comm_advanced_btn", None)
            ai = getattr(self, "ai_cfg_scroll", None)
            cloud = getattr(self, "cloud_cfg_scroll", None)
            if btn is None:
                return
            enabled = bool(getattr(self, "comm_ai_enabled", False))
            row = getattr(self, "comm_advanced_row", None)
            try:
                btn.setVisible(bool(enabled))
            except Exception:
                pass
            try:
                if row is not None:
                    row.setVisible(bool(enabled))
            except Exception:
                pass
            if not enabled:
                try:
                    btn.setChecked(False)
                except Exception:
                    pass
                try:
                    self._comm_advanced_expanded_pref = False
                except Exception:
                    pass
            expanded = bool(btn.isChecked()) if enabled else False
            mode = str(getattr(self, "comm_ai_backend_mode", "hybrid") or "hybrid").strip().lower() or "hybrid"
            show_ai = bool(expanded and mode in ("hybrid", "local"))
            show_cloud = bool(expanded and mode in ("hybrid", "cloud"))
            if ai is not None:
                try:
                    ai.setVisible(show_ai)
                except Exception:
                    pass
            if cloud is not None:
                try:
                    cloud.setVisible(show_cloud)
                except Exception:
                    pass
            try:
                btn.setText("Προχωρημένα ▴" if expanded else "Προχωρημένα ▾")
            except Exception:
                pass
        except Exception:
            pass

    def _save_ai_prefs_from_ui(self):
        try:
            self.comm_llm_url = self._normalize_ai_url(str(self.comm_llm_url_edit.text() or "").strip())
            self.comm_llm_model = str(self.comm_llm_model_edit.text() or "").strip()
            try:
                if hasattr(self, "comm_ai_backend_combo") and self.comm_ai_backend_combo is not None:
                    self.comm_ai_backend_mode = str(self.comm_ai_backend_combo.currentData() or "hybrid")
            except Exception:
                pass
            try:
                if hasattr(self, "comm_cloud_base_edit") and self.comm_cloud_base_edit is not None:
                    self.comm_cloud_api_base = str(self.comm_cloud_base_edit.text() or "").strip() or "https://api.openai.com/v1"
            except Exception:
                pass
            try:
                if hasattr(self, "comm_cloud_model_edit") and self.comm_cloud_model_edit is not None:
                    self.comm_cloud_model = str(self.comm_cloud_model_edit.text() or "").strip() or "gpt-4o-mini"
            except Exception:
                pass
            self.comm_ai_enabled = bool(self.comm_ai_toggle.isChecked())
            try:
                self.comm_ai_auto_execute = bool(self.comm_ai_auto_exec_toggle.isChecked())
            except Exception:
                pass
            try:
                self.comm_learning_enabled = bool(self.comm_learning_toggle.isChecked())
            except Exception:
                pass
            try:
                self.comm_conversation_enabled = bool(self.comm_chatty_toggle.isChecked())
            except Exception:
                pass
            try:
                self.comm_ai_stream_enabled = bool(self.comm_live_toggle.isChecked())
            except Exception:
                pass
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Αποθηκεύτηκαν οι ρυθμίσεις AI.")
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία αποθήκευσης AI: {e}")

    def _set_cloud_defaults(self):
        try:
            if hasattr(self, "comm_cloud_base_edit"):
                self.comm_cloud_base_edit.setText("https://api.openai.com/v1")
            if hasattr(self, "comm_cloud_model_edit") and not str(self.comm_cloud_model_edit.text() or "").strip():
                self.comm_cloud_model_edit.setText("gpt-4o-mini")
            self._append_comm("Σύστημα", "Έγινε preset για Cloud. Βάλε OPENAI_API_KEY στο περιβάλλον και πάτα «Αποθήκευση AI».")
        except Exception:
            pass

    def _edit_ai_prompt(self):
        try:
            current = str(getattr(self, "comm_llm_system_prompt", "") or "")
            txt, ok = QInputDialog.getMultiLineText(self, "AI Prompt", "System prompt:", current)
            if not ok:
                return
            self.comm_llm_system_prompt = str(txt or "").strip()
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Αποθηκεύτηκε το AI prompt.")
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία prompt: {e}")

    def _edit_ai_memory(self):
        try:
            key = self._get_patient_key()
            by_patient = getattr(self, "comm_patient_memory", None)
            if not isinstance(by_patient, dict):
                by_patient = {}
                self.comm_patient_memory = by_patient
            current = str(by_patient.get(key) or "").strip() if key != "general" else str(getattr(self, "comm_memory_text", "") or "")
            title = "Μνήμη Ασθενή" if key != "general" else "Μνήμη"
            prompt = "Τι να θυμάμαι για τον ασθενή:" if key != "general" else "Τι να θυμάμαι μόνιμα:"
            txt, ok = QInputDialog.getMultiLineText(self, title, prompt, current)
            if not ok:
                return
            if key != "general":
                by_patient[key] = str(txt or "").strip()
            else:
                self.comm_memory_text = str(txt or "").strip()
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Αποθηκεύτηκε η μνήμη.")
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία μνήμης: {e}")

    def _set_ollama_defaults(self):
        try:
            if hasattr(self, "comm_llm_url_edit"):
                self.comm_llm_url_edit.setText("http://localhost:11434/api/chat")
            if hasattr(self, "comm_llm_model_edit") and not str(self.comm_llm_model_edit.text() or "").strip():
                self.comm_llm_model_edit.setText("llama3.2:1b")
            self._append_comm("Σύστημα", "Έγινε preset για Ollama. Πάτα «Έλεγχος» και μετά «Αποθήκευση AI».")
        except Exception:
            pass

    def _show_ollama_help(self):
        try:
            model = "llama3.1:8b-instruct"
            try:
                if hasattr(self, "comm_llm_model_edit"):
                    model = str(self.comm_llm_model_edit.text() or "").strip() or model
            except Exception:
                model = model
            self._append_comm("Σύστημα", "Οδηγίες Ollama:\n1) Εγκατάσταση από: https://ollama.com/download/windows\n2) Άνοιξε το Ollama (τρέχει στο localhost:11434)\n3) Κατέβασε μοντέλο: ollama pull " + model + "\n4) Πάτα «Έλεγχος» → «Αποθήκευση AI»\n\nΕναλλακτικά: πάτα «Εκκίνηση» για φορητή ενσωμάτωση (zip) μέσα στο πρόγραμμα.")
            try:
                QDesktopServices.openUrl(QUrl("https://ollama.com/download/windows"))
            except Exception:
                pass
        except Exception:
            pass

    def _start_ollama_pull(self):
        try:
            room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
            cli = self._find_ollama_cli()
            model = ""
            try:
                model = str(self.comm_llm_model_edit.text() or "").strip()
            except Exception:
                model = ""
            if not model:
                model = "llama3.1:8b-instruct"
                try:
                    self.comm_llm_model_edit.setText(model)
                except Exception:
                    pass
            cleaned = self._sanitize_ollama_model_name(model)
            if cleaned and cleaned != model:
                model = cleaned
                try:
                    self.comm_llm_model_edit.setText(model)
                except Exception:
                    pass

            w = getattr(self, "ollama_pull_worker", None)
            if w is not None and hasattr(w, "isRunning") and w.isRunning():
                self._append_comm("Σύστημα", "Υπάρχει ήδη κατέβασμα μοντέλου σε εξέλιξη.", room=room)
                return

            self._append_comm("Σύστημα", f"Pull μοντέλου: {model}…", room=room)
            try:
                if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                    self.layout_save_label.setText("Pull μοντέλου…")
            except Exception:
                pass
            self.ollama_pull_worker = OllamaPullWorker(cli, model, parent=self)
            self.ollama_pull_worker.progress.connect(self._on_ollama_pull_progress)
            self.ollama_pull_worker.finished.connect(self._on_ollama_pull_done)
            self.ollama_pull_worker.error.connect(self._on_ollama_pull_error)
            self.ollama_pull_worker.start()
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία pull: {e}", room="voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None)

    def _on_ollama_pull_progress(self, line: str):
        try:
            room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
            s = str(line or "")
            try:
                s = re.sub(r"\x1b\[[0-9;?]*[A-Za-z]", "", s)
            except Exception:
                pass
            s = s.strip()
            if not s:
                return
            self._append_comm("Ollama", s, room=room)
        except Exception:
            pass

    def _on_ollama_pull_done(self, model_name: str, elapsed_ms: float):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        self._append_comm("Σύστημα", f"✅ Έτοιμο μοντέλο: {model_name} ({elapsed_ms:.0f}ms).", room="voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None)
        try:
            self._check_ollama_connection()
        except Exception:
            pass
        try:
            w = getattr(self, "ollama_pull_worker", None)
            if w is not None:
                try:
                    w.deleteLater()
                except Exception:
                    pass
            self.ollama_pull_worker = None
        except Exception:
            pass
        try:
            if bool(getattr(self, "_ai_retry_after_ollama_pull", False)):
                self._ai_retry_after_ollama_pull = False
                txt = str(getattr(self, "_ai_last_user_text", "") or "").strip()
                if txt:
                    self._append_comm("Σύστημα", "Ξαναδοκιμή AI τώρα που κατέβηκε το μοντέλο…")
                    QTimer.singleShot(250, lambda: self._send_ai_message(txt))
        except Exception:
            pass

    def _on_ollama_pull_error(self, message: str):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        msg = str(message or "").strip()
        room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
        self._append_comm("Σύστημα", f"❌ Αποτυχία pull: {msg}", room=room)
        try:
            self._ai_retry_after_ollama_pull = False
        except Exception:
            pass
        try:
            w = getattr(self, "ollama_pull_worker", None)
            if w is not None:
                try:
                    w.deleteLater()
                except Exception:
                    pass
            self.ollama_pull_worker = None
        except Exception:
            pass
        low = msg.lower()
        if "manifest" in low and ("does not exist" in low or "not exist" in low or "file does not exist" in low):
            self._append_comm("Σύστημα", "Το όνομα μοντέλου δεν βρέθηκε. Έλεγξε ότι δεν έχει τελεία/αποσιωπητικά στο τέλος και δοκίμασε π.χ. llama3.1:8b-instruct ή llama3.1.", room=room)
            try:
                q = getattr(self, "_ai_pull_fallback_queue", None)
                if isinstance(q, list) and q:
                    nxt = self._sanitize_ollama_model_name(str(q.pop(0) or "").strip())
                    self._ai_pull_fallback_queue = q
                    if nxt:
                        try:
                            self.comm_llm_model = nxt
                        except Exception:
                            pass
                        try:
                            if hasattr(self, "comm_llm_model_edit") and self.comm_llm_model_edit is not None:
                                self.comm_llm_model_edit.setText(nxt)
                        except Exception:
                            pass
                        self._ai_retry_after_ollama_pull = True
                        self._append_comm("Σύστημα", f"Δοκιμή εναλλακτικού μοντέλου: Pull {nxt}…", room=room)
                        QTimer.singleShot(500, self._start_ollama_pull)
                        return
            except Exception:
                pass

    def _embedded_ollama_dir(self) -> str:
        try:
            return str(Path("data") / "ollama")
        except Exception:
            return os.path.join("data", "ollama")

    def _embedded_whispercpp_dir(self) -> str:
        try:
            return str(Path("data") / "voice" / "whispercpp")
        except Exception:
            return os.path.join("data", "voice", "whispercpp")

    def _embedded_piper_dir(self) -> str:
        try:
            return str(Path("data") / "voice" / "piper")
        except Exception:
            return os.path.join("data", "voice", "piper")

    def _find_ollama_cli(self) -> str:
        try:
            emb = self._embedded_ollama_dir()
            for cand in [
                os.path.join(emb, "ollama.exe"),
                os.path.join(emb, "bin", "ollama.exe"),
            ]:
                if os.path.exists(cand):
                    return cand
            try:
                for root, dirs, files in os.walk(emb):
                    if "ollama.exe" in files:
                        return os.path.join(root, "ollama.exe")
            except Exception:
                pass
        except Exception:
            pass
        if os.name == "nt":
            candidates = []
            try:
                local = str(os.environ.get("LOCALAPPDATA") or "")
                if local:
                    candidates.append(os.path.join(local, "Programs", "Ollama", "ollama.exe"))
                    candidates.append(os.path.join(local, "Programs", "Ollama", "Ollama.exe"))
            except Exception:
                pass
            candidates.extend([
                r"C:\Program Files\Ollama\ollama.exe",
                r"C:\Program Files\Ollama\Ollama.exe",
                r"C:\Program Files (x86)\Ollama\ollama.exe",
                r"C:\Program Files (x86)\Ollama\Ollama.exe",
            ])
            for p in candidates:
                try:
                    if p and os.path.exists(p):
                        return p
                except Exception:
                    continue
        try:
            cli = shutil.which("ollama")
            if cli:
                return cli
        except Exception:
            pass
        return ""

    def _install_embedded_ollama(self):
        try:
            url = "https://github.com/ollama/ollama/releases/latest/download/ollama-windows-amd64.zip"
            install_dir = self._embedded_ollama_dir()
            os.makedirs(install_dir, exist_ok=True)
            self._append_comm("Σύστημα", "Κατέβασμα φορητού Ollama (μπορεί να είναι μεγάλο)…")
            self.layout_save_label.setText("Κατέβασμα Ollama…")
            self.ollama_install_worker = OllamaPortableInstallWorker(url, install_dir, parent=self)
            self.ollama_install_worker.progress.connect(self._on_ollama_install_progress)
            self.ollama_install_worker.finished.connect(self._on_ollama_install_done)
            self.ollama_install_worker.error.connect(self._on_ollama_install_error)
            self.ollama_install_worker.start()
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία εγκατάστασης Ollama: {e}")

    def _on_ollama_install_progress(self, pct: int, status: str):
        try:
            s = str(status or "").strip()
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                if s:
                    self.layout_save_label.setText(s)
                else:
                    self.layout_save_label.setText(f"Κατέβασμα Ollama… {int(pct)}%")
        except Exception:
            pass

    def _on_ollama_install_done(self, install_dir: str, elapsed_ms: float):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        self._append_comm("Σύστημα", f"✅ Έτοιμο το φορητό Ollama ({elapsed_ms:.0f}ms). Πάτα «Εκκίνηση» για να ξεκινήσει και μετά «Έλεγχος».")

    def _on_ollama_install_error(self, message: str):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        self._append_comm("Σύστημα", f"❌ Αποτυχία κατεβάσματος/εξαγωγής Ollama: {message}")

    def _install_embedded_whispercpp(self):
        try:
            w = getattr(self, "whisper_install_worker", None)
            if w is not None and hasattr(w, "isRunning") and w.isRunning():
                self._append_comm("Σύστημα", "Whisper.cpp: υπάρχει ήδη εγκατάσταση σε εξέλιξη.")
                return
            install_dir = self._embedded_whispercpp_dir()
            os.makedirs(install_dir, exist_ok=True)
            self._append_comm("Σύστημα", "Whisper.cpp: κατέβασμα/εγκατάσταση (exe + model, προτίμηση GPU build)…")
            try:
                if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                    self.layout_save_label.setText("Whisper.cpp: εγκατάσταση…")
            except Exception:
                pass
            self.whisper_install_worker = WhisperCppPortableInstallWorker(install_dir, parent=self)
            self.whisper_install_worker.progress.connect(self._on_whisper_install_progress)
            self.whisper_install_worker.finished.connect(self._on_whisper_install_done)
            self.whisper_install_worker.error.connect(self._on_whisper_install_error)
            self.whisper_install_worker.start()
        except Exception as e:
            self._append_comm("Σύστημα", f"Whisper.cpp: αποτυχία εγκατάστασης: {e}")

    def _on_whisper_install_progress(self, pct: int, status: str):
        try:
            s = str(status or "").strip()
            if s:
                self._append_comm("Σύστημα", s)
            try:
                if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                    self.layout_save_label.setText(s if s else f"Whisper.cpp… {int(pct)}%")
            except Exception:
                pass
        except Exception:
            pass

    def _on_whisper_install_done(self, exe_path: str, model_path: str, elapsed_ms: float):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        try:
            self.comm_stt_backend = "whispercpp"
            self.comm_whispercpp_cli = str(exe_path or "").strip()
            self.comm_whispercpp_model = str(model_path or "").strip()
            try:
                if hasattr(self, "comm_stt_backend_combo"):
                    idx = self.comm_stt_backend_combo.findData("whispercpp")
                    if idx >= 0:
                        self.comm_stt_backend_combo.setCurrentIndex(idx)
            except Exception:
                pass
            try:
                if hasattr(self, "comm_whisper_cli_edit"):
                    self.comm_whisper_cli_edit.setText(self.comm_whispercpp_cli)
                if hasattr(self, "comm_whisper_model_edit"):
                    self.comm_whisper_model_edit.setText(self.comm_whispercpp_model)
            except Exception:
                pass
            self._update_voice_backend_ui()
            self._save_viewer_prefs()
        except Exception:
            pass
        self._append_comm("Σύστημα", f"✅ Whisper.cpp έτοιμο ({elapsed_ms:.0f}ms).")
        try:
            if bool(getattr(self, "_stt_retry_after_whisper_install", False)) and bool(getattr(self, "_last_voice_wav", b"")):
                self._stt_retry_after_whisper_install = False
                QTimer.singleShot(0, self._transcribe_last_voice)
        except Exception:
            pass

    def _on_whisper_install_error(self, message: str):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        self._append_comm("Σύστημα", f"❌ Whisper.cpp: αποτυχία εγκατάστασης: {message}")
        try:
            self._stt_retry_after_whisper_install = False
        except Exception:
            pass

    def _install_embedded_piper(self):
        try:
            w = getattr(self, "piper_install_worker", None)
            if w is not None and hasattr(w, "isRunning") and w.isRunning():
                self._append_comm("Σύστημα", "Piper: υπάρχει ήδη εγκατάσταση σε εξέλιξη.")
                return
            install_dir = self._embedded_piper_dir()
            os.makedirs(install_dir, exist_ok=True)
            self._append_comm("Σύστημα", "Piper: κατέβασμα/εγκατάσταση (exe + ελληνική φωνή)…")
            try:
                if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                    self.layout_save_label.setText("Piper: εγκατάσταση…")
            except Exception:
                pass
            self.piper_install_worker = PiperPortableInstallWorker(install_dir, parent=self)
            self.piper_install_worker.progress.connect(self._on_piper_install_progress)
            self.piper_install_worker.finished.connect(self._on_piper_install_done)
            self.piper_install_worker.error.connect(self._on_piper_install_error)
            self.piper_install_worker.start()
        except Exception as e:
            self._append_comm("Σύστημα", f"Piper: αποτυχία εγκατάστασης: {e}")

    def _on_piper_install_progress(self, pct: int, status: str):
        try:
            s = str(status or "").strip()
            if s:
                self._append_comm("Σύστημα", s)
            try:
                if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                    self.layout_save_label.setText(s if s else f"Piper… {int(pct)}%")
            except Exception:
                pass
        except Exception:
            pass

    def _on_piper_install_done(self, exe_path: str, voice_onnx_path: str, elapsed_ms: float):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        try:
            self.comm_tts_backend = "piper"
            self.comm_piper_cli = str(exe_path or "").strip()
            self.comm_piper_voice_model = str(voice_onnx_path or "").strip()
            try:
                if hasattr(self, "comm_tts_backend_combo"):
                    idx = self.comm_tts_backend_combo.findData("piper")
                    if idx >= 0:
                        self.comm_tts_backend_combo.setCurrentIndex(idx)
            except Exception:
                pass
            try:
                if hasattr(self, "comm_piper_cli_edit"):
                    self.comm_piper_cli_edit.setText(self.comm_piper_cli)
                if hasattr(self, "comm_piper_voice_edit"):
                    self.comm_piper_voice_edit.setText(self.comm_piper_voice_model)
            except Exception:
                pass
            self._update_voice_backend_ui()
            self._save_viewer_prefs()
        except Exception:
            pass
        self._append_comm("Σύστημα", f"✅ Piper έτοιμο ({elapsed_ms:.0f}ms).")
        try:
            self.comm_tts_enabled = True
        except Exception:
            pass
        try:
            pending = str(getattr(self, "_tts_pending_text", "") or "").strip()
            self._tts_pending_text = ""
            if pending:
                QTimer.singleShot(0, lambda: self._speak_text(pending))
        except Exception:
            pass

    def _on_piper_install_error(self, message: str):
        try:
            if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                self.layout_save_label.setText("")
        except Exception:
            pass
        self._append_comm("Σύστημα", f"❌ Piper: αποτυχία εγκατάστασης: {message}")
        try:
            self._tts_pending_text = ""
        except Exception:
            pass

    def _start_ollama_and_check(self):
        try:
            try:
                if hasattr(self, "comm_llm_url_edit") and not str(self.comm_llm_url_edit.text() or "").strip():
                    self.comm_llm_url_edit.setText("http://localhost:11434/api/chat")
            except Exception:
                pass

            launched = False
            cli = self._find_ollama_cli()

            def _popen(cmd_list):
                if os.name == "nt":
                    try:
                        flags = int(getattr(subprocess, "CREATE_NO_WINDOW", 0) or 0)
                        return subprocess.Popen(cmd_list, startupinfo=subprocess.STARTUPINFO(), creationflags=flags)
                    except Exception:
                        return subprocess.Popen(cmd_list)
                return subprocess.Popen(cmd_list)

            if cli:
                try:
                    _popen([cli, "serve"])
                    launched = True
                except Exception:
                    launched = False
            if not launched and os.name == "nt":
                candidates = []
                try:
                    local = str(os.environ.get("LOCALAPPDATA") or "")
                    if local:
                        candidates.append(os.path.join(local, "Programs", "Ollama", "Ollama.exe"))
                except Exception:
                    pass
                candidates.extend([
                    r"C:\Program Files\Ollama\Ollama.exe",
                    r"C:\Program Files (x86)\Ollama\Ollama.exe",
                ])
                for p in candidates:
                    try:
                        if p and os.path.exists(p):
                            _popen([p])
                            launched = True
                            break
                    except Exception:
                        continue

            if launched:
                self._append_comm("Σύστημα", "Προσπάθεια εκκίνησης Ollama…")
                try:
                    self._ollama_starting = True
                    self._ollama_start_attempts = 0
                    self._ollama_start_deadline_ts = time.time() + 45.0
                except Exception:
                    pass
                QTimer.singleShot(1000, self._check_ollama_connection)
                return

            mb = QMessageBox(self)
            mb.setWindowTitle("Ollama")
            mb.setText("Δεν βρέθηκε Ollama στο σύστημα.\nΘες να το ενσωματώσω (φορητή έκδοση zip) μέσα στο πρόγραμμα;")
            btn_zip = mb.addButton("Ενσωμάτωση (zip)", QMessageBox.ButtonRole.AcceptRole)
            btn_inst = mb.addButton("Installer", QMessageBox.ButtonRole.ActionRole)
            mb.addButton("Άκυρο", QMessageBox.ButtonRole.RejectRole)
            mb.exec()
            clicked = mb.clickedButton()
            if clicked == btn_zip:
                self._install_embedded_ollama()
                return
            if clicked == btn_inst:
                self._show_ollama_help()
                return
        except Exception:
            pass

    def _normalize_ai_url(self, url: str) -> str:
        u = str(url or "").strip()
        if not u:
            return ""
        if not re.match(r"^https?://", u, flags=re.IGNORECASE):
            u = "http://" + u
        if u.endswith("/api"):
            u = u + "/chat"
        if u.endswith("/api/"):
            u = u + "chat"
        if "/api/chat" not in u and u.rstrip("/").endswith(":11434"):
            u = u.rstrip("/") + "/api/chat"
        return u

    def _sanitize_ollama_model_name(self, s: str) -> str:
        v = str(s or "").strip()
        if not v:
            return ""
        v = v.replace("\u201c", '"').replace("\u201d", '"').replace("\u2018", "'").replace("\u2019", "'")
        if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
            v = v[1:-1].strip()
        v = v.replace("\u2026", "...").strip()
        v = re.sub(r"\s+", " ", v).strip()
        v = re.sub(r"[.。…,:;]+$", "", v).strip()
        return v

    def _short_ollama_error_detail(self, message: str, max_len: int = 42) -> str:
        s = str(message or "").strip()
        if not s:
            return "error"
        low = s.lower()
        if "winerror" in low:
            m = re.search(r"winerror\s*(\d+)", s, flags=re.IGNORECASE)
            if m:
                s = f"WinError {m.group(1)}"
        elif "http error" in low:
            m = re.search(r"http error\s*(\d+)", s, flags=re.IGNORECASE)
            if m:
                s = f"HTTP {m.group(1)}"
        elif "timed out" in low or "timeout" in low:
            s = "timeout"
        elif "connection refused" in low or "refused" in low:
            s = "connection refused"
        else:
            try:
                s = re.sub(r"\s+", " ", s).strip()
            except Exception:
                s = str(message or "").strip()
        try:
            s = s.replace("urllib.error.", "").replace("URLError:", "").strip()
        except Exception:
            pass
        if len(s) > int(max_len):
            s = s[: int(max_len) - 1].rstrip() + "…"
        return s or "error"

    def _normalize_phrase_key(self, text: str) -> str:
        s = str(text or "").strip().lower()
        if not s:
            return ""
        try:
            s = unicodedata.normalize("NFD", s)
            s = "".join(ch for ch in s if not unicodedata.combining(ch))
            s = unicodedata.normalize("NFC", s)
        except Exception:
            pass
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def _set_ollama_status(self, kind: str, detail: str):
        k = str(kind or "").strip().lower()
        d = str(detail or "").strip()
        lbl = getattr(self, "ollama_status_label", None)
        if lbl is None:
            return
        try:
            if k == "ok":
                lbl.setText(("OK" + (f" · {d}" if d else "")))
                lbl.setStyleSheet("color:#1b5e20;")
                return
            if k == "slow":
                lbl.setText(("Slow" + (f" · {d}" if d else "")))
                lbl.setStyleSheet("color:#8a6d3b;")
                return
            if k == "down":
                lbl.setText(("Down" + (f" · {d}" if d else "")))
                lbl.setStyleSheet("color:#a94442;")
                return
            if k == "checking":
                lbl.setText("Checking…")
                lbl.setStyleSheet("color:#31708f;")
                return
            lbl.setText("—")
            lbl.setStyleSheet("color:#666;")
        except RuntimeError:
            try:
                self.ollama_status_label = None
            except Exception:
                pass
            try:
                t = getattr(self, "_ollama_status_timer", None)
                if t is not None:
                    t.stop()
            except Exception:
                pass
            try:
                w = getattr(self, "_ollama_status_worker", None)
                if w is not None and hasattr(w, "requestInterruption"):
                    w.requestInterruption()
            except Exception:
                pass
            return

    def _on_ollama_status_worker_result(self, _models, ms):
        try:
            self._set_ollama_status("ok" if float(ms) <= 2500.0 else "slow", f"{float(ms):.0f}ms")
        except Exception:
            pass

    def _on_ollama_status_worker_error(self, msg):
        try:
            low = str(msg).lower()
        except Exception:
            low = ""
        try:
            self._set_ollama_status("down", "timeout" if "timeout" in low else self._short_ollama_error_detail(msg))
        except Exception:
            pass

    def _start_ollama_status_timer(self):
        try:
            if getattr(self, "_ollama_status_timer", None) is None:
                self._ollama_status_timer = QTimer(self)
                self._ollama_status_timer.setInterval(12000)
                self._ollama_status_timer.timeout.connect(self._silent_check_ollama_status)
            self._ollama_status_timer.start()
            QTimer.singleShot(400, self._silent_check_ollama_status)
        except Exception:
            pass

    def _silent_check_ollama_status(self):
        try:
            url = str(getattr(self, "comm_llm_url", "") or "").strip()
            try:
                if hasattr(self, "comm_llm_url_edit") and self.comm_llm_url_edit is not None:
                    url = str(self.comm_llm_url_edit.text() or "").strip() or url
            except Exception:
                pass
            url = self._normalize_ai_url(url)
            low = url.lower()
            is_ollama = (":11434" in low) or ("localhost:11434" in low) or ("127.0.0.1:11434" in low) or ("/api/chat" in low) or ("/api/tags" in low)
            if not is_ollama:
                self._set_ollama_status("unknown", "")
                return
            try:
                dead_until = float(getattr(self, "_ollama_dead_until", 0.0) or 0.0)
            except Exception:
                dead_until = 0.0
            if dead_until and time.time() < dead_until:
                wait_s = int(max(1.0, dead_until - time.time()))
                self._set_ollama_status("down", f"backoff {wait_s}s")
                return
            prev = getattr(self, "_ollama_status_worker", None)
            if prev is not None and hasattr(prev, "isRunning") and prev.isRunning():
                return
            self._ollama_status_worker = OllamaTagsWorker(url, timeout_ms=1200, parent=self)
            self._ollama_status_worker.result.connect(self._on_ollama_status_worker_result)
            self._ollama_status_worker.error.connect(self._on_ollama_status_worker_error)
            self._ollama_status_worker.start()
        except Exception:
            pass

    def _check_ollama_connection(self):
        try:
            try:
                self._set_ollama_status("checking", "")
            except Exception:
                pass
            url = ""
            try:
                url = str(self.comm_llm_url_edit.text() or "")
            except Exception:
                url = str(getattr(self, "comm_llm_url", "") or "")
            url = self._normalize_ai_url(url)
            if hasattr(self, "comm_llm_url_edit"):
                self.comm_llm_url_edit.setText(url)
            if not url:
                self._append_comm("Σύστημα", "Δεν έχει οριστεί AI URL.")
                return
            self._append_comm("Σύστημα", "Έλεγχος Ollama…")
            try:
                prev = getattr(self, "ollama_tags_worker", None)
                if prev is not None and hasattr(prev, "isRunning") and prev.isRunning():
                    try:
                        prev.requestInterruption()
                    except Exception:
                        pass
                    try:
                        prev.wait(300)
                    except Exception:
                        pass
            except Exception:
                pass

            timeout_ms = 2000
            try:
                if bool(getattr(self, "_ollama_starting", False)):
                    timeout_ms = 8000
            except Exception:
                timeout_ms = 2000
            self.ollama_tags_worker = OllamaTagsWorker(url, timeout_ms=int(timeout_ms), parent=self)
            self.ollama_tags_worker.result.connect(self._on_ollama_tags_ok)
            self.ollama_tags_worker.error.connect(self._on_ollama_tags_err)
            self.ollama_tags_worker.start()
        except Exception:
            pass

    def _on_ollama_tags_ok(self, models: list, elapsed_ms: float):
        try:
            self._ollama_starting = False
        except Exception:
            pass
        try:
            try:
                self._ollama_dead_until = 0.0
                self._ollama_timeout_count = 0
            except Exception:
                pass
            names = [str(x) for x in (models or []) if str(x).strip()]
            if names:
                disp = ", ".join(names[:8]) + (" …" if len(names) > 8 else "")
                self._append_comm("Σύστημα", f"✅ Ollama διαθέσιμο ({elapsed_ms:.0f}ms). Models: {disp}")
                try:
                    self._set_ollama_status("ok" if float(elapsed_ms) <= 2500.0 else "slow", f"{elapsed_ms:.0f}ms")
                except Exception:
                    pass
                try:
                    cur = str(self.comm_llm_model_edit.text() or "").strip()
                    want = ""
                    preferred = ["llama3.2:3b", "qwen2.5:1.5b", "phi3:mini", "llama3.2:1b", "llama3.1:latest"]
                    available_pref = [p for p in preferred if p in names]
                    if available_pref:
                        want = available_pref[0]
                    elif not cur:
                        want = names[0]
                    if not want and cur and cur not in names and names:
                        want = names[0]
                    if want:
                        self.comm_llm_model_edit.setText(want)
                        try:
                            self.comm_llm_model = str(want)
                        except Exception:
                            pass
                except Exception:
                    pass
            else:
                self._append_comm("Σύστημα", f"✅ Ollama διαθέσιμο ({elapsed_ms:.0f}ms), αλλά δεν βρέθηκαν models. Κάνε pull ένα μοντέλο (π.χ. llama3.1:8b-instruct).")
                try:
                    self._set_ollama_status("ok" if float(elapsed_ms) <= 2500.0 else "slow", "χωρίς models")
                except Exception:
                    pass
                try:
                    if bool(getattr(self, "comm_voice_chat_enabled", False)) and not bool(getattr(self, "_voice_chat_autopull_tried", False)):
                        self._voice_chat_autopull_tried = True
                        try:
                            self.comm_llm_model_edit.setText("llama3.1:8b-instruct")
                        except Exception:
                            pass
                        self._append_comm("Σύστημα", "Voice chat: ξεκινά αυτόματο Pull μοντέλου (μπορεί να είναι μεγάλο download)…")
                        QTimer.singleShot(0, self._start_ollama_pull)
                except Exception:
                    pass
        except Exception:
            pass

    def _on_ollama_tags_err(self, message: str):
        try:
            msg = str(message or "")
            is_refused = ("WinError 10061" in msg or "Connection refused" in msg or "refused" in msg.lower())
            is_timeout = ("timed out" in msg.lower() or "timeout" in msg.lower())
            try:
                if bool(getattr(self, "_ollama_starting", False)) and (is_refused or is_timeout):
                    self._ollama_start_attempts = int(getattr(self, "_ollama_start_attempts", 0) or 0) + 1
                    deadline = float(getattr(self, "_ollama_start_deadline_ts", 0.0) or 0.0)
                    if deadline <= 0.0:
                        deadline = time.time() + 30.0
                        self._ollama_start_deadline_ts = deadline
                    if time.time() < deadline:
                        if self._ollama_start_attempts == 1:
                            self._append_comm("Σύστημα", "Αναμονή εκκίνησης Ollama… μπορεί να πάρει 10–30s στην πρώτη φορά.")
                        QTimer.singleShot(1500, self._check_ollama_connection)
                        return
                    self._ollama_starting = False
            except Exception:
                pass
            if is_refused:
                self._append_comm("Σύστημα", "❌ Δεν απαντά το Ollama στο 11434. Άνοιξε/εκκίνησε το Ollama και ξαναπάτα «Έλεγχος».")
                try:
                    self._set_ollama_status("down", "connection refused")
                except Exception:
                    pass
            elif is_timeout:
                self._append_comm("Σύστημα", "❌ Timeout στο Ollama. Έλεγξε ότι τρέχει και ότι το firewall δεν μπλοκάρει το localhost:11434.")
                try:
                    self._set_ollama_status("down", "timeout")
                except Exception:
                    pass
            else:
                self._append_comm("Σύστημα", f"❌ Αποτυχία ελέγχου Ollama: {msg}")
                try:
                    self._set_ollama_status("down", self._short_ollama_error_detail(msg))
                except Exception:
                    pass
        except Exception:
            pass

    def _default_aliases(self):
        return {
            "contrast": "/set contrast 125",
            "καλύτερη αντίθεση": "/set contrast 125",
            "καλυτερη αντιθεση": "/set contrast 125",
            "περισσότερη αντίθεση": "/set contrast 135",
            "περισσοτερη αντιθεση": "/set contrast 135",
            "λιγότερη αντίθεση": "/set contrast 90",
            "λιγοτερη αντιθεση": "/set contrast 90",
            "πιο φωτεινά": "/set brightness 15",
            "πιο φωτεινα": "/set brightness 15",
            "φωτεινα": "/set brightness 15",
            "brightness": "/set brightness 15",
            "πιο σκοτεινά": "/set brightness -15",
            "πιο σκοτεινα": "/set brightness -15",
            "σκοτεινα": "/set brightness -15",
            "μηδέν φωτισμός": "/set brightness 0",
            "μηδεν φωτισμος": "/set brightness 0",
            "κρυψε πλαισια": "πλαίσια",
            "κρύψε πλαίσια": "πλαίσια",
            "κρυψε πλαισια/κουτια": "πλαίσια",
            "δειξε πλαισια": "πλαίσια",
            "δείξε πλαίσια": "πλαίσια",
            "πλαισια": "πλαίσια",
            "boxes": "πλαίσια",
            "κανε αναλυση": "ανάλυση",
            "κάνε ανάλυση": "ανάλυση",
            "αναλυση": "ανάλυση",
            "ξεκινα αναλυση": "ανάλυση",
            "ξεκίνα ανάλυση": "ανάλυση",
            "επομενη": "επόμενη",
            "next": "επόμενη",
            "προηγουμενη": "προηγούμενη",
            "prev": "προηγούμενη",
            "κεντραρε": "κεντράρισμα",
            "κεντραρισμα": "κεντράρισμα",
            "center": "κεντράρισμα",
            "ενεργοποιησε πλεγμα": "πλέγμα",
            "ενεργοποίησε πλέγμα": "πλέγμα",
            "πλεγμα": "πλέγμα",
            "grid": "πλέγμα",
            "απενεργοποιησε πλεγμα": "πλέγμα",
            "απενεργοποίησε πλέγμα": "πλέγμα",
            "προτεινε": "/suggest",
            "πρότεινε": "/suggest",
            "suggest": "/suggest",
            "βοηθεια": "/help",
            "help": "/help",
            "templates": "/templates",
            "προτυπα": "/templates",
            "πρότυπα": "/templates",
            "λιστα προτυπων": "/templates",
            "άνοιξε πανοραμική": "/open pano",
            "ανοιξε πανοραμικη": "/open pano",
            "ανοιξε πανοραμικη εικόνα": "/open pano",
            "open pano": "/open pano",
            "άνοιξε opg": "/open opg",
            "ανοιξε opg": "/open opg",
            "open opg": "/open opg",
            "άνοιξε panoramic": "/open panoramic",
            "ανοιξε panoramic": "/open panoramic",
            "open panoramic": "/open panoramic",
            "report standard": "/template standard",
            "αναφορα standard": "/template standard",
            "αναφορά standard": "/template standard",
        }

    def _install_default_aliases(self):
        try:
            defaults = self._default_aliases()
            if not isinstance(self.comm_aliases, dict):
                self.comm_aliases = {}
            added = 0
            skipped = 0
            for k, v in defaults.items():
                key = str(k or "").strip().lower()
                val = str(v or "").strip()
                if not key or not val:
                    continue
                if key in self.comm_aliases:
                    skipped += 1
                    continue
                self.comm_aliases[key] = val
                added += 1
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", f"Aliases: προστέθηκαν {added}, παραλείφθηκαν {skipped}.")
            self._session_log("command_executed", {"action": "alias_presets", "added": int(added), "skipped": int(skipped)})
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία aliases: {e}")

    def _state_summary_for_ai(self):
        try:
            training = bool(hasattr(self, "training_worker") and self.training_worker)
            analysis = bool(getattr(self, "analysis_results", None))
            return {
                "current_image_path": str(getattr(self, "current_image_path", "") or ""),
                "has_analysis": analysis,
                "boxes_visible": bool(getattr(self, "boxes_visible", True)),
                "grid_active": bool(getattr(self, "grid_active", False)),
                "auto_fdi_enabled": bool(getattr(self, "auto_fdi_enabled", True)),
                "layout_locked": bool(getattr(self, "layout_locked", False)),
                "is_cropping": bool(getattr(self, "is_cropping", False)),
                "is_calibrating": bool(getattr(self, "is_calibrating", False)),
                "model_path": str(getattr(self, "model_path", "") or ""),
                "training_running": training,
            }
        except Exception:
            return {}

    def _allowed_ai_tools(self):
        return {
            "command": {
                "description": "Εκτέλεση ασφαλούς εντολής στο viewer.",
                "allowed": [
                    "κεντράρισμα", "πλέγμα", "μαγικό", "ανάλυση", "αποκοπή", "βαθμονόμηση",
                    "επόμενη", "προηγούμενη", "πλαίσια",
                    "προσθήκη ακτινογραφίας", "επαλήθευση", "εξαγωγή", "αποθήκευση ανάλυσης", "καθαρισμός ανάλυσης", "ιστορικό",
                    "διπλότυπα",
                    "yolo", "γραμμές", "auto fdi", "κλείδωμα",
                    "/set brightness <int>", "/set contrast <int>", "/goto <int>", "/open <text>",
                    "/click <action>",
                    "/templates", "/template <name>", "/suggest", "/macro run <name>"
                ],
            }
        }

    def _is_allowed_ai_command(self, cmd: str) -> bool:
        c = str(cmd or "").strip()
        if not c:
            return False
        low = c.lower()
        if re.match(r"^/macro\s+run\s+.+$", low):
            return True
        if low in (
            "κεντράρισμα", "πλέγμα", "μαγικό", "ανάλυση", "αποκοπή", "βαθμονόμηση",
            "επόμενη", "προηγούμενη", "πλαίσια",
            "προσθήκη ακτινογραφίας", "επαλήθευση", "εξαγωγή", "αποθήκευση ανάλυσης", "καθαρισμός ανάλυσης", "ιστορικό",
            "διπλότυπα",
            "yolo", "γραμμές", "auto fdi", "κλείδωμα",
            "/suggest",
        ):
            return True
        if re.match(r"^/click\s+(add_radiograph|duplicates|analyze|verify|export|save_analysis|clear_analysis|history|toggle_boxes|center|crop|grid|magic|yolo_seg|jaw_lines|auto_fdi|lock_layout|calibration)\s*$", low):
            return True
        if re.match(r"^/set\s+(brightness|contrast)\s+-?\d+\s*$", low):
            return True
        if re.match(r"^/goto\s+\d+\s*$", low):
            return True
        if low.startswith("/open ") and len(low) <= 200 and ("<" not in low and ">" not in low):
            return True
        if low in ("/templates",) or low.startswith("/template "):
            return True
        return False

    def _send_ai_message(self, user_text: str):
        self._ai_last_user_text = str(user_text or "")
        try:
            self._ai_active_origin = str(getattr(self, "_ai_last_origin", "text") or "text")
        except Exception:
            self._ai_active_origin = "text"
        room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
        try:
            self.comm_llm_url = self._normalize_ai_url(str(getattr(self, "comm_llm_url_edit", None).text() if getattr(self, "comm_llm_url_edit", None) else self.comm_llm_url).strip())
            try:
                u = str(self.comm_llm_url or "").strip()
                if bool(getattr(self, "comm_voice_chat_enabled", False)) and (":11434" in u or "localhost:11434" in u or "127.0.0.1:11434" in u) and "/api/chat" not in u:
                    self.comm_llm_url = "http://localhost:11434/api/chat"
                    if hasattr(self, "comm_llm_url_edit") and self.comm_llm_url_edit is not None:
                        self.comm_llm_url_edit.setText(self.comm_llm_url)
                    try:
                        self._save_viewer_prefs()
                    except Exception:
                        pass
            except Exception:
                pass
            self.comm_llm_model = self._sanitize_ollama_model_name(str(getattr(self, "comm_llm_model_edit", None).text() if getattr(self, "comm_llm_model_edit", None) else self.comm_llm_model).strip())
            try:
                if hasattr(self, "comm_llm_model_edit") and self.comm_llm_model_edit is not None:
                    if str(self.comm_llm_model_edit.text() or "").strip() != str(self.comm_llm_model or ""):
                        self.comm_llm_model_edit.setText(str(self.comm_llm_model or ""))
            except Exception:
                pass
            if hasattr(self, "comm_ai_backend_combo") and self.comm_ai_backend_combo is not None:
                self.comm_ai_backend_mode = str(self.comm_ai_backend_combo.currentData() or self.comm_ai_backend_mode or "hybrid")
            if hasattr(self, "comm_cloud_base_edit") and self.comm_cloud_base_edit is not None:
                self.comm_cloud_api_base = str(self.comm_cloud_base_edit.text() or "").strip() or self.comm_cloud_api_base or "https://api.openai.com/v1"
            if hasattr(self, "comm_cloud_model_edit") and self.comm_cloud_model_edit is not None:
                self.comm_cloud_model = str(self.comm_cloud_model_edit.text() or "").strip() or self.comm_cloud_model or "gpt-4o-mini"
        except Exception:
            pass
        mode = str(getattr(self, "comm_ai_backend_mode", "hybrid") or "hybrid").strip().lower()
        try:
            if room == "voice" and bool(getattr(self, "comm_voice_force_cloud", False)):
                api_key = str(os.environ.get("OPENAI_API_KEY") or "").strip()
                if api_key:
                    mode = "cloud"
        except Exception:
            pass
        if mode not in ("hybrid", "local", "cloud"):
            mode = "local"
        if mode == "hybrid":
            mode = "local"
        if mode in ("local",) and not str(getattr(self, "comm_llm_url", "") or "").strip():
            self._append_comm("Σύστημα", "Δεν έχει οριστεί AI API URL (τοπικό).")
            return
        if mode in ("cloud",) and not str(getattr(self, "comm_cloud_model", "") or "").strip():
            self._append_comm("Σύστημα", "Δεν έχει οριστεί Cloud model.")
            return

        if not isinstance(self._ai_messages, list):
            self._ai_messages = []

        try:
            if self._ai_messages:
                last = self._ai_messages[-1]
                if isinstance(last, dict) and last.get("role") == "user" and str(last.get("content") or "") == str(user_text or ""):
                    pass
                else:
                    self._ai_messages.append({"role": "user", "content": str(user_text or "")})
            else:
                self._ai_messages.append({"role": "user", "content": str(user_text or "")})
        except Exception:
            self._ai_messages.append({"role": "user", "content": str(user_text or "")})
        self._ai_messages = self._ai_messages[-20:]
        self._schedule_prefs_save()

        tools = self._allowed_ai_tools()
        ctx = self._state_summary_for_ai()
        style_instr = ""
        conversation = bool(getattr(self, "comm_conversation_enabled", False))
        lang_instr = (
            "Απάντα ΠΑΝΤΑ και ΜΟΝΟ στα Ελληνικά. "
            "Μην χρησιμοποιείς καμία άλλη γλώσσα. "
        )
        if conversation:
            style_instr = (
                "Απάντα φυσικά σαν άνθρωπος (ελληνικά): φιλικός τόνος, σύντομες προτάσεις, "
                "1–2 διευκρινιστικές ερωτήσεις όταν λείπουν στοιχεία, "
                "και πρόταση 1 επόμενου βήματος όταν είναι χρήσιμη. "
            )
        allowed_list = ", ".join(tools["command"]["allowed"]) if isinstance(tools, dict) else ""
        try:
            has_img = bool(getattr(self, "current_image_path", None))
        except Exception:
            has_img = False
        try:
            has_analysis = bool(getattr(self, "analysis_results", None))
        except Exception:
            has_analysis = False
        try:
            teeth_cnt = 0
            if isinstance(getattr(self, "analysis_results", None), dict):
                boxes = (self.analysis_results or {}).get("boxes", []) or []
                if isinstance(boxes, list):
                    teeth_cnt = int(len(boxes))
        except Exception:
            teeth_cnt = 0
        ctx_instr = f"Πληροφορίες εφαρμογής (μην τις επαναλάβεις): εικόνα={'ναι' if has_img else 'όχι'}, ανάλυση={'ναι' if has_analysis else 'όχι'}, δόντια={teeth_cnt}. "
        fmt_instr = (
            "Επιστρέφεις ΠΑΝΤΑ ΜΟΝΟ ένα JSON object με κλειδιά: "
            "reply (string) και tool (null ή object {name:\"command\", args:{text:\"<εντολή>\"}}). "
            "Η reply είναι καθαρό ελληνικό κείμενο. "
            "Η tool επιτρέπεται μόνο αν η εντολή είναι μέσα στη λίστα επιτρεπόμενων. "
            "Επιτρεπόμενες εντολές: " + allowed_list + "."
        )
        key = self._get_patient_key()
        mem = str(getattr(self, "comm_memory_text", "") or "").strip()
        by_patient = getattr(self, "comm_patient_memory", None)
        if not isinstance(by_patient, dict):
            by_patient = {}
        pmem = str(by_patient.get(key) or "").strip() if key != "general" else ""
        mem_instr = (f"Μόνιμη μνήμη χρήστη: {mem}. " if mem else "") + (f"Μνήμη ασθενή: {pmem}. " if pmem else "")
        sys_instr = (
            lang_instr
            + str(getattr(self, "comm_llm_system_prompt", "") or "").strip()
            + " "
            + style_instr
            + mem_instr
            + ctx_instr
            + fmt_instr
        )
        try:
            if room == "voice":
                sys_instr = lang_instr + "Είσαι βοηθός. Απάντα σύντομα και καθαρά. " + fmt_instr
                tail = list((self._ai_messages or [])[-6:])
                messages = [{"role": "system", "content": sys_instr}] + tail
            else:
                messages = [{"role": "system", "content": sys_instr}] + list(self._ai_messages)
        except Exception:
            messages = [{"role": "system", "content": sys_instr}] + list(self._ai_messages)
        payload = {
            "model": str(self.comm_llm_model or ""),
            "messages": messages,
            "stream": False,
        }
        try:
            u = str(getattr(self, "comm_llm_url", "") or "").strip().lower()
            is_ollama = (":11434" in u) or ("localhost:11434" in u) or ("127.0.0.1:11434" in u) or ("/api/chat" in u)
            if is_ollama:
                base_ctx = 512 if bool(getattr(self, "comm_conversation_enabled", False)) else 256
                payload["options"] = {
                    "num_ctx": int(base_ctx),
                    "num_predict": 128,
                    "temperature": 0.2,
                    "top_p": 0.9,
                    "repeat_penalty": 1.1,
                }
                payload["format"] = "json"
            override = getattr(self, "_ollama_options_override", None)
            if isinstance(override, dict) and override:
                if "options" not in payload or not isinstance(payload.get("options"), dict):
                    payload["options"] = {}
                payload["options"].update({str(k): v for k, v in override.items() if str(k).strip()})
                self._ollama_options_override = None
        except Exception:
            pass
        self._ai_last_request_messages = messages
        self._ai_last_request_conversation = bool(conversation)
        self._ai_last_request_want_json = bool(not conversation)
        self._ai_fallback_enabled = bool(mode == "hybrid")
        self._ai_fallback_tried = False

        if mode == "cloud":
            self._append_comm("Σύστημα", "AI (cloud): επεξεργασία…", room=room)
            self._start_cloud_ai_request()
            return

        try:
            u = str(getattr(self, "comm_llm_url", "") or "").strip().lower()
            is_ollama = (":11434" in u) or ("localhost:11434" in u) or ("127.0.0.1:11434" in u) or ("/api/chat" in u)
        except Exception:
            is_ollama = False
        try:
            dead_until = float(getattr(self, "_ollama_dead_until", 0.0) or 0.0)
        except Exception:
            dead_until = 0.0
        if is_ollama and dead_until and time.time() < dead_until:
            wait_s = int(max(1.0, dead_until - time.time()))
            self._append_comm("Σύστημα", f"Τοπικό AI προσωρινά μη διαθέσιμο (αναμονή ~{wait_s}s).", room=room)
            return

        self._append_comm("Σύστημα", "AI (τοπικό): επεξεργασία…", room=room)
        self._session_log("ai_started", {"provider": "local", "url": self.comm_llm_url, "model": self.comm_llm_model, "mode": mode})
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                seq = int(getattr(self, "_ai_req_seq", 0) or 0) + 1
                self._ai_req_seq = seq
                def _still_running():
                    try:
                        if int(getattr(self, "_ai_req_seq", 0) or 0) != seq:
                            return False
                        w = getattr(self, "ai_worker", None)
                        return bool(w is not None and hasattr(w, "isRunning") and w.isRunning())
                    except Exception:
                        return False
                QTimer.singleShot(8000, lambda: self._append_comm("Σύστημα", "AI: ακόμα σε επεξεργασία…", room=room) if _still_running() else None)
                QTimer.singleShot(45000, lambda: self._append_comm("Σύστημα", "AI: καθυστερεί πολύ (πιθανό Ollama hang/crash).", room=room) if _still_running() else None)
        except Exception:
            pass
        streaming = bool(getattr(self, "comm_ai_stream_enabled", False)) and bool(getattr(self, "comm_conversation_enabled", False))
        try:
            u = str(getattr(self, "comm_llm_url", "") or "").strip().lower()
            is_ollama = (":11434" in u) or ("localhost:11434" in u) or ("127.0.0.1:11434" in u) or ("/api/chat" in u)
            if is_ollama:
                streaming = False
        except Exception:
            pass
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                streaming = False
        except Exception:
            pass
        try:
            if bool(getattr(self, "_ai_force_no_stream_once", False)):
                streaming = False
                self._ai_force_no_stream_once = False
        except Exception:
            pass
        if streaming:
            payload["stream"] = True
            try:
                u = str(getattr(self, "comm_llm_url", "") or "").strip().lower()
                is_ollama = (":11434" in u) or ("localhost:11434" in u) or ("127.0.0.1:11434" in u) or ("/api/chat" in u)
            except Exception:
                is_ollama = False
            timeout_ms = 30000 if is_ollama else 12000
            self.ai_worker = ChatLLMStreamWorker(self.comm_llm_url, payload, timeout_ms=timeout_ms)
            self.ai_worker.chunk.connect(self._on_ai_stream_chunk)
            self.ai_worker.result.connect(self._on_ai_stream_done)
            self.ai_worker.error.connect(self._on_ai_stream_error)
            self._start_ai_stream_ui()
            self.ai_worker.start()
        else:
            payload["stream"] = False
            timeout_ms = 30000 if bool(getattr(self, "comm_voice_chat_enabled", False)) else (30000 if bool(getattr(self, "comm_conversation_enabled", False)) else 15000)
            self.ai_worker = ChatLLMWorker(self.comm_llm_url, payload, timeout_ms=timeout_ms)
            self.ai_worker.result.connect(self._on_ai_result)
            self.ai_worker.error.connect(self._on_ai_error)
            self.ai_worker.start()

    def _start_cloud_ai_request(self):
        try:
            messages = getattr(self, "_ai_last_request_messages", None)
            if not isinstance(messages, list) or not messages:
                raise ValueError("Λείπει context μηνυμάτων.")
            api_base = str(getattr(self, "comm_cloud_api_base", "") or "").strip() or "https://api.openai.com/v1"
            u = urllib.parse.urlparse(api_base)
            scheme = str(u.scheme or "").strip().lower()
            host = str(u.hostname or "").strip().lower()
            if scheme != "https" and host not in ("localhost", "127.0.0.1"):
                raise ValueError("Μη ασφαλές Cloud Base URL (απαιτείται https).")
            model = str(getattr(self, "comm_cloud_model", "") or "").strip() or "gpt-4o-mini"
            want_json = bool(getattr(self, "_ai_last_request_want_json", False))
            timeout_ms = 15000 if bool(getattr(self, "_ai_last_request_conversation", False)) else 12000
            self._session_log("ai_started", {"provider": "cloud", "api_base": api_base, "model": model})
            self.ai_worker = OpenAIChatWorker(api_base, model, messages, want_json=want_json, timeout_ms=timeout_ms)
            self.ai_worker.result.connect(self._on_ai_result)
            self.ai_worker.error.connect(self._on_ai_cloud_error)
            self.ai_worker.start()
        except Exception as e:
            self._on_ai_cloud_error(str(e))

    def _on_ai_result(self, reply: str, tool, elapsed_ms: float):
        try:
            try:
                self._ollama_dead_until = 0.0
                self._ollama_timeout_count = 0
            except Exception:
                pass
            text_out = reply
            # If reply is a JSON string, attempt to parse to extract fields
            try:
                if isinstance(text_out, str) and text_out.strip().startswith("{"):
                    obj = json.loads(text_out)
                    if isinstance(obj, dict):
                        text_out = str(obj.get("reply") or text_out)
                        if not tool and obj.get("tool"):
                            tool = obj.get("tool")
            except Exception:
                pass
            try:
                t = str(text_out or "")
                is_local = str(getattr(self, "comm_ai_backend_mode", "local") or "local").strip().lower() != "cloud"
                if is_local:
                    greek_cnt = len(re.findall(r"[\u0370-\u03FF\u1F00-\u1FFF]", t))
                    foreign_cnt = len(re.findall(r"[A-Za-z\u00C0-\u024F\u4E00-\u9FFF\u3040-\u30FF\uAC00-\uD7AF]", t))
                    if greek_cnt >= 6 and foreign_cnt >= 3:
                        t2 = re.sub(r"[A-Za-z\u00C0-\u024F\u4E00-\u9FFF\u3040-\u30FF\uAC00-\uD7AF]+", " ", t)
                        t2 = re.sub(r"\s+", " ", t2).strip()
                        greek2 = len(re.findall(r"[\u0370-\u03FF\u1F00-\u1FFF]", t2))
                        if greek2 >= 6 and len(t2) >= 8:
                            text_out = t2
            except Exception:
                pass

            stream_already_written = bool(getattr(self, "_ai_stream_chat_completed", False))
            self._ai_stream_chat_completed = False
            if text_out:
                if not stream_already_written:
                    room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
                    self._append_comm("AI", text_out, room=room)
                else:
                    try:
                        self._session_log("chat", {"role": "AI", "text": str(text_out)})
                    except Exception:
                        pass
                    try:
                        self._maybe_speak_comm("AI", text_out)
                    except Exception:
                        pass
                if not isinstance(self._ai_messages, list):
                    self._ai_messages = []
                self._ai_messages.append({"role": "assistant", "content": str(text_out)})
                self._ai_messages = self._ai_messages[-20:]
                self._schedule_prefs_save()
            elif not tool:
                try:
                    room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
                    self._append_comm("Σύστημα", "AI: κενή απάντηση.", room=room)
                except Exception:
                    pass
            self._session_log("ai_finished", {"elapsed_ms": float(elapsed_ms)})

            cmd = None
            if isinstance(tool, dict):
                if tool.get("name") == "command" and isinstance(tool.get("args"), dict):
                    cmd = tool.get("args", {}).get("text")
                else:
                    cmd = tool.get("text") or tool.get("command")
            elif isinstance(tool, str):
                cmd = tool

            if cmd and self._is_allowed_ai_command(cmd):
                if bool(getattr(self, "comm_ai_auto_execute", False)):
                    self._append_comm("Σύστημα", f"AI→Εντολή: {cmd}")
                    self._session_log("ai_tool_call", {"command": str(cmd), "auto_executed": True})
                    self._handle_text_command(str(cmd))
                    self._maybe_queue_learn_alias(str(getattr(self, "_ai_last_user_text", "") or ""), str(cmd))
                else:
                    self._ai_pending_command = str(cmd)
                    self._ai_pending_origin_phrase = str(getattr(self, "_ai_last_user_text", "") or "")
                    self._append_comm("Σύστημα", f"AI πρότεινε εντολή: {cmd}")
                    self._update_ai_pending_ui()
                    self._session_log("ai_tool_call", {"command": str(cmd), "auto_executed": False})
            elif cmd:
                self._append_comm("Σύστημα", "AI πρότεινε μη-επιτρεπτή εντολή και αγνοήθηκε.")
                self._session_log("ai_tool_blocked", {"command": str(cmd)})
            try:
                self._maybe_schedule_voice_chat_resume(650)
            except Exception:
                pass
        except Exception as e:
            self._append_comm("Σύστημα", f"Σφάλμα AI: {e}")
        try:
            self._ai_active_origin = "text"
        except Exception:
            pass

    def _on_ai_error(self, message: str):
        msg = str(message or "")
        room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
        try:
            low = msg.lower()
            wants_pull = ("model" in low and ("not found" in low or "pull" in low or "manifest" in low)) or ("pull" in low and "ollama" in low)
            if wants_pull:
                model = ""
                try:
                    m = re.search(r'model\s+"?([a-z0-9_.:-]+)"?\s+(?:not\s+found|does\s+not\s+exist)', low, flags=re.IGNORECASE)
                    if m:
                        model = str(m.group(1) or "").strip()
                except Exception:
                    model = ""
                if not model:
                    try:
                        m2 = re.search(r'pull\s+([a-z0-9_.:-]+)', low, flags=re.IGNORECASE)
                        if m2:
                            model = str(m2.group(1) or "").strip()
                    except Exception:
                        model = ""
                if not model:
                    try:
                        model = str(getattr(self, "comm_llm_model", "") or "").strip()
                    except Exception:
                        model = ""
                model = self._sanitize_ollama_model_name(model) or "llama3.1:8b-instruct"
                try:
                    if model.endswith("-instruct"):
                        model = self._sanitize_ollama_model_name(model[:-len("-instruct")])
                except Exception:
                    pass
                try:
                    if model.startswith("llama3.2:") and model.endswith("b-instruct"):
                        model = self._sanitize_ollama_model_name(model.replace("-instruct", ""))
                except Exception:
                    pass
                try:
                    if model.startswith("llama3.2:"):
                        cands = ["llama3.2:3b", "llama3.2:1b", "llama3.2:latest", "llama3.1:latest"]
                    elif model.startswith("llama3.1:"):
                        cands = ["llama3.1:latest", "llama3.1:8b-instruct", "llama3.2:1b", "llama3.2:latest"]
                    else:
                        cands = [model, "llama3.1:latest", "llama3.2:1b"]
                    cands = [self._sanitize_ollama_model_name(x) for x in cands]
                    cands = [x for x in cands if x]
                    if model and model not in cands:
                        cands.insert(0, model)
                    if cands:
                        model = cands[0]
                        self._ai_pull_fallback_queue = cands[1:]
                except Exception:
                    pass
                try:
                    s = getattr(self, "_ai_autopull_models", None)
                    if not isinstance(s, set):
                        s = set()
                        self._ai_autopull_models = s
                    if model not in s:
                        s.add(model)
                        try:
                            if hasattr(self, "comm_llm_model_edit") and self.comm_llm_model_edit is not None:
                                self.comm_llm_model_edit.setText(model)
                        except Exception:
                            pass
                        try:
                            self.comm_llm_model = model
                        except Exception:
                            pass
                        self._ai_retry_after_ollama_pull = True
                        self._append_comm("Σύστημα", f"Auto-Pull μοντέλου: {model}…", room=room)
                        QTimer.singleShot(0, self._start_ollama_pull)
                        self._session_log("ai_autopull", {"model": model, "message": msg})
                        return
                except Exception:
                    pass
        except Exception:
            pass

        try:
            low = msg.lower()
            is_runner_crash = ("llama runner process has terminated" in low or "runner process has terminated" in low or "exit status 2" in low)
            if is_runner_crash:
                try:
                    cur_model = self._sanitize_ollama_model_name(str(getattr(self, "comm_llm_model", "") or "").strip())
                    tried = getattr(self, "_ai_cpu_fallback_tried_models", None)
                    if not isinstance(tried, set):
                        tried = set()
                        self._ai_cpu_fallback_tried_models = tried
                    if cur_model and cur_model not in tried:
                        tried.add(cur_model)
                        self._ai_retry_after_ollama_pull = False
                        self._ai_force_no_stream_once = True
                        self._ollama_options_override = {"num_gpu": 0, "num_ctx": 512, "num_predict": 96, "temperature": 0.2}
                        self._append_comm("Σύστημα", "Fallback: CPU-only retry στο ίδιο μοντέλο…", room=room)
                        txt = str(getattr(self, "_ai_last_user_text", "") or "").strip()
                        if txt:
                            QTimer.singleShot(400, lambda: self._send_ai_message(txt))
                            return
                except Exception:
                    pass
                candidates = ["phi3:mini", "qwen2.5:1.5b", "llama3.2:1b", "llama3.2:3b"]
                model = ""
                try:
                    q = [self._sanitize_ollama_model_name(x) for x in candidates if self._sanitize_ollama_model_name(x)]
                    self._ai_pull_fallback_queue = q[1:]
                    model = q[0] if q else "llama3.1:8b-instruct"
                except Exception:
                    model = "llama3.1:8b-instruct"
                try:
                    s = getattr(self, "_ai_autopull_models", None)
                    if not isinstance(s, set):
                        s = set()
                        self._ai_autopull_models = s
                    if model not in s:
                        s.add(model)
                        try:
                            if hasattr(self, "comm_llm_model_edit") and self.comm_llm_model_edit is not None:
                                self.comm_llm_model_edit.setText(model)
                        except Exception:
                            pass
                        try:
                            self.comm_llm_model = model
                        except Exception:
                            pass
                        self._ai_retry_after_ollama_pull = True
                        self._append_comm("Σύστημα", f"Ollama crash (exit 2). Αλλαγή σε πιο ελαφρύ μοντέλο και Pull: {model}…", room=room)
                        QTimer.singleShot(0, self._start_ollama_pull)
                        self._session_log("ai_autopull", {"model": model, "message": msg, "reason": "runner_exit_2"})
                        return
                except Exception:
                    pass
        except Exception:
            pass

        if bool(getattr(self, "_ai_fallback_enabled", False)) and not bool(getattr(self, "_ai_fallback_tried", False)):
            api_key = str(os.environ.get("OPENAI_API_KEY") or "").strip()
            if api_key:
                self._ai_fallback_tried = True
                self._session_log("ai_error", {"provider": "local", "message": str(message or "")})
                self._append_comm("Σύστημα", "Τοπικό AI απέτυχε · fallback σε cloud…", room=room)
                self._start_cloud_ai_request()
                return
            self._ai_fallback_tried = True
            try:
                if not bool(getattr(self, "_ai_no_cloud_warned", False)):
                    self._ai_no_cloud_warned = True
                    self._append_comm("Σύστημα", "Τοπικό AI απέτυχε. Δεν υπάρχει OPENAI_API_KEY για cloud fallback. Βάλε key ή άλλαξε σε «Τοπικό».", room=room)
            except Exception:
                self._append_comm("Σύστημα", "Τοπικό AI απέτυχε. Δεν υπάρχει OPENAI_API_KEY για cloud fallback. Βάλε key ή άλλαξε σε «Τοπικό».", room=room)
        low_msg = msg.lower()
        is_timeout = ("timed out" in low_msg) or ("timeout" in low_msg)
        try:
            u = str(getattr(self, "comm_llm_url", "") or "").lower()
            is_local_ollama = (":11434" in u) or ("localhost:11434" in u) or ("127.0.0.1:11434" in u) or ("/api/chat" in u)
        except Exception:
            is_local_ollama = False
        if is_timeout and is_local_ollama:
            try:
                now = time.time()
                cnt = int(getattr(self, "_ollama_timeout_count", 0) or 0) + 1
                self._ollama_timeout_count = cnt
                backoff = min(60, 8 * (2 ** min(3, max(0, cnt - 1))))
                self._ollama_dead_until = now + float(backoff)
                try:
                    self._set_ollama_status("down", f"timeout · backoff {int(backoff)}s")
                except Exception:
                    pass
            except Exception:
                pass
            try:
                last_sw = float(getattr(self, "_ollama_timeout_window_start", 0.0) or 0.0)
                now2 = time.time()
                if not last_sw or (now2 - last_sw) > 180.0:
                    self._ollama_timeout_window_start = now2
                    self._ollama_timeout_window_count = 1
                else:
                    self._ollama_timeout_window_count = int(getattr(self, "_ollama_timeout_window_count", 0) or 0) + 1
                if int(getattr(self, "_ollama_timeout_window_count", 0) or 0) >= 2:
                    cur = self._sanitize_ollama_model_name(str(getattr(self, "comm_llm_model", "") or "").strip())
                    if cur == "llama3.2:3b":
                        self.comm_llm_model = "llama3.2:1b"
                        try:
                            if hasattr(self, "comm_llm_model_edit") and self.comm_llm_model_edit is not None:
                                self.comm_llm_model_edit.setText("llama3.2:1b")
                        except Exception:
                            pass
                        try:
                            self._save_viewer_prefs()
                        except Exception:
                            self._schedule_prefs_save()
                        self._append_comm("Σύστημα", "Τοπικό AI αργεί/κολλάει. Προσωρινή αλλαγή σε llama3.2:1b για σταθερότητα.", room=room)
            except Exception:
                pass
            try:
                cur_model = self._sanitize_ollama_model_name(str(getattr(self, "comm_llm_model", "") or "").strip())
                tried = getattr(self, "_ai_cpu_timeout_tried_models", None)
                if not isinstance(tried, set):
                    tried = set()
                    self._ai_cpu_timeout_tried_models = tried
                if cur_model and cur_model not in tried:
                    tried.add(cur_model)
                    self._ai_force_no_stream_once = True
                    self._ollama_options_override = {"num_gpu": 0, "num_ctx": 512, "num_predict": 96, "temperature": 0.2}
                    self._append_comm("Σύστημα", "Fallback: CPU-only retry λόγω timeout…", room=room)
                    txt = str(getattr(self, "_ai_last_user_text", "") or "").strip()
                    if txt:
                        QTimer.singleShot(400, lambda: self._send_ai_message(txt))
                        return
            except Exception:
                pass
        if "http 500" in low_msg or "internal server error" in low_msg:
            self._append_comm("Σύστημα", f"AI σφάλμα: {msg}", room=room)
            try:
                self._check_ollama_connection()
            except Exception:
                pass
            try:
                if not bool(getattr(self, "_voice_chat_autopull_tried", False)):
                    self._voice_chat_autopull_tried = True
                    self._append_comm("Σύστημα", "Αν δεν υπάρχει μοντέλο στο Ollama, θα χρειαστεί Pull. Δοκίμασε ξανά μετά τον έλεγχο.", room=room)
            except Exception:
                pass
            self._session_log("ai_error", {"message": str(message or "")})
            return
        if "HTTP Error 404" in msg or " 404" in msg:
            fixed = ""
            try:
                cur = str(getattr(self, "comm_llm_url", "") or "").strip()
                if "/api/tags" in cur:
                    fixed = cur.replace("/api/tags", "/api/chat")
                elif (":11434" in cur or "localhost:11434" in cur) and "/api/chat" not in cur:
                    fixed = "http://localhost:11434/api/chat"
                elif not cur:
                    fixed = "http://localhost:11434/api/chat"
                if fixed:
                    self.comm_llm_url = self._normalize_ai_url(fixed)
                    try:
                        if hasattr(self, "comm_llm_url_edit") and self.comm_llm_url_edit is not None:
                            self.comm_llm_url_edit.setText(self.comm_llm_url)
                    except Exception:
                        pass
                    try:
                        self._save_viewer_prefs()
                    except Exception:
                        pass
            except Exception:
                fixed = ""
            if not fixed and bool(getattr(self, "comm_voice_chat_enabled", False)):
                fixed = "http://localhost:11434/api/chat"
                try:
                    self.comm_llm_url = self._normalize_ai_url(fixed)
                    if hasattr(self, "comm_llm_url_edit") and self.comm_llm_url_edit is not None:
                        self.comm_llm_url_edit.setText(self.comm_llm_url)
                    self._save_viewer_prefs()
                except Exception:
                    fixed = ""
            if fixed:
                self._append_comm("Σύστημα", f"AI σφάλμα: 404 (λάθος endpoint). Διορθώθηκε το AI URL σε {self.comm_llm_url}. Πάτα «Έλεγχος» και μετά «Pull» για μοντέλο.", room=room)
                try:
                    if not bool(getattr(self, "_ai_retry_after_url_fix", False)):
                        self._ai_retry_after_url_fix = True
                        txt = str(getattr(self, "_ai_last_user_text", "") or "").strip()
                        if txt:
                            self._append_comm("Σύστημα", "Ξαναδοκιμή AI μετά τη διόρθωση URL…", room=room)
                            QTimer.singleShot(400, lambda: self._send_ai_message(txt))
                except Exception:
                    pass
            else:
                self._append_comm("Σύστημα", "AI σφάλμα: 404 (λάθος endpoint). Για Ollama βάλε AI URL: http://localhost:11434/api/chat και πάτα «Έλεγχος».", room=room)
            self._session_log("ai_error", {"message": str(message or "")})
            return
        if "WinError 10061" in msg or "Connection refused" in msg or "refused" in msg.lower():
            self._append_comm("Σύστημα", f"AI σφάλμα: δεν απαντά το Ollama στο URL ({self.comm_llm_url}). Πάτα «Έλεγχος» και βεβαιώσου ότι τρέχει.", room=room)
        elif "timed out" in msg.lower() or "timeout" in msg.lower():
            self._append_comm("Σύστημα", f"AI σφάλμα: timeout στο Ollama ({self.comm_llm_url}). Έλεγξε ότι τρέχει και ότι το firewall δεν μπλοκάρει το localhost.", room=room)
            try:
                if bool(getattr(self, "comm_voice_chat_enabled", False)) and room == "voice":
                    self._ensure_voice_chat_tts_ready()
                    self._speak_text("Δεν απαντά το τοπικό AI. Έλεγξε ότι τρέχει το Ollama.")
            except Exception:
                pass
        else:
            self._append_comm("Σύστημα", f"AI σφάλμα: {msg}", room=room)
        self._session_log("ai_error", {"message": str(message or "")})

    def _on_ai_cloud_error(self, message: str):
        room = "voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None
        msg = str(message or "")
        low = msg.lower()
        try:
            if "exceeded your current quota" in low or "insufficient_quota" in low or "quota" in low:
                self._append_comm(
                    "Σύστημα",
                    "Cloud AI σφάλμα: δεν υπάρχουν διαθέσιμα credits/χρέωση (quota). "
                    "Άνοιξε Billing/Usage στο OpenAI Platform, πρόσθεσε τρόπο πληρωμής ή credits, και ξαναδοκίμασε. "
                    "Usage: https://platform.openai.com/usage · API keys: https://platform.openai.com/api-keys",
                    room=room,
                )
                self._session_log("ai_error", {"provider": "cloud", "message": str(message or ""), "kind": "quota"})
                return
        except Exception:
            pass
        if "OPENAI_API_KEY" in msg:
            self._append_comm("Σύστημα", "Cloud AI σφάλμα: λείπει OPENAI_API_KEY. Βάλ'το ως environment variable και δοκίμασε ξανά.", room=room)
        else:
            self._append_comm("Σύστημα", f"Cloud AI σφάλμα: {msg}", room=room)
        self._session_log("ai_error", {"provider": "cloud", "message": str(message or "")})

    def _start_ai_stream_ui(self):
        try:
            self._ai_stream_text = ""
            self._ai_stream_chat_active = False
            if hasattr(self, "ai_live_label"):
                self.ai_live_label.setText("AI: …")
            if hasattr(self, "ai_live_widget"):
                self.ai_live_widget.setVisible(True)
            try:
                disp = None
                if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice":
                    disp = getattr(self, "voice_chat_display", None)
                if disp is None:
                    disp = getattr(self, "comm_chat_display", None)
                if disp is not None:
                    ts = datetime.now().strftime("%H:%M:%S")
                    disp.moveCursor(QTextCursor.MoveOperation.End)
                    disp.insertPlainText(f"[{ts}] AI: ")
                    self._ai_stream_chat_active = True
            except Exception:
                self._ai_stream_chat_active = False
        except Exception:
            pass

    def _on_ai_stream_chunk(self, delta: str):
        try:
            self._ai_stream_text = str(getattr(self, "_ai_stream_text", "") or "") + str(delta or "")
            if hasattr(self, "ai_live_label"):
                txt = str(self._ai_stream_text or "").strip()
                if len(txt) > 800:
                    txt = txt[-800:]
                self.ai_live_label.setText(f"AI: {txt}")
            try:
                if bool(getattr(self, "_ai_stream_chat_active", False)):
                    disp = None
                    if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice":
                        disp = getattr(self, "voice_chat_display", None)
                    if disp is None:
                        disp = getattr(self, "comm_chat_display", None)
                    if disp is not None:
                        disp.moveCursor(QTextCursor.MoveOperation.End)
                        disp.insertPlainText(str(delta or ""))
            except Exception:
                pass
        except Exception:
            pass

    def _on_ai_stream_done(self, reply: str, tool, elapsed_ms: float):
        try:
            if hasattr(self, "ai_live_widget"):
                self.ai_live_widget.setVisible(False)
            if hasattr(self, "ai_live_label"):
                self.ai_live_label.setText("")
        except Exception:
            pass
        try:
            if bool(getattr(self, "_ai_stream_chat_active", False)):
                disp = None
                if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice":
                    disp = getattr(self, "voice_chat_display", None)
                if disp is None:
                    disp = getattr(self, "comm_chat_display", None)
                if disp is not None:
                    disp.moveCursor(QTextCursor.MoveOperation.End)
                    disp.insertPlainText("\n")
        except Exception:
            pass
        self._ai_stream_chat_completed = bool(getattr(self, "_ai_stream_chat_active", False))
        self._ai_stream_chat_active = False
        if not str(reply or "").strip():
            self._on_ai_stream_error("Κενή απάντηση από Ollama (stream).")
            return
        self._on_ai_result(reply, tool, elapsed_ms)

    def _on_ai_stream_error(self, message: str):
        try:
            if hasattr(self, "ai_live_widget"):
                self.ai_live_widget.setVisible(False)
            if hasattr(self, "ai_live_label"):
                self.ai_live_label.setText("")
        except Exception:
            pass
        try:
            if bool(getattr(self, "_ai_stream_chat_active", False)):
                disp = None
                if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice":
                    disp = getattr(self, "voice_chat_display", None)
                if disp is None:
                    disp = getattr(self, "comm_chat_display", None)
                if disp is not None:
                    disp.moveCursor(QTextCursor.MoveOperation.End)
                    disp.insertPlainText("\n")
        except Exception:
            pass
        self._ai_stream_chat_active = False
        self._ai_stream_chat_completed = False
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                self._ai_force_no_stream_once = True
                txt = str(getattr(self, "_ai_last_user_text", "") or "").strip()
                if txt:
                    self._append_comm("Σύστημα", "Fallback: retry χωρίς streaming…", room="voice" if str(getattr(self, "_ai_active_origin", "text") or "text") == "voice" else None)
                    QTimer.singleShot(500, lambda: self._send_ai_message(txt))
                    return
        except Exception:
            pass
        self._on_ai_error(message)

    def _stop_ai_stream(self):
        try:
            w = getattr(self, "ai_worker", None)
            if w and hasattr(w, "request_stop"):
                w.request_stop()
        except Exception:
            pass

    def _update_ai_pending_ui(self):
        try:
            cmd = str(getattr(self, "_ai_pending_command", "") or "").strip()
            if not hasattr(self, "ai_pending_widget"):
                return
            if cmd:
                self.ai_pending_label.setText(f"AI εντολή σε αναμονή: {cmd}")
                self.ai_pending_widget.setVisible(True)
            else:
                self.ai_pending_label.setText("")
                self.ai_pending_widget.setVisible(False)
        except Exception:
            pass

    def _update_learn_pending_ui(self):
        try:
            if not hasattr(self, "learn_pending_widget"):
                return
            phrase = str(getattr(self, "_learn_pending_phrase", "") or "").strip()
            cmd = str(getattr(self, "_learn_pending_command", "") or "").strip()
            if phrase and cmd and bool(getattr(self, "comm_learning_enabled", False)):
                self.learn_pending_label.setText(f"Να θυμάμαι «{phrase}» → «{cmd}» ;")
                self.learn_pending_widget.setVisible(True)
            else:
                self.learn_pending_label.setText("")
                self.learn_pending_widget.setVisible(False)
        except Exception:
            pass

    def _maybe_queue_learn_alias(self, phrase: str, cmd: str):
        try:
            if not bool(getattr(self, "comm_learning_enabled", False)):
                return
            p = str(phrase or "").strip()
            c = str(cmd or "").strip()
            if not p or not c:
                return
            if p.startswith("/") or len(p) > 200:
                return
            if not self._is_allowed_ai_command(c):
                return
            key = self._normalize_phrase_key(p)
            if isinstance(getattr(self, "comm_aliases", None), dict) and key in self.comm_aliases:
                return
            if bool(getattr(self, "comm_learning_auto_accept", False)):
                if not isinstance(getattr(self, "comm_aliases", None), dict):
                    self.comm_aliases = {}
                self.comm_aliases[key] = c
                try:
                    self._save_viewer_prefs()
                except Exception:
                    self._schedule_prefs_save()
                try:
                    self._append_comm("Σύστημα", f"Έμαθα αυτόματα: {p} → {c}")
                except Exception:
                    pass
                try:
                    self._session_log("command_executed", {"action": "learn_auto_accept", "phrase": p, "command": c})
                except Exception:
                    pass
                return
            self._learn_pending_phrase = p
            self._learn_pending_command = c
            self._update_learn_pending_ui()
        except Exception:
            pass

    def _accept_learn_alias(self):
        phrase = str(getattr(self, "_learn_pending_phrase", "") or "").strip()
        cmd = str(getattr(self, "_learn_pending_command", "") or "").strip()
        if not phrase or not cmd:
            self._update_learn_pending_ui()
            return
        key = self._normalize_phrase_key(phrase)
        if not isinstance(self.comm_aliases, dict):
            self.comm_aliases = {}
        if key in self.comm_aliases:
            self._append_comm("Σύστημα", "Το alias υπάρχει ήδη.")
        else:
            self.comm_aliases[key] = cmd
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", f"Έμαθα: {phrase} → {cmd}")
            self._session_log("command_executed", {"action": "learn_accept", "phrase": phrase, "command": cmd})
        self._learn_pending_phrase = ""
        self._learn_pending_command = ""
        self._update_learn_pending_ui()

    def _reject_learn_alias(self):
        phrase = str(getattr(self, "_learn_pending_phrase", "") or "").strip()
        cmd = str(getattr(self, "_learn_pending_command", "") or "").strip()
        self._learn_pending_phrase = ""
        self._learn_pending_command = ""
        self._update_learn_pending_ui()
        if phrase and cmd:
            try:
                self._session_log("command_executed", {"action": "learn_reject", "phrase": phrase, "command": cmd})
            except Exception:
                pass

    def _run_pending_ai_command(self):
        cmd = str(getattr(self, "_ai_pending_command", "") or "").strip()
        if not cmd:
            self._append_comm("Σύστημα", "Δεν υπάρχει εκκρεμής AI εντολή.")
            self._update_ai_pending_ui()
            return
        origin = str(getattr(self, "_ai_pending_origin_phrase", "") or "").strip()
        self._ai_pending_command = ""
        self._ai_pending_origin_phrase = ""
        self._update_ai_pending_ui()
        self._append_comm("Σύστημα", f"Εκτέλεση: {cmd}")
        self._session_log("command_executed", {"action": "ai_run_btn", "command": cmd})
        self._handle_text_command(cmd)
        self._maybe_queue_learn_alias(origin, cmd)

    def _cancel_pending_ai_command(self):
        if str(getattr(self, "_ai_pending_command", "") or "").strip():
            self._ai_pending_command = ""
            self._ai_pending_origin_phrase = ""
            self._append_comm("Σύστημα", "Ακυρώθηκε η εκκρεμής AI εντολή.")
            self._session_log("command_executed", {"action": "ai_cancel_btn"})
        else:
            self._append_comm("Σύστημα", "Δεν υπάρχει εκκρεμής AI εντολή.")
        self._update_ai_pending_ui()
        self._learn_pending_phrase = ""
        self._learn_pending_command = ""
        self._update_learn_pending_ui()

    def _update_known_commands(self):
        self._comm_known_commands = [
            "κεντράρισμα", "πλέγμα", "μαγικό", "ανάλυση", "αποκοπή", "βαθμονόμηση",
            "επόμενη", "προηγούμενη", "πλαίσια",
            "/run", "/cancel",
            "/learn yes", "/learn no",
            "/chat on", "/chat off",
            "/live on", "/live off",
            "/memory show", "/memory clear", "/memory set <text>", "/reset ai",
            "/pmemory show", "/pmemory clear", "/pmemory set <text>",
            "/help", "/suggest",
            "/alias add <φράση>=<εντολή>", "/alias list", "/alias remove <φράση>", "/alias presets",
            "/set brightness <int>", "/set contrast <int>", "/goto <int>", "/open <text>",
            "/templates", "/template <όνομα>"
        ]
        try:
            comp = QCompleter(self._comm_known_commands)
            comp.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
            self.text_input.setCompleter(comp)
        except Exception:
            pass

    def _maybe_suggest_command(self, txt: str):
        try:
            if not txt or txt.startswith("/"):
                return
            norm = txt.lower().strip()
            cand = difflib.get_close_matches(norm, self._comm_known_commands, n=1, cutoff=0.6)
            if cand:
                self._append_comm("Σύστημα", f"Μήπως εννοείς: “{cand[0]}”?")
        except Exception:
            pass

    def _toggle_voice_capture(self):
        try:
            if hasattr(self, "voice_chat_mode_toggle") and self.voice_chat_mode_toggle is not None:
                self.comm_voice_chat_enabled = bool(self.voice_chat_mode_toggle.isChecked())
        except Exception:
            pass
        if not getattr(self, "_voice_running", False):
            self._start_voice_capture()
        else:
            self._stop_voice_capture()

    def _update_microphone_status(self):
        try:
            try:
                from PyQt6.QtMultimedia import QMediaDevices
            except Exception:
                try:
                    self.voice_device_label.setText("Audio: QtMultimedia δεν είναι διαθέσιμο.")
                except Exception:
                    pass
                return

            dev = None
            try:
                dev = QMediaDevices.defaultAudioInput()
            except Exception:
                dev = None
            if dev is None:
                try:
                    self.voice_device_label.setText("Audio: δεν βρέθηκε προεπιλεγμένο μικρόφωνο.")
                except Exception:
                    pass
                return
            try:
                name = str(dev.description() or "").strip()
            except Exception:
                name = ""
            try:
                self.voice_device_label.setText(f"Συσκευή: {name}" if name else "Συσκευή: (default)")
            except Exception:
                pass
        except Exception:
            pass

    def _test_microphone(self):
        try:
            try:
                from PyQt6.QtMultimedia import QMediaDevices, QAudioFormat, QAudioSource
            except Exception:
                QMessageBox.warning(self, "Φωνή", "Δεν είναι διαθέσιμη η ηχογράφηση (QtMultimedia).")
                return
            dev = QMediaDevices.defaultAudioInput()
            if dev is None:
                QMessageBox.warning(self, "Φωνή", "Δεν βρέθηκε συσκευή μικροφώνου.")
                return
            fmt = QAudioFormat()
            fmt.setSampleRate(16000)
            fmt.setChannelCount(1)
            try:
                fmt.setSampleFormat(QAudioFormat.SampleFormat.Int16)
            except Exception:
                pass
            src = QAudioSource(dev, fmt)
            io_dev = src.start()
            if io_dev is None:
                try:
                    src.stop()
                except Exception:
                    pass
                QMessageBox.warning(self, "Φωνή", "Αποτυχία εκκίνησης μικροφώνου (πιθανό multimedia backend issue).")
                return
            QTimer.singleShot(200, lambda: self._finish_mic_test(src))
            try:
                if not bool(getattr(self, "_voice_running", False)):
                    self.voice_status.setText("Μικρόφωνο: έτοιμο")
                    QTimer.singleShot(1500, lambda: self.voice_status.setText("Μικρόφωνο: ανενεργό") if not bool(getattr(self, "_voice_running", False)) else None)
            except Exception:
                pass
            QMessageBox.information(self, "Φωνή", "OK: το μικρόφωνο είναι διαθέσιμο.")
        except Exception as e:
            QMessageBox.warning(self, "Φωνή", f"Αποτυχία δοκιμής μικροφώνου: {e}")

    def _finish_mic_test(self, src):
        try:
            try:
                src.stop()
            except Exception:
                pass
        except Exception:
            pass

    def _start_voice_capture(self):
        try:
            from PyQt6.QtMultimedia import QMediaDevices, QAudioFormat, QAudioSource
        except Exception:
            QMessageBox.warning(self, "Φωνή", "Δεν είναι διαθέσιμη η ηχογράφηση (QtMultimedia).")
            return

        device = QMediaDevices.defaultAudioInput()
        if device is None:
            QMessageBox.warning(self, "Φωνή", "Δεν βρέθηκε συσκευή μικροφώνου.")
            return

        fmt = QAudioFormat()
        fmt.setSampleRate(16000)
        fmt.setChannelCount(1)
        try:
            fmt.setSampleFormat(QAudioFormat.SampleFormat.Int16)
        except Exception:
            pass

        try:
            self._voice_pcm = bytearray()
            self._voice_audio_source = QAudioSource(device, fmt)
            self._voice_audio_io = self._voice_audio_source.start()
            if self._voice_audio_io is None:
                raise RuntimeError("Αποτυχία εκκίνησης μικροφώνου (multimedia backend).")
            self._voice_running = True
            self.voice_status.setText("Μικρόφωνο: ενεργό")
            try:
                if bool(getattr(self, "comm_voice_chat_enabled", False)):
                    self.voice_toggle_btn.setText("Σταμάτα")
                else:
                    self.voice_toggle_btn.setText("Διακοπή Καταγραφής")
            except Exception:
                self.voice_toggle_btn.setText("Διακοπή Καταγραφής")
            self._append_comm("Σύστημα", "Έναρξη καταγραφής φωνής.")
            self._session_log("voice_started", {"sample_rate": 16000, "channels": 1})
            try:
                self._voice_vad_last_speech_ts = time.time()
                self._voice_vad_had_speech = False
                self._voice_vad_started_ts = time.time()
                self._voice_vad_auto_stopped = False
            except Exception:
                pass

            self._voice_audio_timer = QTimer()
            self._voice_audio_timer.setInterval(50)
            self._voice_audio_timer.timeout.connect(self._pull_voice_audio)
            self._voice_audio_timer.start()
        except Exception as e:
            self._voice_running = False
            self.voice_status.setText("Μικρόφωνο: ανενεργό")
            QMessageBox.warning(self, "Φωνή", f"Αποτυχία εκκίνησης καταγραφής: {e}")

    def _pull_voice_audio(self):
        try:
            io_dev = getattr(self, "_voice_audio_io", None)
            if not io_dev:
                return
            data = io_dev.readAll()
            if data:
                b = b""
                try:
                    b = bytes(data)
                    self._voice_pcm.extend(b)
                except Exception:
                    pass
                try:
                    if bool(getattr(self, "comm_voice_chat_enabled", False)) and bool(getattr(self, "voice_handsfree_toggle", None).isChecked() if getattr(self, "voice_handsfree_toggle", None) else bool(getattr(self, "comm_voice_handsfree", True))):
                        self._update_voice_vad_and_maybe_stop(b)
                except Exception:
                    pass
        except Exception:
            pass

    def _update_voice_vad_and_maybe_stop(self, pcm_chunk: bytes):
        try:
            if not bool(getattr(self, "_voice_running", False)):
                return
            if bool(getattr(self, "_voice_vad_auto_stopped", False)):
                return
            if not pcm_chunk:
                return
            try:
                import array
                a = array.array("h")
                a.frombytes(pcm_chunk)
            except Exception:
                return
            if not a:
                return
            s = 0
            n = 0
            for v in a:
                s += abs(int(v))
                n += 1
            avg = (s / n) if n else 0.0
            now = time.time()
            thr = 260.0
            if avg >= thr:
                self._voice_vad_last_speech_ts = now
                self._voice_vad_had_speech = True
                return
            had = bool(getattr(self, "_voice_vad_had_speech", False))
            if not had:
                return
            last = float(getattr(self, "_voice_vad_last_speech_ts", now) or now)
            started = float(getattr(self, "_voice_vad_started_ts", now) or now)
            silence_s = max(0.0, now - last)
            total_s = max(0.0, now - started)
            if total_s < 0.7:
                return
            if silence_s >= 1.5:
                self._voice_vad_auto_stopped = True
                QTimer.singleShot(0, self._stop_voice_capture)
        except Exception:
            pass

    def _stop_voice_capture(self):
        try:
            if self._voice_audio_timer:
                self._voice_audio_timer.stop()
                self._voice_audio_timer.deleteLater()
                self._voice_audio_timer = None
        except Exception:
            self._voice_audio_timer = None

        try:
            if self._voice_audio_source:
                self._voice_audio_source.stop()
        except Exception:
            pass

        self._voice_audio_source = None
        self._voice_audio_io = None
        self._voice_running = False
        self.voice_status.setText("Μικρόφωνο: ανενεργό")
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                self.voice_toggle_btn.setText("Μίλα")
            else:
                self.voice_toggle_btn.setText("Έναρξη Καταγραφής")
        except Exception:
            self.voice_toggle_btn.setText("Έναρξη Καταγραφής")

        wav_bytes = self._pcm16_to_wav_bytes(bytes(self._voice_pcm), sample_rate=16000, channels=1)
        self._last_voice_wav = wav_bytes
        self._append_comm("Σύστημα", f"Τερματισμός καταγραφής. Δείγματα: {len(self._voice_pcm)} bytes.")
        self._session_log("voice_stopped", {"pcm_bytes": int(len(self._voice_pcm)), "wav_bytes": int(len(wav_bytes))})
        try:
            if bool(getattr(self, "comm_voice_auto_transcribe", True)):
                QTimer.singleShot(0, self._transcribe_last_voice)
        except Exception:
            pass

    def _pcm16_to_wav_bytes(self, pcm_bytes: bytes, sample_rate: int = 16000, channels: int = 1) -> bytes:
        bio = io.BytesIO()
        with wave.open(bio, "wb") as wf:
            wf.setnchannels(int(channels))
            wf.setsampwidth(2)
            wf.setframerate(int(sample_rate))
            wf.writeframes(pcm_bytes or b"")
        return bio.getvalue()

    def _save_comm_prefs_from_ui(self):
        try:
            self.comm_stt_url = str(self.comm_stt_url_edit.text() or "").strip()
            self.comm_stt_lang = str(self.comm_stt_lang_edit.text() or "el").strip() or "el"
            try:
                if hasattr(self, "comm_stt_backend_combo"):
                    self.comm_stt_backend = str(self.comm_stt_backend_combo.currentData() or "api")
                if hasattr(self, "comm_whisper_cli_edit"):
                    self.comm_whispercpp_cli = str(self.comm_whisper_cli_edit.text() or "").strip()
                if hasattr(self, "comm_whisper_model_edit"):
                    self.comm_whispercpp_model = str(self.comm_whisper_model_edit.text() or "").strip()
                if hasattr(self, "comm_tts_backend_combo"):
                    self.comm_tts_backend = str(self.comm_tts_backend_combo.currentData() or "qt")
                if hasattr(self, "comm_piper_cli_edit"):
                    self.comm_piper_cli = str(self.comm_piper_cli_edit.text() or "").strip()
                if hasattr(self, "comm_piper_voice_edit"):
                    self.comm_piper_voice_model = str(self.comm_piper_voice_edit.text() or "").strip()
            except Exception:
                pass
            try:
                if hasattr(self, "voice_auto_transcribe_toggle"):
                    self.comm_voice_auto_transcribe = bool(self.voice_auto_transcribe_toggle.isChecked())
                if hasattr(self, "voice_auto_send_toggle"):
                    self.comm_voice_auto_send = bool(self.voice_auto_send_toggle.isChecked())
                if hasattr(self, "voice_tts_toggle"):
                    self.comm_tts_enabled = bool(self.voice_tts_toggle.isChecked())
                if hasattr(self, "voice_action_tts_toggle"):
                    self.comm_action_tts_enabled = bool(self.voice_action_tts_toggle.isChecked())
                if hasattr(self, "voice_scan_tts_toggle"):
                    self.comm_scan_tts_enabled = bool(self.voice_scan_tts_toggle.isChecked())
                if hasattr(self, "voice_chat_mode_toggle"):
                    self.comm_voice_chat_enabled = bool(self.voice_chat_mode_toggle.isChecked())
                if hasattr(self, "voice_handsfree_toggle"):
                    self.comm_voice_handsfree = bool(self.voice_handsfree_toggle.isChecked())
                if hasattr(self, "voice_ptt_toggle"):
                    self.comm_voice_push_to_talk = bool(self.voice_ptt_toggle.isChecked())
                if hasattr(self, "voice_continuous_toggle"):
                    self.comm_voice_continuous = bool(self.voice_continuous_toggle.isChecked())
            except Exception:
                pass
            if bool(getattr(self, "comm_tts_enabled", False)) and getattr(self, "_tts_engine", None) is None:
                try:
                    self._init_tts_engine()
                except Exception:
                    pass
                if getattr(self, "_tts_engine", None) is None:
                    self._append_comm("Σύστημα", "TTS δεν είναι διαθέσιμο σε αυτό το περιβάλλον.")
            self._save_viewer_prefs()
            self._append_comm("Σύστημα", "Αποθηκεύτηκαν οι ρυθμίσεις STT.")
        except Exception as e:
            self._append_comm("Σύστημα", f"Αποτυχία αποθήκευσης: {e}")

    def _save_voice_mode_prefs_from_ui(self):
        try:
            if hasattr(self, "voice_chat_mode_toggle"):
                self.comm_voice_chat_enabled = bool(self.voice_chat_mode_toggle.isChecked())
            if hasattr(self, "voice_handsfree_toggle"):
                self.comm_voice_handsfree = bool(self.voice_handsfree_toggle.isChecked())
            if hasattr(self, "voice_ptt_toggle"):
                self.comm_voice_push_to_talk = bool(self.voice_ptt_toggle.isChecked())
            if hasattr(self, "voice_continuous_toggle"):
                self.comm_voice_continuous = bool(self.voice_continuous_toggle.isChecked())
            self._save_viewer_prefs()
        except Exception:
            pass

    def _ensure_voice_chat_stt_ready(self):
        try:
            try:
                self.comm_stt_url = str(getattr(self, "comm_stt_url_edit", None).text() if getattr(self, "comm_stt_url_edit", None) else self.comm_stt_url).strip()
            except Exception:
                pass
            try:
                self.comm_whispercpp_cli = str(getattr(self, "comm_whisper_cli_edit", None).text() if getattr(self, "comm_whisper_cli_edit", None) else self.comm_whispercpp_cli).strip()
                self.comm_whispercpp_model = str(getattr(self, "comm_whisper_model_edit", None).text() if getattr(self, "comm_whisper_model_edit", None) else self.comm_whispercpp_model).strip()
            except Exception:
                pass

            has_whisper = bool(self.comm_whispercpp_cli and self.comm_whispercpp_model and os.path.exists(self.comm_whispercpp_cli) and os.path.exists(self.comm_whispercpp_model))
            if has_whisper:
                try:
                    cur_model = str(self.comm_whispercpp_model or "").lower()
                    if ("ggml-base.bin" in cur_model) and not bool(getattr(self, "_voice_chat_whisper_upgrade_tried", False)):
                        self._voice_chat_whisper_upgrade_tried = True
                        models_dir = os.path.join(os.path.dirname(self.comm_whispercpp_model), "")
                        small_path = os.path.join(models_dir, "ggml-small.bin")
                        if os.path.exists(small_path):
                            self.comm_whispercpp_model = small_path
                            if hasattr(self, "comm_whisper_model_edit") and self.comm_whisper_model_edit is not None:
                                self.comm_whisper_model_edit.setText(small_path)
                            self._save_viewer_prefs()
                        else:
                            self._append_comm("Σύστημα", "Voice chat: αναβάθμιση Whisper model σε small για καλύτερα Ελληνικά…", room="voice")
                            url = "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-small.bin?download=true"
                            self.whisper_model_dl_worker = WhisperCppModelDownloadWorker(small_path, url, "Κατέβασμα Whisper model (small)…", timeout_s=240, parent=self)
                            self.whisper_model_dl_worker.progress.connect(lambda pct, s: self._append_comm("Σύστημα", s, room="voice"))
                            self.whisper_model_dl_worker.finished.connect(lambda p, ms: self._on_whisper_model_upgrade_done(p, ms))
                            self.whisper_model_dl_worker.error.connect(lambda e: self._append_comm("Σύστημα", f"Whisper model: αποτυχία αναβάθμισης: {e}", room="voice"))
                            self.whisper_model_dl_worker.start()
                except Exception:
                    pass
                # Removed forced downgrade to small model
                try:
                    self.comm_stt_backend = "whispercpp"
                    if hasattr(self, "comm_stt_backend_combo") and self.comm_stt_backend_combo is not None:
                        self.comm_stt_backend_combo.blockSignals(True)
                        idx = self.comm_stt_backend_combo.findData("whispercpp")
                        if idx >= 0:
                            self.comm_stt_backend_combo.setCurrentIndex(idx)
                        self.comm_stt_backend_combo.blockSignals(False)
                    self._update_voice_backend_ui()
                except Exception:
                    pass
                return

            if not bool(getattr(self, "_voice_chat_whisper_autoinstall_tried", False)):
                self._voice_chat_whisper_autoinstall_tried = True
                try:
                    self._append_comm("Σύστημα", "Voice chat: εγκατάσταση Whisper.cpp (προτίμηση GPU build)…")
                except Exception:
                    pass
                try:
                    self._install_embedded_whispercpp()
                except Exception:
                    pass

            if not self.comm_stt_url:
                default_url = "http://localhost:8000/transcribe"
                try:
                    if hasattr(self, "comm_stt_url_edit") and self.comm_stt_url_edit is not None:
                        self.comm_stt_url_edit.setText(default_url)
                except Exception:
                    pass
                self.comm_stt_url = default_url
                try:
                    self.comm_stt_backend = "api"
                    if hasattr(self, "comm_stt_backend_combo") and self.comm_stt_backend_combo is not None:
                        self.comm_stt_backend_combo.blockSignals(True)
                        idx = self.comm_stt_backend_combo.findData("api")
                        if idx >= 0:
                            self.comm_stt_backend_combo.setCurrentIndex(idx)
                        self.comm_stt_backend_combo.blockSignals(False)
                    self._update_voice_backend_ui()
                except Exception:
                    pass
                try:
                    self._append_comm("Σύστημα", f"STT: ορίστηκε default URL {default_url}. Αν δεν τρέχει server, βάλε Whisper.cpp (exe+model).")
                except Exception:
                    pass
        except Exception:
            pass

    def _on_whisper_model_upgrade_done(self, model_path: str, elapsed_ms: float):
        try:
            p = str(model_path or "").strip()
            if p and os.path.exists(p):
                self.comm_whispercpp_model = p
                try:
                    if hasattr(self, "comm_whisper_model_edit") and self.comm_whisper_model_edit is not None:
                        self.comm_whisper_model_edit.setText(p)
                except Exception:
                    pass
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                name = "medium" if "ggml-medium.bin" in str(p).lower() else ("small" if "ggml-small.bin" in str(p).lower() else os.path.basename(p))
                self._append_comm("Σύστημα", f"✅ Whisper model upgraded: {name} ({elapsed_ms:.0f}ms).", room="voice")
                try:
                    if bool(getattr(self, "_stt_retry_after_whisper_install", False)):
                        self._stt_retry_after_whisper_install = False
                        QTimer.singleShot(0, self._transcribe_last_voice)
                except Exception:
                    pass
        except Exception:
            pass

    def _toggle_voice_chat_mode(self):
        try:
            enabled = bool(self.voice_chat_mode_toggle.isChecked()) if hasattr(self, "voice_chat_mode_toggle") else False
            self.comm_voice_chat_enabled = bool(enabled)
            if enabled:
                try:
                    self.voice_auto_transcribe_toggle.setChecked(True)
                    self.voice_auto_send_toggle.setChecked(True)
                    self.voice_tts_toggle.setChecked(True)
                except Exception:
                    pass
                try:
                    self.comm_voice_auto_transcribe = True
                    self.comm_voice_auto_send = True
                    self.comm_tts_enabled = True
                except Exception:
                    pass
                try:
                    if hasattr(self, "comm_ai_toggle") and self.comm_ai_toggle is not None:
                        self.comm_ai_toggle.setChecked(True)
                        self.comm_ai_enabled = True
                    if hasattr(self, "comm_chatty_toggle") and self.comm_chatty_toggle is not None:
                        self.comm_chatty_toggle.setChecked(True)
                        self.comm_conversation_enabled = True
                    if hasattr(self, "comm_live_toggle") and self.comm_live_toggle is not None:
                        self.comm_live_toggle.setChecked(False)
                        self.comm_ai_stream_enabled = False
                except Exception:
                    pass
                try:
                    self.comm_ai_stream_enabled = False
                except Exception:
                    pass
                try:
                    if hasattr(self, "comm_llm_model_edit") and self.comm_llm_model_edit is not None:
                        cur = str(self.comm_llm_model_edit.text() or "").strip()
                        if not cur or cur == "llama3.1:latest":
                            self.comm_llm_model_edit.setText("llama3.2:1b")
                    self.comm_llm_model = str(self.comm_llm_model_edit.text() or "").strip() or "llama3.2:1b"
                except Exception:
                    pass
                try:
                    if hasattr(self, "voice_handsfree_toggle") and self.voice_handsfree_toggle is not None:
                        self.voice_handsfree_toggle.setChecked(False)
                    if hasattr(self, "voice_continuous_toggle") and self.voice_continuous_toggle is not None:
                        self.voice_continuous_toggle.setChecked(False)
                    if hasattr(self, "voice_ptt_toggle") and self.voice_ptt_toggle is not None:
                        self.voice_ptt_toggle.setChecked(True)
                    self.comm_voice_handsfree = False
                    self.comm_voice_continuous = False
                    self.comm_voice_push_to_talk = True
                except Exception:
                    pass
                try:
                    self._ensure_voice_chat_stt_ready()
                except Exception:
                    pass
                try:
                    self._ensure_voice_chat_tts_ready()
                except Exception:
                    pass
                try:
                    if hasattr(self, "comm_chat_toggle") and self.comm_chat_toggle is not None:
                        self.comm_chat_toggle.setChecked(True)
                    self._toggle_comm_chat_visible(True)
                except Exception:
                    pass
                try:
                    if not bool(getattr(self, "_voice_chat_checked_ollama", False)):
                        self._voice_chat_checked_ollama = True
                        self._check_ollama_connection()
                except Exception:
                    pass
                try:
                    ptt = bool(self.voice_ptt_toggle.isChecked()) if hasattr(self, "voice_ptt_toggle") else bool(getattr(self, "comm_voice_push_to_talk", False))
                    if ptt:
                        self.voice_toggle_btn.setText("Κράτα για ομιλία" if not bool(getattr(self, "_voice_running", False)) else "Άφησε για stop")
                    else:
                        self.voice_toggle_btn.setText("Μίλα" if not bool(getattr(self, "_voice_running", False)) else "Σταμάτα")
                    self.voice_transcribe_btn.setVisible(False)
                    self.voice_send_btn.setVisible(False)
                    self.voice_toggle_btn.setMinimumHeight(44)
                except Exception:
                    pass
            else:
                try:
                    self.voice_transcribe_btn.setVisible(True)
                    self.voice_send_btn.setVisible(True)
                    self.voice_toggle_btn.setMinimumHeight(0)
                    self.voice_toggle_btn.setText("Έναρξη Καταγραφής" if not bool(getattr(self, "_voice_running", False)) else "Διακοπή Καταγραφής")
                except Exception:
                    pass
            self._save_viewer_prefs()
        except Exception:
            pass

    def eventFilter(self, obj, event):
        try:
            if hasattr(self, "voice_toggle_btn") and obj is self.voice_toggle_btn:
                if bool(getattr(self, "comm_voice_chat_enabled", False)) and bool(getattr(self, "comm_voice_push_to_talk", False)):
                    t = event.type()
                    if t == QEvent.Type.MouseButtonPress:
                        if not bool(getattr(self, "_voice_running", False)):
                            self._start_voice_capture()
                        return True
                    if t == QEvent.Type.MouseButtonRelease:
                        if bool(getattr(self, "_voice_running", False)):
                            self._stop_voice_capture()
                        return True
        except Exception:
            pass
        try:
            return super().eventFilter(obj, event)
        except Exception:
            return False

    def _maybe_schedule_voice_chat_resume(self, delay_ms: int = 500):
        try:
            if not bool(getattr(self, "comm_voice_chat_enabled", False)):
                return
            if not bool(getattr(self, "comm_voice_continuous", True)):
                return
            if bool(getattr(self, "comm_voice_push_to_talk", False)):
                return
            if bool(getattr(self, "_voice_running", False)):
                return
            if bool(getattr(self, "_tts_speaking", False)):
                return
            if getattr(self, "_voice_resume_timer", None) is None:
                self._voice_resume_timer = QTimer(self)
                self._voice_resume_timer.setSingleShot(True)
                self._voice_resume_timer.timeout.connect(self._resume_voice_chat_now)
            self._voice_resume_timer.start(max(0, int(delay_ms)))
        except Exception:
            pass

    def _resume_voice_chat_now(self):
        try:
            if not bool(getattr(self, "comm_voice_chat_enabled", False)):
                return
            if not bool(getattr(self, "comm_voice_continuous", True)):
                return
            if bool(getattr(self, "comm_voice_push_to_talk", False)):
                return
            if bool(getattr(self, "_voice_running", False)):
                return
            if bool(getattr(self, "_tts_speaking", False)):
                return
            self._start_voice_capture()
        except Exception:
            pass

    def _pick_path_for_edit(self, edit: QLineEdit, title: str, file_filter: str):
        try:
            start_dir = ""
            try:
                start_dir = str(edit.text() or "").strip()
                if start_dir and os.path.isfile(start_dir):
                    start_dir = os.path.dirname(start_dir)
            except Exception:
                start_dir = ""
            path, _ = QFileDialog.getOpenFileName(self, str(title or "Επιλογή αρχείου"), start_dir, str(file_filter or "Όλα (*.*)"))
            if not path:
                return
            try:
                edit.setText(str(path))
            except Exception:
                pass
            self._on_voice_backend_changed()
        except Exception:
            pass

    def _on_voice_backend_changed(self):
        try:
            try:
                if hasattr(self, "comm_stt_backend_combo"):
                    self.comm_stt_backend = str(self.comm_stt_backend_combo.currentData() or "api")
                if hasattr(self, "comm_tts_backend_combo"):
                    self.comm_tts_backend = str(self.comm_tts_backend_combo.currentData() or "qt")
            except Exception:
                pass
            self._update_voice_backend_ui()
            self._save_comm_prefs_from_ui()
        except Exception:
            pass

    def _update_voice_backend_ui(self):
        try:
            stt_backend = str(getattr(self, "comm_stt_backend", "api") or "api").strip().lower()
            is_whisper = (stt_backend == "whispercpp")
            for w in (
                getattr(self, "comm_stt_url_edit", None),
                getattr(self, "comm_stt_save_btn", None),
            ):
                if w is not None:
                    try:
                        w.setEnabled(not is_whisper)
                    except Exception:
                        pass

            for w in (
                getattr(self, "comm_whisper_cli_edit", None),
                getattr(self, "comm_whisper_cli_browse", None),
                getattr(self, "comm_whisper_install_btn", None),
                getattr(self, "comm_whisper_model_edit", None),
                getattr(self, "comm_whisper_model_browse", None),
            ):
                if w is not None:
                    try:
                        w.setVisible(True)
                        w.setEnabled(bool(is_whisper))
                    except Exception:
                        pass

            tts_backend = str(getattr(self, "comm_tts_backend", "qt") or "qt").strip().lower()
            is_piper = (tts_backend == "piper")
            is_edge = (tts_backend == "edge-tts")
            for w in (
                getattr(self, "comm_piper_cli_edit", None),
                getattr(self, "comm_piper_cli_browse", None),
                getattr(self, "comm_piper_install_btn", None),
                getattr(self, "comm_piper_voice_edit", None),
                getattr(self, "comm_piper_voice_browse", None),
            ):
                if w is not None:
                    try:
                        w.setVisible(True)
                        w.setEnabled(bool(is_piper))
                    except Exception:
                        pass
            
            for w in (
                getattr(self, "comm_edge_tts_voice_edit", None),
            ):
                if w is not None:
                    try:
                        w.setVisible(True)
                        w.setEnabled(bool(is_edge))
                    except Exception:
                        pass
        except Exception:
            pass

    def _refresh_templates_ui(self):
        try:
            self.comm_template_combo.blockSignals(True)
            self.comm_template_combo.clear()
            names = sorted([str(k) for k in (self.comm_templates or {}).keys() if str(k).strip()])
            if not names:
                self.comm_template_combo.addItem("(χωρίς πρότυπα)")
                self.comm_template_combo.setEnabled(False)
            else:
                self.comm_template_combo.setEnabled(True)
                for n in names:
                    self.comm_template_combo.addItem(n)
                if self.comm_last_template and self.comm_last_template in names:
                    self.comm_template_combo.setCurrentText(self.comm_last_template)
        except Exception:
            pass
        finally:
            try:
                self.comm_template_combo.blockSignals(False)
            except Exception:
                pass

    def _run_selected_template(self):
        name = ""
        try:
            name = str(self.comm_template_combo.currentText() or "").strip()
        except Exception:
            name = ""
        if not name or name == "(χωρίς πρότυπα)":
            self._append_comm("Σύστημα", "Δεν υπάρχει επιλεγμένο πρότυπο.")
            return
        payload = str((self.comm_templates or {}).get(name) or "").strip()
        if not payload:
            self._append_comm("Σύστημα", "Το πρότυπο είναι κενό.")
            return
        self.comm_last_template = name
        try:
            self._save_viewer_prefs()
        except Exception:
            pass
        self._append_comm("Χρήστης", payload)
        self._handle_text_command(payload)

    def _save_current_as_template(self):
        txt = str(self.text_input.text() or "").strip()
        if not txt:
            self._append_comm("Σύστημα", "Γράψε πρώτα μια εντολή/κείμενο για αποθήκευση.")
            return
        name, ok = QInputDialog.getText(self, "Αποθήκευση Πρότυπου", "Όνομα προτύπου:")
        if not ok:
            return
        name = str(name or "").strip()
        if not name:
            self._append_comm("Σύστημα", "Άκυρο όνομα προτύπου.")
            return
        if not isinstance(self.comm_templates, dict):
            self.comm_templates = {}
        self.comm_templates[name] = txt
        self.comm_last_template = name
        self._save_viewer_prefs()
        self._refresh_templates_ui()
        self._append_comm("Σύστημα", f"Αποθηκεύτηκε πρότυπο: {name}")

    def _transcribe_last_voice(self):
        self.comm_stt_url = str(getattr(self, "comm_stt_url_edit", None).text() if getattr(self, "comm_stt_url_edit", None) else self.comm_stt_url).strip()
        self.comm_stt_lang = str(getattr(self, "comm_stt_lang_edit", None).text() if getattr(self, "comm_stt_lang_edit", None) else self.comm_stt_lang).strip() or "el"
        if not self._last_voice_wav:
            self._append_comm("Σύστημα", "Δεν υπάρχει ηχητικό. Κάνε πρώτα καταγραφή.")
            return
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                with wave.open(io.BytesIO(self._last_voice_wav), "rb") as wf:
                    frames = int(wf.getnframes() or 0)
                    rate = int(wf.getframerate() or 0)
                dur = (frames / rate) if rate > 0 else 0.0
                if dur > 0 and dur < 0.5:
                    self._append_comm("Σύστημα", "Πολύ σύντομη ομιλία. Πες μια λίγο πιο μεγάλη φράση και ξαναδοκίμασε.", room="voice")
                    return
        except Exception:
            pass
        backend = ""
        try:
            if hasattr(self, "comm_stt_backend_combo") and self.comm_stt_backend_combo is not None:
                backend = str(self.comm_stt_backend_combo.currentData() or "")
        except Exception:
            backend = ""
        backend = (backend or str(getattr(self, "comm_stt_backend", "api") or "api")).strip().lower()
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                self._ensure_voice_chat_stt_ready()
                backend = (str(getattr(self, "comm_stt_backend", backend) or backend)).strip().lower()
                self.comm_stt_url = str(getattr(self, "comm_stt_url_edit", None).text() if getattr(self, "comm_stt_url_edit", None) else self.comm_stt_url).strip()
        except Exception:
            pass

        if backend != "whispercpp" and not str(self.comm_stt_url or "").strip():
            try:
                self.comm_whispercpp_cli = str(getattr(self, "comm_whisper_cli_edit", None).text() if getattr(self, "comm_whisper_cli_edit", None) else self.comm_whispercpp_cli).strip()
                self.comm_whispercpp_model = str(getattr(self, "comm_whisper_model_edit", None).text() if getattr(self, "comm_whisper_model_edit", None) else self.comm_whispercpp_model).strip()
            except Exception:
                pass
            if self.comm_whispercpp_cli and self.comm_whispercpp_model and os.path.exists(self.comm_whispercpp_cli) and os.path.exists(self.comm_whispercpp_model):
                backend = "whispercpp"
                try:
                    self.comm_stt_backend = "whispercpp"
                    if hasattr(self, "comm_stt_backend_combo") and self.comm_stt_backend_combo is not None:
                        idx = self.comm_stt_backend_combo.findData("whispercpp")
                        if idx >= 0:
                            self.comm_stt_backend_combo.setCurrentIndex(idx)
                    self._update_voice_backend_ui()
                    self._save_viewer_prefs()
                except Exception:
                    pass
            else:
                self._append_comm("Σύστημα", "Σφάλμα μεταγραφής: Δεν υπάρχει STT. Βάλε STT API URL ή ρύθμισε Whisper.cpp (exe+model).")
                return

        if backend == "whispercpp":
            try:
                self.comm_whispercpp_cli = str(getattr(self, "comm_whisper_cli_edit", None).text() if getattr(self, "comm_whisper_cli_edit", None) else self.comm_whispercpp_cli).strip()
                self.comm_whispercpp_model = str(getattr(self, "comm_whisper_model_edit", None).text() if getattr(self, "comm_whisper_model_edit", None) else self.comm_whispercpp_model).strip()
            except Exception:
                pass
            has_whisper = bool(self.comm_whispercpp_cli and self.comm_whispercpp_model and os.path.exists(self.comm_whispercpp_cli) and os.path.exists(self.comm_whispercpp_model))
            if not has_whisper:
                w = getattr(self, "whisper_install_worker", None)
                if w is not None and hasattr(w, "isRunning") and w.isRunning():
                    self._append_comm("Σύστημα", "Whisper.cpp: εγκατάσταση σε εξέλιξη… περίμενε λίγο και θα γίνει αυτόματα μεταγραφή.")
                    self._stt_retry_after_whisper_install = True
                    return
                self._append_comm("Σύστημα", "Whisper.cpp: λείπει exe/model. Ξεκινά εγκατάσταση…")
                self._stt_retry_after_whisper_install = True
                try:
                    self._install_embedded_whispercpp()
                except Exception:
                    pass
                return

        self._append_comm("Σύστημα", "Μεταγραφή σε εξέλιξη…")
        try:
            self._stt_last_backend = str(backend or "")
        except Exception:
            self._stt_last_backend = ""
        if backend == "whispercpp":
            try:
                self.comm_whispercpp_cli = str(getattr(self, "comm_whisper_cli_edit", None).text() if getattr(self, "comm_whisper_cli_edit", None) else self.comm_whispercpp_cli).strip()
                self.comm_whispercpp_model = str(getattr(self, "comm_whisper_model_edit", None).text() if getattr(self, "comm_whisper_model_edit", None) else self.comm_whispercpp_model).strip()
            except Exception:
                pass
            self._session_log("stt_started", {"backend": "whispercpp", "lang": self.comm_stt_lang, "wav_bytes": int(len(self._last_voice_wav))})
            self.stt_worker = WhisperCppTranscribeWorker(self.comm_whispercpp_cli, self.comm_whispercpp_model, self._last_voice_wav, language=self.comm_stt_lang, timeout_ms=180000)
        else:
            self._session_log("stt_started", {"backend": "api", "endpoint": self.comm_stt_url, "lang": self.comm_stt_lang, "wav_bytes": int(len(self._last_voice_wav))})
            self.stt_worker = SpeechToTextWorker(self.comm_stt_url, self._last_voice_wav, language=self.comm_stt_lang, timeout_ms=20000)
        self.stt_worker.result.connect(self._on_stt_result)
        self.stt_worker.error.connect(self._on_stt_error)
        self.stt_worker.start()

    def _on_stt_result(self, text: str, elapsed_ms: float):
        out = str(text or "")
        try:
            if bool(getattr(self, "comm_voice_chat_enabled", False)):
                out = re.sub(r"\[[^\]]+\]", " ", out)
        except Exception:
            pass
        try:
            out = re.sub(r"\s+", " ", out).strip()
        except Exception:
            out = str(out or "").strip()
        self.voice_transcript.setText(out)
        self._append_comm("Σύστημα", f"Μεταγραφή ολοκληρώθηκε ({elapsed_ms:.0f}ms).")
        self._session_log("stt_finished", {"elapsed_ms": float(elapsed_ms), "text": str(out or "")})
        try:
            if bool(getattr(self, "comm_voice_auto_send", True)) and str(out or "").strip():
                if bool(getattr(self, "comm_voice_chat_enabled", False)):
                    words = [w for w in str(out or "").strip().split(" ") if w.strip()]
                    if len(words) < 2 and len(str(out or "").strip()) < 8:
                        self._append_comm("AI", "Δεν σε άκουσα καθαρά. Πες το ξανά λίγο πιο αργά.", room="voice")
                        try:
                            self._maybe_speak_comm("AI", "Δεν σε άκουσα καθαρά. Πες το ξανά λίγο πιο αργά.")
                        except Exception:
                            pass
                        try:
                            self._maybe_schedule_voice_chat_resume(650)
                        except Exception:
                            pass
                        return
                QTimer.singleShot(0, self._send_voice_transcript)
        except Exception:
            pass

    def _on_stt_error(self, message: str):
        msg = str(message or "")
        last_backend = str(getattr(self, "_stt_last_backend", "") or "").strip().lower()
        if last_backend == "api":
            low = msg.lower()
            retryable = ("winerror 10061" in low or "refused" in low or "timed out" in low or "timeout" in low or "http error" in low)
            if retryable:
                try:
                    cli = str(getattr(self, "comm_whispercpp_cli", "") or "").strip()
                    model = str(getattr(self, "comm_whispercpp_model", "") or "").strip()
                    try:
                        if hasattr(self, "comm_whisper_cli_edit") and self.comm_whisper_cli_edit is not None:
                            cli = str(self.comm_whisper_cli_edit.text() or "").strip() or cli
                        if hasattr(self, "comm_whisper_model_edit") and self.comm_whisper_model_edit is not None:
                            model = str(self.comm_whisper_model_edit.text() or "").strip() or model
                    except Exception:
                        pass
                    if cli and model and os.path.exists(cli) and os.path.exists(model):
                        self._append_comm("Σύστημα", "Το STT API απέτυχε · δοκιμή Whisper.cpp…")
                        self._stt_last_backend = "whispercpp"
                        self.stt_worker = WhisperCppTranscribeWorker(cli, model, self._last_voice_wav, language=self.comm_stt_lang, timeout_ms=180000)
                        self.stt_worker.result.connect(self._on_stt_result)
                        self.stt_worker.error.connect(lambda e: self._append_comm("Σύστημα", f"Σφάλμα μεταγραφής: {e}"))
                        self.stt_worker.start()
                        self._session_log("stt_error", {"backend": "api", "message": msg, "fallback": "whispercpp"})
                        return
                except Exception:
                    pass
        self._append_comm("Σύστημα", f"Σφάλμα μεταγραφής: {msg}")
        self._session_log("stt_error", {"message": msg})

    def _send_voice_transcript(self):
        txt = str(self.voice_transcript.text() or "").strip()
        if not txt:
            self._append_comm("Σύστημα", "Δεν υπάρχει μεταγραφή για αποστολή.")
            return
        self._ai_last_origin = "voice"
        self._append_comm("Χρήστης", txt, room="voice")
        try:
            if self._handle_command_confirmation_input(txt):
                return
        except Exception:
            pass
        if bool(getattr(self, "comm_voice_chat_enabled", False)):
            try:
                self.comm_ai_enabled = True
                if hasattr(self, "comm_ai_toggle") and self.comm_ai_toggle is not None:
                    self.comm_ai_toggle.setChecked(True)
            except Exception:
                pass
            self._send_ai_message(txt)
            return
        direct = self._direct_command_from_text(txt)
        if direct:
            self._handle_text_command(direct)
        elif getattr(self, "comm_ai_enabled", False):
            self._send_ai_message(txt)
        else:
            self._handle_text_command(txt)

    def _handle_text_command(self, text: str):
        raw = str(text or "").strip()
        t = raw.lower()
        t_key = self._normalize_phrase_key(raw)
        try:
            if bool(getattr(self, "_manual_scan_active", False)):
                if t_key and ("αναλυση" in t_key or "analysis" in t_key) or (t.startswith("/click") and "analyze" in t):
                    self._append_comm("Σύστημα", "Εντολή ανάλυσης: μπλοκαρίστηκε (χειροκίνητη σάρωση ενεργή).")
                    return
        except Exception:
            pass
        try:
            started = time.perf_counter()
            self._session_log("command_received", {"text": raw})
            try:
                if bool(getattr(self, "comm_action_tts_enabled", False)):
                    self._speak_actions_active = True
                    if getattr(self, "_speak_actions_timer", None) is None:
                        self._speak_actions_timer = QTimer(self)
                        self._speak_actions_timer.setSingleShot(True)
                        self._speak_actions_timer.timeout.connect(self._deactivate_action_speech)
                    self._speak_actions_timer.start(2500)
            except Exception:
                pass

            # Resolve aliases (learning)
            alias = (self.comm_aliases or {}).get(t) or (self.comm_aliases or {}).get(t_key)
            if alias:
                raw = str(alias).strip()
                t = raw.lower()
                t_key = self._normalize_phrase_key(raw)
                self._append_comm("Σύστημα", f"Χρήση alias → {raw}")

            if t in ("/help", "help", "βοήθεια") or t_key in ("βοηθεια",):
                self._append_comm("Σύστημα", "Εντολές: κεντράρισμα, πλέγμα, μαγικό, ανάλυση, αποκοπή, βαθμονόμηση, επόμενη, προηγούμενη, πλαίσια, προσθήκη ακτινογραφίας, διπλότυπα, επαλήθευση, εξαγωγή, αποθήκευση ανάλυσης, καθαρισμός ανάλυσης, ιστορικό, εκπαίδευση μοντέλου, yolo, γραμμές, auto fdi, κλείδωμα. Slash: /click <action>, /set brightness <−100..100>, /set contrast <0..200>, /goto <n>, /open <όνομα>, /templates, /template <όνομα>, /suggest, /alias ... (/alias presets), /macro add|list|remove|run, /learn yes|no, /chat on|off, /live on|off, /auto_train on|off|status, /notify training on|off, /memory show|clear|set <text>, /pmemory show|clear|set <text>, /reset ai, /ai on|off, /record start|stop|cancel|status|bind.")
                self._session_log("command_executed", {"action": "help"})
                return

            if t_key in ("επαναφορα_labels", "επαναφορα_label", "realign_labels", "align_labels") or t in ("επαναφορά labels", "επαναφορα labels"):
                try:
                    self.realign_labels_to_grid()
                    self._announce_action_done("Επαναφορά labels", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                except Exception as e:
                    self._announce_action_failed(f"Επαναφορά labels: {e}")
                self._session_log("command_executed", {"action": "realign_labels"})
                return

            if t.startswith("/click"):
                m = re.match(r"^/click\s+([a-z_]+)\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /click <action>")
                    return
                action = str(m.group(1) or "").strip().lower()
                mapping = {
                    "add_radiograph": ("Προσθήκη ακτινογραφίας", getattr(self, "add_image_button", None)),
                    "duplicates": ("Διπλότυπα", getattr(self, "manage_duplicates_button", None)),
                    "analyze": ("Ανάλυση", getattr(self, "analyze_button", None)),
                    "verify": ("Επαλήθευση", getattr(self, "verify_button", None)),
                    "export": ("Εξαγωγή", getattr(self, "export_button", None)),
                    "save_analysis": ("Αποθήκευση ανάλυσης", getattr(self, "save_analysis_button", None)),
                    "clear_analysis": ("Καθαρισμός ανάλυσης", getattr(self, "clear_analysis_button", None)),
                    "history": ("Ιστορικό", getattr(self, "history_button", None)),
                    "toggle_boxes": ("Πλαίσια", getattr(self, "toggle_boxes_button", None)),
                    "center": ("Κεντράρισμα", getattr(self, "center_view_button", None)),
                    "crop": ("Αποκοπή", getattr(self, "crop_button", None)),
                    "grid": ("Πλέγμα", getattr(self, "grid_button", None)),
                    "magic": ("Μαγικό ραβδί", getattr(self, "magic_wand_button", None)),
                    "yolo_seg": ("YOLOv8 Seg", getattr(self, "yolov8_seg_button", None)),
                    "jaw_lines": ("Διαχωριστικές γραμμές", getattr(self, "jaw_lines_button", None)),
                    "auto_fdi": ("Auto FDI", getattr(self, "auto_fdi_checkbox", None)),
                    "lock_layout": ("Κλείδωμα", getattr(self, "lock_layout_checkbox", None)),
                    "calibration": ("Βαθμονόμηση", getattr(self, "calibration_button", None)),
                }
                if action not in mapping:
                    self._append_comm("Σύστημα", "Άγνωστο action. Δοκίμασε: /help")
                    return
                label, widget = mapping[action]
                if widget is None:
                    self._append_comm("Σύστημα", "Το κουμπί δεν είναι διαθέσιμο σε αυτή την οθόνη.")
                    return
                try:
                    if hasattr(widget, "click"):
                        widget.click()
                    elif hasattr(widget, "toggle"):
                        widget.toggle()
                    else:
                        try:
                            widget.setChecked(not bool(widget.isChecked()))
                        except Exception:
                            pass
                    if action in ("analyze", "verify"):
                        self._append_comm("Σύστημα", f"Εκκίνηση: {label}")
                    else:
                        self._announce_action_done(str(label), elapsed_ms=(time.perf_counter() - started) * 1000.0)
                    self._session_log("command_executed", {"action": "click", "target": str(action)})
                    return
                except Exception as e:
                    self._announce_action_failed(f"{label}: {e}")
                    return

            if t.startswith("/ai"):
                m = re.match(r"^/ai\s*(on|off)?\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /ai on ή /ai off")
                    return
                mode = m.group(1)
                if mode == "on":
                    self.comm_ai_enabled = True
                elif mode == "off":
                    self.comm_ai_enabled = False
                else:
                    self.comm_ai_enabled = not bool(getattr(self, "comm_ai_enabled", False))
                try:
                    self.comm_ai_toggle.setChecked(bool(self.comm_ai_enabled))
                except Exception:
                    pass
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                self._announce_action_done("AI mode: ενεργό" if self.comm_ai_enabled else "AI mode: ανενεργό", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "ai_mode", "enabled": bool(self.comm_ai_enabled)})
                return

            if t.startswith("/chat"):
                m = re.match(r"^/chat\s*(on|off)?\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /chat on ή /chat off")
                    return
                mode = m.group(1)
                if mode == "on":
                    self.comm_conversation_enabled = True
                elif mode == "off":
                    self.comm_conversation_enabled = False
                else:
                    self.comm_conversation_enabled = not bool(getattr(self, "comm_conversation_enabled", False))
                try:
                    self.comm_chatty_toggle.setChecked(bool(self.comm_conversation_enabled))
                except Exception:
                    pass
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                self._announce_action_done("Διάλογος: ενεργός" if self.comm_conversation_enabled else "Διάλογος: ανενεργός", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "chat_mode", "enabled": bool(self.comm_conversation_enabled)})
                return

            if t.startswith("/live"):
                m = re.match(r"^/live\s*(on|off)?\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /live on ή /live off")
                    return
                mode = m.group(1)
                if mode == "on":
                    self.comm_ai_stream_enabled = True
                elif mode == "off":
                    self.comm_ai_stream_enabled = False
                else:
                    self.comm_ai_stream_enabled = not bool(getattr(self, "comm_ai_stream_enabled", False))
                try:
                    self.comm_live_toggle.setChecked(bool(self.comm_ai_stream_enabled))
                except Exception:
                    pass
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                self._announce_action_done("Ζωντανά: ενεργό" if self.comm_ai_stream_enabled else "Ζωντανά: ανενεργό", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "live_mode", "enabled": bool(self.comm_ai_stream_enabled)})
                return

            if t.startswith("/memory"):
                m_set = re.match(r"^/memory\s+set\s+(.+)$", raw, flags=re.IGNORECASE)
                if t.strip() == "/memory show":
                    mem = str(getattr(self, "comm_memory_text", "") or "").strip()
                    self._append_comm("Σύστημα", mem if mem else "(Κενή μνήμη)")
                    self._session_log("command_executed", {"action": "memory_show"})
                    return
                if t.strip() == "/memory clear":
                    self.comm_memory_text = ""
                    self._save_viewer_prefs()
                    self._append_comm("Σύστημα", "Καθαρίστηκε η μνήμη.")
                    self._session_log("command_executed", {"action": "memory_clear"})
                    return
                if m_set:
                    txt = str(m_set.group(1) or "").strip()
                    if len(txt) > 2000:
                        txt = txt[:2000]
                    self.comm_memory_text = txt
                    self._save_viewer_prefs()
                    self._append_comm("Σύστημα", "Ενημερώθηκε η μνήμη.")
                    self._session_log("command_executed", {"action": "memory_set", "chars": int(len(txt))})
                    return
                self._append_comm("Σύστημα", "Χρήση: /memory show | /memory clear | /memory set <κείμενο>")
                return

            if t.startswith("/pmemory"):
                key = self._get_patient_key()
                if key == "general":
                    self._append_comm("Σύστημα", "Δεν υπάρχει ενεργός ασθενής για μνήμη ασθενή.")
                    return
                m_set = re.match(r"^/pmemory\s+set\s+(.+)$", raw, flags=re.IGNORECASE)
                by_patient = getattr(self, "comm_patient_memory", None)
                if not isinstance(by_patient, dict):
                    by_patient = {}
                    self.comm_patient_memory = by_patient
                if t.strip() == "/pmemory show":
                    mem = str(by_patient.get(key) or "").strip()
                    self._append_comm("Σύστημα", mem if mem else "(Κενή μνήμη ασθενή)")
                    self._session_log("command_executed", {"action": "pmemory_show"})
                    return
                if t.strip() == "/pmemory clear":
                    by_patient[key] = ""
                    self._save_viewer_prefs()
                    self._append_comm("Σύστημα", "Καθαρίστηκε η μνήμη ασθενή.")
                    self._session_log("command_executed", {"action": "pmemory_clear"})
                    return
                if m_set:
                    txt = str(m_set.group(1) or "").strip()
                    if len(txt) > 2000:
                        txt = txt[:2000]
                    by_patient[key] = txt
                    self._save_viewer_prefs()
                    self._append_comm("Σύστημα", "Ενημερώθηκε η μνήμη ασθενή.")
                    self._session_log("command_executed", {"action": "pmemory_set", "chars": int(len(txt))})
                    return
                self._append_comm("Σύστημα", "Χρήση: /pmemory show | /pmemory clear | /pmemory set <κείμενο>")
                return

            if t.strip() == "/reset ai":
                key = self._get_patient_key()
                self._ai_messages = []
                try:
                    pmsg = getattr(self, "comm_patient_ai_messages", None)
                    if key != "general" and isinstance(pmsg, dict):
                        pmsg[key] = []
                except Exception:
                    pass
                self._ai_pending_command = ""
                self._ai_pending_origin_phrase = ""
                try:
                    self._stop_ai_stream()
                except Exception:
                    pass
                try:
                    if hasattr(self, "ai_live_widget"):
                        self.ai_live_widget.setVisible(False)
                    if hasattr(self, "ai_live_label"):
                        self.ai_live_label.setText("")
                except Exception:
                    pass
                self._save_viewer_prefs()
                self._append_comm("Σύστημα", "Καθαρίστηκε το AI ιστορικό διαλόγου.")
                self._session_log("command_executed", {"action": "reset_ai"})
                return

            if t in ("/run", "εκτέλεση"):
                cmd = str(getattr(self, "_ai_pending_command", "") or "").strip()
                if not cmd:
                    self._append_comm("Σύστημα", "Δεν υπάρχει εκκρεμής AI εντολή.")
                    self._update_ai_pending_ui()
                    return
                origin = str(getattr(self, "_ai_pending_origin_phrase", "") or "").strip()
                self._ai_pending_command = ""
                self._ai_pending_origin_phrase = ""
                self._update_ai_pending_ui()
                self._append_comm("Σύστημα", f"Εκτέλεση: {cmd}")
                self._session_log("command_executed", {"action": "ai_run", "command": cmd})
                self._handle_text_command(cmd)
                self._maybe_queue_learn_alias(origin, cmd)
                return

            if t in ("/cancel", "άκυρο", "ακύρωση"):
                if str(getattr(self, "_ai_pending_command", "") or "").strip():
                    self._ai_pending_command = ""
                    self._ai_pending_origin_phrase = ""
                    self._append_comm("Σύστημα", "Ακυρώθηκε η εκκρεμής AI εντολή.")
                    self._session_log("command_executed", {"action": "ai_cancel"})
                else:
                    self._append_comm("Σύστημα", "Δεν υπάρχει εκκρεμής AI εντολή.")
                self._update_ai_pending_ui()
                self._learn_pending_phrase = ""
                self._learn_pending_command = ""
                self._update_learn_pending_ui()
                return

            if t in ("ακυρο", "ακυρωση", "cancel", "stop"):
                if str(getattr(self, "_ai_pending_command", "") or "").strip():
                    self._ai_pending_command = ""
                    self._ai_pending_origin_phrase = ""
                    self._append_comm("Σύστημα", "Ακυρώθηκε η εκκρεμής AI εντολή.")
                    self._session_log("command_executed", {"action": "ai_cancel"})
                else:
                    self._append_comm("Σύστημα", "Δεν υπάρχει εκκρεμής AI εντολή.")
                self._update_ai_pending_ui()
                self._learn_pending_phrase = ""
                self._learn_pending_command = ""
                self._update_learn_pending_ui()
                return

            if t.startswith("/learn"):
                m = re.match(r"^/learn\s*(yes|no|auto)?(?:\s+(on|off))?\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /learn yes | /learn no | /learn auto on|off")
                    return
                choice = m.group(1)
                auto_mode = m.group(2)
                if choice == "yes":
                    self._accept_learn_alias()
                elif choice == "no":
                    self._reject_learn_alias()
                elif choice == "auto":
                    if auto_mode == "on":
                        self.comm_learning_auto_accept = True
                    elif auto_mode == "off":
                        self.comm_learning_auto_accept = False
                    else:
                        self.comm_learning_auto_accept = not bool(getattr(self, "comm_learning_auto_accept", False))
                    try:
                        self._save_viewer_prefs()
                    except Exception:
                        self._schedule_prefs_save()
                    self._append_comm("Σύστημα", "Μάθηση αυτόματη: ενεργή" if bool(getattr(self, "comm_learning_auto_accept", False)) else "Μάθηση αυτόματη: ανενεργή")
                else:
                    phrase = str(getattr(self, "_learn_pending_phrase", "") or "").strip()
                    cmd = str(getattr(self, "_learn_pending_command", "") or "").strip()
                    if phrase and cmd:
                        self._append_comm("Σύστημα", f"Εκκρεμής μάθηση: {phrase} → {cmd} (γράψε /learn yes ή /learn no)")
                    else:
                        self._append_comm("Σύστημα", "Δεν υπάρχει εκκρεμής μάθηση.")
                return

            if t.startswith("/alias "):
                m_add = re.match(r"^/alias\s+add\s+(.+?)\s*=\s*(.+?)\s*$", raw, flags=re.IGNORECASE)
                m_list = re.match(r"^/alias\s+list\s*$", t)
                m_remove = re.match(r"^/alias\s+remove\s+(.+?)\s*$", raw, flags=re.IGNORECASE)
                m_presets = re.match(r"^/alias\s+presets\s*$", t)
                if m_add:
                    phrase = self._normalize_phrase_key(m_add.group(1))
                    canon = m_add.group(2).strip()
                    if not phrase or not canon:
                        self._append_comm("Σύστημα", "Χρήση: /alias add <φράση>=<εντολή>")
                        return
                    self.comm_aliases[phrase] = canon
                    self._save_viewer_prefs()
                    self._append_comm("Σύστημα", f"Alias προστέθηκε: {phrase} → {canon}")
                    self._session_log("command_executed", {"action": "alias_add", "phrase": phrase, "canon": canon})
                    return
                if m_presets:
                    self._install_default_aliases()
                    return
                if m_list:
                    items = [f"{k} → {v}" for k, v in sorted((self.comm_aliases or {}).items())]
                    self._append_comm("Σύστημα", ("Aliases:\n" + "\n".join(items)) if items else "Δεν υπάρχουν aliases.")
                    self._session_log("command_executed", {"action": "alias_list"})
                    return
                if m_remove:
                    phrase = self._normalize_phrase_key(m_remove.group(1))
                    if phrase in (self.comm_aliases or {}):
                        del self.comm_aliases[phrase]
                        self._save_viewer_prefs()
                        self._append_comm("Σύστημα", f"Alias αφαιρέθηκε: {phrase}")
                        self._session_log("command_executed", {"action": "alias_remove", "phrase": phrase})
                    else:
                        self._append_comm("Σύστημα", "Δεν βρέθηκε τέτοιο alias.")
                    return
                self._append_comm("Σύστημα", "Χρήση: /alias add <φράση>=<εντολή>, /alias list, /alias remove <φράση>, /alias presets")
                return

            if t.startswith("/teach "):
                phrase = raw[len("/teach "):].strip()
                if not phrase:
                    self._append_comm("Σύστημα", "Χρήση: /teach <φράση> (μετά κάνε βήματα και γράψε /record stop)")
                    return
                try:
                    self._macro_recording_bind_phrase = phrase
                except Exception:
                    self._macro_recording_bind_phrase = ""
                self._start_macro_recording()
                self._append_comm("Σύστημα", f"Θα μάθω τη διαδικασία ως: «{phrase}». Καταγράφονται μόνο εντολές/κουμπιά (όχι χειροκίνητες μετακινήσεις/διορθώσεις). Όταν τελειώσεις γράψε /record stop.")
                return

            if t.startswith("/macro "):
                if not isinstance(getattr(self, "comm_macros", None), dict):
                    self.comm_macros = {}
                m_add = re.match(r"^/macro\s+add\s+(.+?)\s*=\s*(.+?)\s*$", raw, flags=re.IGNORECASE)
                m_list = re.match(r"^/macro\s+list\s*$", t)
                m_remove = re.match(r"^/macro\s+remove\s+(.+?)\s*$", raw, flags=re.IGNORECASE)
                m_run = re.match(r"^/macro\s+run\s+(.+?)\s*$", raw, flags=re.IGNORECASE)
                if m_add:
                    name = str(m_add.group(1) or "").strip()
                    seq = str(m_add.group(2) or "").strip()
                    parts = [p.strip() for p in re.split(r"\s*;\s*", seq) if p.strip()]
                    cmds = []
                    for p in parts:
                        if self._is_allowed_ai_command(p):
                            cmds.append(p)
                    if not name or not cmds:
                        self._append_comm("Σύστημα", "Χρήση: /macro add <όνομα>=<εντολή1>; <εντολή2>; ... (μόνο επιτρεπόμενες εντολές)")
                        return
                    self.comm_macros[name] = cmds[:12]
                    self._save_viewer_prefs()
                    self._append_comm("Σύστημα", f"Macro προστέθηκε: {name} ({len(cmds)} βήματα)")
                    self._session_log("command_executed", {"action": "macro_add", "name": name, "steps": int(len(cmds))})
                    return
                if m_list:
                    items = []
                    for k, v in sorted((self.comm_macros or {}).items()):
                        steps = v if isinstance(v, list) else []
                        items.append(f"{k} → " + "; ".join([str(x) for x in steps]))
                    self._append_comm("Σύστημα", ("Macros:\n" + "\n".join(items)) if items else "Δεν υπάρχουν macros.")
                    self._session_log("command_executed", {"action": "macro_list"})
                    return
                if m_remove:
                    name = str(m_remove.group(1) or "").strip()
                    if name in (self.comm_macros or {}):
                        del self.comm_macros[name]
                        self._save_viewer_prefs()
                        self._append_comm("Σύστημα", f"Macro αφαιρέθηκε: {name}")
                        self._session_log("command_executed", {"action": "macro_remove", "name": name})
                    else:
                        self._append_comm("Σύστημα", "Δεν βρέθηκε τέτοιο macro.")
                    return
                if m_run:
                    name = str(m_run.group(1) or "").strip()
                    steps = (self.comm_macros or {}).get(name)
                    if not isinstance(steps, list) or not steps:
                        self._append_comm("Σύστημα", "Δεν βρέθηκε τέτοιο macro.")
                        return
                    self._append_comm("Σύστημα", f"Εκτέλεση macro: {name}")
                    for step in steps[:12]:
                        if self._is_allowed_ai_command(step):
                            self._record_macro_step(str(step))
                            self._handle_text_command(str(step))
                    self._session_log("command_executed", {"action": "macro_run", "name": name, "steps": int(len(steps))})
                    return
                self._append_comm("Σύστημα", "Χρήση: /macro add <όνομα>=<cmd1>; <cmd2> | /macro list | /macro remove <όνομα> | /macro run <όνομα>")
                return

            if t.startswith("/record"):
                m_start = re.match(r"^/record\s+start(?:\s+(.+?))?\s*$", raw, flags=re.IGNORECASE)
                m_stop = re.match(r"^/record\s+stop\s*$", t)
                m_cancel = re.match(r"^/record\s+cancel\s*$", t)
                m_status = re.match(r"^/record\s+status\s*$", t)
                m_bind = re.match(r"^/record\s+bind\s+(.+?)\s*$", raw, flags=re.IGNORECASE)
                if m_start:
                    name = str(m_start.group(1) or "").strip()
                    self._start_macro_recording(name if name else None)
                    return
                if m_stop:
                    self._stop_macro_recording(save=True)
                    return
                if m_cancel:
                    self._stop_macro_recording(save=False)
                    return
                if m_status:
                    active = bool(getattr(self, "_macro_recording_active", False))
                    nm = str(getattr(self, "_macro_recording_name", "") or "").strip()
                    steps = getattr(self, "_macro_recording_steps", None)
                    nsteps = int(len(steps)) if isinstance(steps, list) else 0
                    self._append_comm("Σύστημα", f"Καταγραφή: {'ενεργή' if active else 'ανενεργή'} | macro: {nm or '-'} | βήματα: {nsteps}")
                    return
                if m_bind:
                    self._bind_last_recorded_macro(str(m_bind.group(1) or ""))
                    return
                self._append_comm("Σύστημα", "Χρήση: /record start [όνομα] | /record stop | /record cancel | /record status | /record bind <φράση>")
                return

            if t.startswith("/notify"):
                m_train = re.match(r"^/notify\s+training\s*(on|off)?\s*$", t)
                if not m_train:
                    self._append_comm("Σύστημα", "Χρήση: /notify training on|off")
                    return
                choice = m_train.group(1)
                if choice == "on":
                    self._notify_training_finish = True
                elif choice == "off":
                    self._notify_training_finish = False
                else:
                    self._notify_training_finish = not bool(getattr(self, "_notify_training_finish", False))
                self._announce_action_done("Ειδοποίηση εκπαίδευσης: ενεργή" if bool(getattr(self, "_notify_training_finish", False)) else "Ειδοποίηση εκπαίδευσης: ανενεργή", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                return
            
            if t.startswith("/auto_train"):
                m = re.match(r"^/auto_train\s*(on|off|status)?\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /auto_train on|off|status")
                    return
                mode = str(m.group(1) or "").strip().lower()
                if mode == "status":
                    self._append_comm("Σύστημα", "Auto-train μετά από ανάλυση: ενεργό" if bool(getattr(self, "auto_train_after_analysis", True)) else "Auto-train μετά από ανάλυση: ανενεργό")
                    return
                if mode == "on":
                    self.auto_train_after_analysis = True
                elif mode == "off":
                    self.auto_train_after_analysis = False
                else:
                    self.auto_train_after_analysis = not bool(getattr(self, "auto_train_after_analysis", True))
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                self._announce_action_done("Auto-train μετά από ανάλυση: ενεργό" if bool(getattr(self, "auto_train_after_analysis", True)) else "Auto-train μετά από ανάλυση: ανενεργό", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                return

            try:
                if ("παρακολουθ" in t_key or "record" in t) and ("κινησ" in t_key or "ενεργει" in t_key or "actions" in t):
                    self._start_macro_recording()
                    return
            except Exception:
                pass
            try:
                if ("ενημερω" in t_key or "notify" in t) and ("εκπαιδευ" in t_key or "training" in t) and ("ολοκληρ" in t_key or "finish" in t or "done" in t):
                    self._notify_training_finish = True
                    self._announce_action_done("Θα σε ενημερώσω όταν ολοκληρωθεί η εκπαίδευση", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                    return
            except Exception:
                pass

            if t in ("/suggest", "πρόταση", "προτάσεις"):
                suggestions = self._compute_suggestions()
                if suggestions:
                    self._append_comm("Σύστημα", "Προτάσεις: " + "; ".join(suggestions))
                else:
                    self._append_comm("Σύστημα", "Δεν υπάρχουν συγκεκριμένες προτάσεις αυτή τη στιγμή.")
                self._session_log("command_executed", {"action": "suggest"})
                return

            if t.startswith("/set "):
                m = re.match(r"^/set\s+(brightness|contrast)\s+(-?\d+)\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /set brightness <−100..100> ή /set contrast <0..200>")
                    return
                key = m.group(1)
                val = int(m.group(2))
                if key == "brightness":
                    val = max(-100, min(100, val))
                    self.brightness_slider.setValue(val)
                    self._announce_action_done(f"Φωτισμός: {val}", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                    self._session_log("command_executed", {"action": "set_brightness", "value": val})
                    return
                val = max(0, min(200, val))
                self.contrast_slider.setValue(val)
                self._announce_action_done(f"Αντίθεση: {val}", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "set_contrast", "value": val})
                return

            if t.startswith("/goto "):
                m = re.match(r"^/goto\s+(\d+)\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /goto <αριθμός> (1-based)")
                    return
                idx = int(m.group(1)) - 1
                if self.image_list_widget.count() <= 0:
                    self._append_comm("Σύστημα", "Δεν υπάρχουν εικόνες.")
                    return
                idx = max(0, min(self.image_list_widget.count() - 1, idx))
                self.image_list_widget.setCurrentRow(idx)
                it = self.image_list_widget.currentItem()
                if it:
                    self.display_selected_image(it)
                self._announce_action_done(f"Μετάβαση στην εικόνα #{idx + 1}", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "goto_image", "index": idx})
                return

            if t.startswith("/spot "):
                m = re.match(r"^/spot\s+(\d+)\s*$", t)
                if not m:
                    self._append_comm("Σύστημα", "Χρήση: /spot <αριθμός> (1-based)")
                    return
                idx = int(m.group(1))
                if not (getattr(self, "change_hotspots", None) or []):
                    self._append_comm("Σύστημα", "Δεν υπάρχουν διαθέσιμα hotspots αλλαγών.")
                    return
                self.jump_to_change_hotspot(idx)
                self._announce_action_done(f"Hotspot αλλαγών #{idx}", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "goto_hotspot", "index": idx})
                return

            if t.startswith("/open "):
                query = raw[6:].strip()
                if not query:
                    self._append_comm("Σύστημα", "Χρήση: /open <μέρος_ονόματος>")
                    return
                best_idx = -1
                q = query.lower()
                for i in range(self.image_list_widget.count()):
                    it = self.image_list_widget.item(i)
                    name = str(it.text() or "").lower()
                    if q in name:
                        best_idx = i
                        break
                if best_idx < 0:
                    self._append_comm("Σύστημα", "Δεν βρέθηκε εικόνα με αυτό το όνομα.")
                    return
                self.image_list_widget.setCurrentRow(best_idx)
                it = self.image_list_widget.currentItem()
                if it:
                    self.display_selected_image(it)
                self._announce_action_done(f"Άνοιξε: {self.image_list_widget.currentItem().text()}", elapsed_ms=(time.perf_counter() - started) * 1000.0)
                self._session_log("command_executed", {"action": "open_image", "query": query, "index": best_idx})
                return

            if t in ("/templates", "/template", "πρότυπα"):
                names = sorted([str(k) for k in (self.comm_templates or {}).keys() if str(k).strip()])
                if not names:
                    self._append_comm("Σύστημα", "Δεν υπάρχουν αποθηκευμένα πρότυπα.")
                else:
                    self._append_comm("Σύστημα", "Πρότυπα: " + ", ".join(names))
                self._session_log("command_executed", {"action": "list_templates"})
                return

            if t.startswith("/template "):
                name = raw[len("/template "):].strip()
                if not name:
                    self._append_comm("Σύστημα", "Χρήση: /template <όνομα>")
                    return
                payload = str((self.comm_templates or {}).get(name) or "").strip()
                if not payload:
                    self._append_comm("Σύστημα", "Δεν βρέθηκε τέτοιο πρότυπο.")
                    return
                self.comm_last_template = name
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                self._append_comm("Χρήστης", payload)
                self._handle_text_command(payload)
                return

            if "κεντράρ" in t or "center" in t or "κεντραρ" in t_key:
                self._session_log("command_executed", {"action": "center_view"})
                self.center_view()
                self._append_comm("Σύστημα", "Κεντράρισμα πανοραμικής.")
                return
            if "πλέγμα" in t or "grid" in t or "πλεγμα" in t_key:
                self._session_log("command_executed", {"action": "toggle_grid"})
                self.grid_button.toggle()
                self.toggle_grid_mode()
                self._append_comm("Σύστημα", "Εναλλαγή πλέγματος.")
                return
            if "μαγικό" in t or "wand" in t or "μαγικο" in t_key:
                self._session_log("command_executed", {"action": "toggle_magic_wand"})
                self.magic_wand_button.toggle()
                self.toggle_magic_wand_mode()
                self._append_comm("Σύστημα", "Εναλλαγή μαγικού ραβδιού.")
                return
            if (("προσθήκ" in t or "προσθηκ" in t_key) and ("ακτινο" in t or "ακτινο" in t_key)) or ("add" in t and "radio" in t):
                if self._maybe_request_command_confirmation(
                    "add_radiograph",
                    "προσθήκη ακτινογραφίας",
                    "Θέλετε να ανοίξω επιλογή αρχείου για προσθήκη ακτινογραφίας;",
                    "Θα ανοίξει παράθυρο επιλογής αρχείου (DICOM/εικόνα) και θα γίνει εισαγωγή στην καρτέλα ασθενή.",
                ):
                    return
                self._session_log("command_executed", {"action": "add_radiograph"})
                self.add_new_radiograph()
                self._append_comm("Σύστημα", "Άνοιγμα επιλογής αρχείου για προσθήκη ακτινογραφίας.")
                return
            if "επαλήθευση" in t or "verify" in t or "επαληθευση" in t_key:
                if self._maybe_request_command_confirmation(
                    "verify",
                    "επαλήθευση",
                    "Θέλετε να ξεκινήσει επαλήθευση επανάλυσης στην τρέχουσα εικόνα;",
                    "Θα τρέξω επανάλυση και θα συγκρίνω με την τελευταία αποθηκευμένη ανάλυση.",
                ):
                    return
                self._session_log("command_executed", {"action": "verify"})
                self.verify_reanalysis()
                self._append_comm("Σύστημα", "Εκκίνηση επαλήθευσης επανάλυσης.")
                return
            if ("μεταφορ" in t or "transfer" in t or "μεταφορ" in t_key) and ("προηγ" in t or "previous" in t or "προηγ" in t_key):
                if self._maybe_request_command_confirmation(
                    "transfer_prev",
                    "μεταφορά προηγούμενης",
                    "Θέλετε να μεταφέρω την προηγούμενη αποθηκευμένη ανάλυση στην τρέχουσα εικόνα;",
                    "Θα επιχειρήσω ευθυγράμμιση εικόνων και θα μεταφέρω τα πλαίσια/FDI ως αρχικό draft για διόρθωση.",
                ):
                    return
                self._session_log("command_executed", {"action": "transfer_prev"})
                self.transfer_previous_analysis()
                self._append_comm("Σύστημα", "Μεταφορά προηγούμενης ανάλυσης.")
                return
            if ("αλλαγ" in t or "changes" in t or "heatmap" in t or "αλλαγ" in t_key):
                if self._maybe_request_command_confirmation(
                    "changes_overlay",
                    "αλλαγές",
                    "Θέλετε να εμφανίσω/κρύψω heatmap αλλαγών σε σχέση με προηγούμενη εικόνα;",
                    "Θα υπολογίσω διαφορές μετά από ευθυγράμμιση και θα τις δείξω ως χρωματικό overlay.",
                ):
                    return
                try:
                    if hasattr(self, "change_overlay_button") and self.change_overlay_button is not None:
                        self.change_overlay_button.setChecked(not bool(self.change_overlay_button.isChecked()))
                    self.toggle_change_overlay()
                except Exception:
                    pass
                self._session_log("command_executed", {"action": "changes_overlay"})
                self._append_comm("Σύστημα", "Αλλαγές: ενημερώθηκε.")
                return
            if ("εκπαιδευ" in t or "εκπαίδευ" in t or "εκπαιδευ" in t_key) and ("μοντελ" in t or "μοντέλ" in t or "μοντελ" in t_key or "model" in t or "train" in t):
                if self._maybe_request_command_confirmation(
                    "train_model",
                    "εκπαίδευση μοντέλου",
                    "Θέλετε να ξεκινήσει εκπαίδευση μοντέλου τώρα;",
                    "Θα γίνει έλεγχος dataset και μετά θα ξεκινήσει αυτόματη εκπαίδευση (toothdet). Αν ήδη τρέχει εκπαίδευση, θα μπει σε ουρά.",
                ):
                    return
                self._session_log("command_executed", {"action": "train_model"})
                self.on_training_triggered("Ξεκινάει αυτόματη εκπαίδευση τώρα…")
                return
            if "εξαγωγ" in t or "export" in t:
                if self._maybe_request_command_confirmation(
                    "export",
                    "εξαγωγή",
                    "Θέλετε να κάνω εξαγωγή των αποτελεσμάτων σε αρχείο κειμένου;",
                    "Θα ανοίξει παράθυρο αποθήκευσης και θα γραφτεί αρχείο .txt με τα τρέχοντα αποτελέσματα.",
                ):
                    return
                self._session_log("command_executed", {"action": "export"})
                self.export_results_to_text()
                self._append_comm("Σύστημα", "Εξαγωγή αποτελεσμάτων.")
                return
            if ("αποθήκευση" in t and "ανάλυ" in t) or ("αποθηκευση" in t_key and "αναλυ" in t_key) or ("save" in t and "analysis" in t):
                if self._maybe_request_command_confirmation(
                    "save_analysis",
                    "αποθήκευση ανάλυσης",
                    "Θέλετε να αποθηκεύσω τα αποτελέσματα της τρέχουσας ανάλυσης;",
                    "Θα αποθηκεύσω τα τρέχοντα πλαίσια/labels και τις σημειώσεις σε αρχείο ανάλυσης (JSON) για μελλοντική χρήση (Ιστορικό/Επαλήθευση).",
                ):
                    return
                self._session_log("command_executed", {"action": "save_analysis"})
                self.save_edited_results()
                self._append_comm("Σύστημα", "Αποθήκευση ανάλυσης.")
                return
            if ("καθαρισ" in t and "ανάλυ" in t) or ("καθαρισ" in t_key and "αναλυ" in t_key) or ("clear" in t and "analysis" in t):
                if self._maybe_request_command_confirmation(
                    "clear_analysis",
                    "καθαρισμός ανάλυσης",
                    "Θέλετε να καθαρίσω την τρέχουσα ανάλυση από την εικόνα;",
                    "Θα αφαιρέσω τα πλαίσια/labels της ανάλυσης από τη σκηνή και θα μηδενίσω τα τρέχοντα αποτελέσματα.",
                ):
                    return
                self._session_log("command_executed", {"action": "clear_analysis"})
                self.clear_analysis()
                self._append_comm("Σύστημα", "Καθαρισμός ανάλυσης.")
                return
            if "ανάλυση" in t or "analyze" in t or "αναλυση" in t_key:
                if not getattr(self, "current_image_path", None):
                    self._announce_action_failed("Ανάλυση AI: δεν έχει επιλεγεί εικόνα")
                    return
                if self._maybe_request_command_confirmation(
                    "analyze",
                    "ανάλυση",
                    "Θέλετε να ξεκινήσει νέα ανάλυση AI για την τρέχουσα εικόνα;",
                    "Θα τρέξω νέο inference και θα ενημερώσω τα πλαίσια/αποτελέσματα στην οθόνη.",
                ):
                    return
                self._session_log("command_executed", {"action": "analyze"})
                self.analyze_image_with_ai()
                self._append_comm("Σύστημα", "Εκκίνηση ανάλυσης AI.")
                return
            if "διπλοτυπ" in t or "duplicate" in t or "διπλοτυπ" in t_key:
                if self._maybe_request_command_confirmation(
                    "duplicates",
                    "διπλότυπα",
                    "Θέλετε να ανοίξω τη διαχείριση διπλότυπων εικόνων;",
                    "Θα εμφανιστεί παράθυρο για επιλογή/διαχείριση διπλοτύπων.",
                ):
                    return
                self._session_log("command_executed", {"action": "duplicates"})
                self.manage_duplicate_images()
                self._append_comm("Σύστημα", "Άνοιγμα διαχείρισης διπλοτύπων.")
                return
            if "ιστορ" in t or "history" in t or "ιστορ" in t_key:
                if self._maybe_request_command_confirmation(
                    "history",
                    "ιστορικό",
                    "Θέλετε να ανοίξω το ιστορικό;",
                    "Θα εμφανιστεί παράθυρο ιστορικού με προηγούμενες αναλύσεις/ενέργειες.",
                ):
                    return
                self._session_log("command_executed", {"action": "history"})
                self.show_history_dialog()
                self._append_comm("Σύστημα", "Άνοιγμα ιστορικού.")
                return
            if "yolo" in t:
                self._session_log("command_executed", {"action": "yolo_seg"})
                self.run_yolov8_segmentation()
                self._append_comm("Σύστημα", "Εκτέλεση YOLOv8 Seg.")
                return
            if "γραμμ" in t or "γραμμ" in t_key:
                self._session_log("command_executed", {"action": "jaw_lines"})
                self.toggle_jaw_lines()
                self._append_comm("Σύστημα", "Εναλλαγή διαχωριστικών γραμμών.")
                return
            if ("auto" in t and "fdi" in t) or ("fdi" in t and "auto" in t) or ("auto" in t_key and "fdi" in t_key):
                self._session_log("command_executed", {"action": "auto_fdi"})
                try:
                    self.auto_fdi_checkbox.toggle()
                except Exception:
                    pass
                try:
                    self.toggle_auto_fdi()
                except Exception:
                    pass
                self._append_comm("Σύστημα", "Εναλλαγή Auto FDI.")
                return
            if "κλειδω" in t or "lock" in t or "κλειδω" in t_key:
                self._session_log("command_executed", {"action": "lock_layout"})
                try:
                    self.lock_layout_checkbox.toggle()
                except Exception:
                    pass
                try:
                    self.toggle_layout_lock()
                except Exception:
                    pass
                self._append_comm("Σύστημα", "Εναλλαγή κλειδώματος πλέγματος/γραμμών.")
                return
            if "αποκοπή" in t or "crop" in t or "αποκοπη" in t_key:
                self._session_log("command_executed", {"action": "toggle_crop"})
                self.crop_button.toggle()
                self.toggle_crop_mode()
                self._append_comm("Σύστημα", "Εναλλαγή αποκοπής.")
                return
            if "βαθμονόμηση" in t or "calib" in t or "ruler" in t or "βαθμονομηση" in t_key:
                self._session_log("command_executed", {"action": "toggle_calibration"})
                self.calibration_button.toggle()
                self.toggle_calibration_mode()
                self._append_comm("Σύστημα", "Εναλλαγή βαθμονόμησης.")
                return
            if "επόμεν" in t or "next" in t or "επομεν" in t_key:
                self._session_log("command_executed", {"action": "next_image"})
                self._select_next_image()
                self._append_comm("Σύστημα", "Μετάβαση στην επόμενη εικόνα.")
                return
            if "προηγ" in t or "prev" in t:
                self._session_log("command_executed", {"action": "prev_image"})
                self._select_prev_image()
                self._append_comm("Σύστημα", "Μετάβαση στην προηγούμενη εικόνα.")
                return
            if "πλαίσι" in t or "boxes" in t or "πλαισι" in t_key:
                self._session_log("command_executed", {"action": "toggle_boxes"})
                self.toggle_box_visibility()
                self._append_comm("Σύστημα", "Εναλλαγή πλαισίων.")
                return
            try:
                base = [x for x in (self._comm_known_commands or []) if "<" not in str(x) and not str(x).startswith("/alias")]
                base = [x for x in base if x not in ("/run", "/cancel", "/learn yes", "/learn no", "/chat on", "/chat off", "/live on", "/live off", "/memory show", "/memory clear", "/reset ai", "/pmemory show", "/pmemory clear")]
                cand = difflib.get_close_matches(t, [str(x).lower() for x in base], n=1, cutoff=0.65)
                if cand:
                    chosen = base[[str(x).lower() for x in base].index(cand[0])]
                    self._maybe_queue_learn_alias(raw, str(chosen))
            except Exception:
                pass
            self._append_comm("Σύστημα", "Δεν αναγνωρίστηκε εντολή. Λέξεις-κλειδιά: κεντράρισμα, πλέγμα, μαγικό, ανάλυση, αποκοπή, βαθμονόμηση, επόμενη, προηγούμενη, πλαίσια.")
        except Exception as e:
            try:
                self._append_comm("Σύστημα", f"Σφάλμα: {e}")
            except Exception:
                pass
        finally:
            try:
                elapsed_ms = (time.perf_counter() - started) * 1000.0
                self._session_log("command_latency", {"ms": float(elapsed_ms)})
            except Exception:
                pass

    def _compute_suggestions(self):
        s = []
        try:
            if not self.current_image_path:
                s.append("/open <όνομα> για φόρτωση εικόνας")
            else:
                if not getattr(self, "analysis_results", None):
                    s.append("ανάλυση για αποτελέσματα AI")
                if not getattr(self, "grid_active", False):
                    s.append("πλέγμα για υποβοήθηση θέσεων/πυκνότητας")
                if getattr(self, "is_calibrating", False):
                    s.append("βαθμονόμηση: ολοκλήρωσε ή απενεργοποίησε")
                base = os.path.splitext(self.current_image_path)[0]
                json_path = base + "_analysis.json"
                if os.path.exists(json_path):
                    s.append("επαλήθευση επανάλυσης για συνέπεια")
            if hasattr(self, "training_worker") and self.training_worker:
                s.append("παρακολούθηση εκπαίδευσης: ανασκόπηση logs/metrics")
            if isinstance(getattr(self, "_auto_train_data_stats", None), dict) and not self._auto_train_data_stats.get("ok", True):
                s.append("βελτίωσε dataset πριν εκπαίδευση")
            s.append("/set brightness <…> ή /set contrast <…>")
        except Exception:
            pass
        # Deduplicate while preserving order
        seen = set()
        out = []
        for x in s:
            if x not in seen:
                out.append(x)
                seen.add(x)
        return out

    def _select_next_image(self):
        row = self.image_list_widget.currentRow()
        if row < 0:
            row = 0
        else:
            row = min(self.image_list_widget.count() - 1, row + 1)
        if self.image_list_widget.count() > 0:
            self.image_list_widget.setCurrentRow(row)
            it = self.image_list_widget.currentItem()
            if it:
                self.display_selected_image(it)

    def _select_prev_image(self):
        row = self.image_list_widget.currentRow()
        if row < 0:
            row = 0
        else:
            row = max(0, row - 1)
        if self.image_list_widget.count() > 0:
            self.image_list_widget.setCurrentRow(row)
            it = self.image_list_widget.currentItem()
            if it:
                self.display_selected_image(it)
    def load_images_from_directory(self):
        self.image_list_widget.clear()
        if not self.radiograph_path or not os.path.isdir(self.radiograph_path):
            return
            
        extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.dcm', '.tif', '.tiff', '.jfif'}
        try:
            files = sorted([f for f in os.listdir(self.radiograph_path) 
                            if os.path.splitext(f)[1].lower() in extensions])
            for f in files:
                full_path = os.path.join(self.radiograph_path, f)
                item = QListWidgetItem(f)
                item.setData(Qt.ItemDataRole.UserRole, full_path)
                self.image_list_widget.addItem(item)
        except Exception as e:
            print(f"Error loading images: {e}")

    def _get_patient_key(self) -> str:
        try:
            pid = getattr(self, "origin_patient_id", None)
            if pid is None:
                return "general"
            s = str(pid).strip()
            return s if s else "general"
        except Exception:
            return "general"

    def _viewer_prefs_path(self):
        settings_dir = Path("data/settings")
        settings_dir.mkdir(parents=True, exist_ok=True)
        return settings_dir / "radiograph_viewer_prefs.json"

    def _model_map50(self, model_path: str):
        p = str(model_path or "").strip()
        if not p:
            return None
        meta_path = p + ".json"
        if not os.path.exists(meta_path):
            return None
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                meta = json.load(f) or {}
        except Exception:
            return None
        m = meta.get("metrics") if isinstance(meta, dict) else None
        if not isinstance(m, dict):
            return None
        v = m.get("metrics/mAP50(B)")
        try:
            return float(v)
        except Exception:
            return None

    def _toothdet_model_usable(self, model_path: str) -> bool:
        try:
            p = str(model_path or "").strip()
            if not p or not os.path.exists(p):
                return False
            mp = self._model_map50(p)
            if mp is None:
                return True
            return float(mp) >= 0.008
        except Exception:
            return False

    def _ensure_radiograph_dir(self) -> bool:
        try:
            cur = getattr(self, "radiograph_path", None)
            if cur and os.path.isdir(str(cur)):
                return True
        except Exception:
            pass
        base = ""
        try:
            base = os.path.join(str(getattr(self, "project_root", "") or ""), "data", "radiographs")
        except Exception:
            base = ""
        if not base:
            try:
                base = os.path.join(str(Path(__file__).resolve().parents[2]), "data", "radiographs")
            except Exception:
                base = ""
        pid = str(getattr(self, "origin_patient_id", "") or "").strip()
        if pid:
            target = os.path.join(base, pid) if base else ""
        else:
            target = os.path.join(base, "general") if base else ""
        if not target:
            return False
        try:
            os.makedirs(target, exist_ok=True)
        except Exception:
            return False
        try:
            self.radiograph_path = target
        except Exception:
            return False
        try:
            self._save_viewer_prefs()
        except Exception:
            pass
        try:
            if hasattr(self, "image_list_widget") and self.image_list_widget is not None:
                self.load_images_from_directory()
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", f"Ορίστηκε φάκελος ακτινογραφιών: {target}")
        except Exception:
            pass
        return True

    def _record_macro_step(self, cmd: str):
        try:
            if not bool(getattr(self, "_macro_recording_active", False)):
                return
            c = str(cmd or "").strip()
            if not c:
                return
            low = c.lower()
            if low.startswith("/record"):
                return
            if not self._is_allowed_ai_command(c):
                return
            steps = getattr(self, "_macro_recording_steps", None)
            if not isinstance(steps, list):
                steps = []
                self._macro_recording_steps = steps
            if steps and str(steps[-1]).strip().lower() == low:
                return
            steps.append(c)
            self._macro_recording_steps = steps[-12:]
            try:
                self._session_log("macro_record_step", {"cmd": c})
            except Exception:
                pass
        except Exception:
            pass

    def _blink_ghosts(self):
        """
        Animates any existing ghost items to simulate 'learning'.
        """
        ghosts = []
        try:
            for item in self.scene.items():
                if isinstance(item, EditableRectItem) and getattr(item, 'ghost_item', None):
                     if item.ghost_item.scene(): # Check if still in scene
                        ghosts.append(item.ghost_item)
                elif isinstance(item, EditableTextItem) and getattr(item, 'ghost_item', None):
                     if item.ghost_item.scene():
                        ghosts.append(item.ghost_item)
        except: pass
        
        if not ghosts: return

        self._blink_counter = 0
        self._blink_timer = QTimer(self)
        self._blink_timer.setInterval(200) # Fast blink
        
        def toggle_opacity():
            try:
                self._blink_counter += 1
                is_on = self._blink_counter % 2 == 1
                
                for g in ghosts:
                    if not g.scene(): continue
                    # Store original color if not stored
                    if not hasattr(g, "_orig_ghost_color"):
                         g._orig_ghost_color = g.defaultTextColor()

                    if is_on:
                        g.setOpacity(1.0)
                        g.setDefaultTextColor(QColor(0, 255, 0, 255)) # Green = Learned
                    else:
                        g.setOpacity(0.6)
                        g.setDefaultTextColor(g._orig_ghost_color) # Restore faint original
                
                if self._blink_counter >= 12: # 6 blinks (slightly longer)
                    self._blink_timer.stop()
                    self._blink_timer.deleteLater()
                    # Remove ghosts
                    for g in ghosts:
                        if g.scene(): g.scene().removeItem(g)
                    # Clear references
                    for item in self.scene.items():
                        if isinstance(item, EditableRectItem):
                            item.ghost_item = None
            except Exception as e:
                print(f"Blink error: {e}")
        
        self._blink_timer.timeout.connect(toggle_opacity)
        self._blink_timer.start()

    def _on_save_and_learn_clicked(self):
        """
        Saves analysis without triggering training.
        """
        try:
            self.save_edited_results()

            # Visual feedback of "learning" (Blinking Ghosts)
            self._blink_ghosts()
            self._trace_log("save_and_train_completed")
            
            # WYSIWYG Confirmation
            self.results_text_edit.append("✅ Οι αλλαγές καταχωρήθηκαν για βελτίωση του μοντέλου.")
        except Exception as e:
            self._trace_log("save_and_train_error", {"error": str(e)})
            QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία διαδικασίας: {e}")

    def _start_post_analysis_flow(self):
        try:
            self._trace_log("post_analysis_flow_started")
            # Initialize state variables to safe defaults (legacy support)
            self._post_analysis_waiting_success = False
            self._post_analysis_waiting_missing = False
            self._post_analysis_waiting_corrections = False
            self._post_analysis_waiting_train_confirm = False
            self._post_analysis_expected_missing = []
            self._training_allowed = False
            
            # Enable corrections mode
            try:
                self._set_corrections_mode(True, announce=False)
            except: pass

            if not bool(getattr(self, "post_analysis_popup_enabled", True)):
                self._trace_log("post_analysis_flow_skipped_disabled")
                self.results_text_edit.append("ℹ️ Ο διάλογος επιβεβαίωσης είναι απενεργοποιημένος.")
            
            if bool(getattr(self, "post_analysis_popup_enabled", True)):
                # Step 1: Confirm Tooth Count
                self._trace_log("post_analysis_dialog_count_shown")
                reply_count = QMessageBox.question(self, "Επιβεβαίωση Αριθμού Δοντιών", 
                                             "Είναι σωστός ο αριθμός των δοντιών που ανιχνεύθηκαν;",
                                             QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                
                self._trace_log("post_analysis_dialog_count_response", {"response": "Yes" if reply_count == QMessageBox.StandardButton.Yes else "No"})

                if reply_count == QMessageBox.StandardButton.Yes:
                    # Step 2: Confirm Tooth Positions
                    self._trace_log("post_analysis_dialog_positions_shown")
                    reply_pos = QMessageBox.question(self, "Επιβεβαίωση Θέσεων Δοντιών", 
                                                   "Είναι σωστές οι θέσεις των δοντιών;",
                                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                    
                    self._trace_log("post_analysis_dialog_positions_response", {"response": "Yes" if reply_pos == QMessageBox.StandardButton.Yes else "No"})

                    if reply_pos == QMessageBox.StandardButton.Yes:
                        self.results_text_edit.append("✅ Η ανάλυση επιβεβαιώθηκε πλήρως.")
                        self._trace_log("analysis_fully_confirmed")
                    else:
                        # Positions Wrong
                        self.results_text_edit.append("✍️ Παρακαλώ διορθώστε τις ΘΕΣΕΙΣ των δοντιών και πατήστε 'Αποθήκευση'.")
                        
                        # Enable Radiograph Save Button
                        self.save_analysis_button.setEnabled(True)
                        self._trace_log("save_button_radiograph_enabled_pos_wrong")
                        try: self.save_analysis_button.clicked.disconnect()
                        except: pass
                        self.save_analysis_button.clicked.connect(self.save_edited_results)
                        
                        # Enable Odontogram Save Button (Panoramic)
                        if hasattr(self, "save_odontogram_button"):
                            self.save_odontogram_button.setEnabled(True)
                            self._trace_log("save_button_odontogram_enabled_pos_wrong")
                            try: self.save_odontogram_button.clicked.disconnect()
                            except: pass
                            self.save_odontogram_button.clicked.connect(self.save_edited_results)
                else:
                    # Count Wrong
                    self.results_text_edit.append("✍️ Παρακαλώ διορθώστε τον ΑΡΙΘΜΟ των δοντιών και πατήστε 'Αποθήκευση'.")
                    
                    # Enable Radiograph Save Button
                    self.save_analysis_button.setEnabled(True)
                    self._trace_log("save_button_radiograph_enabled_count_wrong")
                    try: self.save_analysis_button.clicked.disconnect()
                    except: pass
                    self.save_analysis_button.clicked.connect(self.save_edited_results)
                    
                    # Enable Odontogram Save Button as well (Consistency)
                    if hasattr(self, "save_odontogram_button"):
                        self.save_odontogram_button.setEnabled(True)
                        self._trace_log("save_button_odontogram_enabled_count_wrong")
                        try: self.save_odontogram_button.clicked.disconnect()
                        except: pass
                        self.save_odontogram_button.clicked.connect(self.save_edited_results)
                    
        except Exception as e:
            print(f"Post Analysis Flow Error: {e}")
            self._trace_log("post_analysis_flow_error", {"error": str(e)})

    def _prompt_post_analysis_popup(self):
        try:
            if not bool(getattr(self, "post_analysis_popup_enabled", True)):
                return None
        except Exception:
            return None
        try:
            msg = str(getattr(self, "_post_analysis_popup_message", "") or "").strip()
        except Exception:
            msg = ""
        if not msg:
            msg = "Είναι πλήρης/σωστή η ανάλυση;"
        try:
            dlg = PostAnalysisConfirmDialog(self, title="Αξιολόγηση Ανάλυσης", message=msg)
            rc = dlg.exec()
            if rc != QDialog.DialogCode.Accepted:
                return None
            return dlg.get_choice()
        except Exception:
            return None

    def _handle_post_analysis_flow_input(self, text: str) -> bool:
        t0 = str(text or "").strip()
        t = t0.lower()
        if not t:
            return False
        try:
            cleaned = re.sub(r"[^\wάέήίόύώϊΐϋΰ]+", " ", t, flags=re.IGNORECASE).strip()
            tokens = [x for x in cleaned.split() if x]
        except Exception:
            tokens = []
        try:
            if self._direct_command_from_text(text):
                return False
        except Exception:
            pass
        if bool(getattr(self, "_post_analysis_waiting_success", False)):
            if (t in ("ναι", "yes", "ok", "οκ", "ενταξει", "εντάξει")) or (tokens and tokens[0] in ("ναι", "yes", "ok", "οκ", "ενταξει", "εντάξει")) or ("ναι" in tokens):
                self._post_analysis_waiting_success = False
                self._post_analysis_waiting_missing = False
                self._post_analysis_waiting_corrections = False
                self._training_allowed = True
                try:
                    self._set_corrections_mode(False, announce=False)
                except Exception:
                    self.snap_annotations_to_grid_on_drop = True
                self._append_comm("AI", "Θέλεις να αποθηκεύσω την ανάλυση ή να κάνω εξαγωγή;")
                return True
            if (t in ("οχι", "όχι", "no")) or (tokens and tokens[0] in ("οχι", "όχι", "no")) or ("όχι" in tokens) or ("οχι" in tokens):
                self._post_analysis_waiting_success = False
                self._post_analysis_waiting_missing = False
                self._post_analysis_waiting_corrections = True
                self._training_allowed = False
                try:
                    self._set_corrections_mode(True, announce=False)
                except Exception:
                    self.snap_annotations_to_grid_on_drop = False
                exp = getattr(self, "_post_analysis_expected_missing", None)
                hint = ""
                if isinstance(exp, list) and exp:
                    hint = " Πιθανόν λείπουν: " + ", ".join(str(x) for x in exp[:10]) + ("…" if len(exp) > 10 else "")
                self._append_comm("Σύστημα", "Κάνε διορθώσεις πάνω στην εικόνα: μετακίνησε πλαίσια/νούμερα, ή διπλό κλικ για αλλαγή αριθμού. Όταν τελειώσεις γράψε «έτοιμο». Αν λείπουν δόντια, γράψε «λείπουν 11 12 21»." + hint)
                try:
                    if not bool(getattr(self, "_manual_scan_active", False)) and getattr(self, "zoning_scan_button", None) is not None:
                        try:
                            q = self._manual_scan_selected_quadrant()
                        except Exception:
                            q = "q1"
                        try:
                            self._start_manual_scan(q)
                        except Exception:
                            pass
                        try:
                            if hasattr(self, "_scan_timer") and self._scan_timer:
                                self._scan_timer.stop()
                        except Exception:
                            pass
                        try:
                            self._manual_scan_paused = True
                        except Exception:
                            pass
                        try:
                            self.zoning_scan_button.setText("Συνέχεια")
                        except Exception:
                            pass
                except Exception:
                    pass
                return True
            self._append_comm("Σύστημα", "Απάντησε «ναι» ή «όχι».")
            return True
        if bool(getattr(self, "_post_analysis_waiting_corrections", False)):
            if (t in ("ετοιμο", "έτοιμο", "ok", "οκ", "ναι", "yes")) or (tokens and tokens[0] in ("ετοιμο", "έτοιμο", "ok", "οκ", "ναι", "yes")):
                self._post_analysis_waiting_corrections = False
                try:
                    self._post_analysis_waiting_success = True
                    self._post_analysis_waiting_missing = False
                except Exception:
                    pass
                try:
                    if bool(getattr(self, "post_analysis_popup_enabled", True)):
                        self._post_analysis_popup_message = "Είναι πλέον πλήρης/σωστή η ανάλυση;"
                        choice = self._prompt_post_analysis_popup()
                        if choice is True:
                            return bool(self._handle_post_analysis_flow_input("ναι"))
                        if choice is False:
                            return bool(self._handle_post_analysis_flow_input("όχι"))
                except Exception:
                    pass
                self._append_comm("AI", "Είναι πλέον πλήρης/σωστή η ανάλυση; (ναι/όχι)")
                return True
            if (t in ("ακυρο", "άκυρο", "ακυρωση", "ακύρωση", "cancel", "skip")) or (tokens and tokens[0] in ("ακυρο", "άκυρο", "ακυρωση", "ακύρωση", "cancel", "skip")):
                self._post_analysis_waiting_corrections = False
                try:
                    self._set_corrections_mode(False, announce=False)
                except Exception:
                    self.snap_annotations_to_grid_on_drop = True
                self._append_comm("Σύστημα", "OK. Θέλεις να αποθηκεύσω την ανάλυση ή να κάνω εξαγωγή;")
                return True
            if ("λειπ" in t) or ("missing" in t):
                fdis = self._parse_fdi_list(text)
                if not fdis:
                    self._append_comm("Σύστημα", "Δώσε αριθμούς FDI που λείπουν. Παράδειγμα: λείπουν 11 12 21 22")
                    return True
                added = self._auto_fill_missing_teeth(fdis)
                if added:
                    try:
                        self._save_silent = True
                        self._save_silent_notes = "Auto-fill missing FDI: " + ", ".join(str(x) for x in added)
                    except Exception:
                        pass
                    try:
                        self.save_edited_results(False)
                    except Exception:
                        pass
                    self._append_comm("Σύστημα", "Προστέθηκαν: " + ", ".join(str(x) for x in added))
                else:
                    self._append_comm("Σύστημα", "Δεν προστέθηκαν νέα δόντια (ίσως υπάρχουν ήδη).")
                return True
            self._append_comm("Σύστημα", "Κάνε τις διορθώσεις πάνω στην εικόνα και γράψε «έτοιμο» όταν τελειώσεις.")
            return True
        if bool(getattr(self, "_post_analysis_waiting_missing", False)):
            if (t in ("ακυρο", "άκυρο", "ακυρωση", "ακύρωση", "cancel", "skip")) or (tokens and tokens[0] in ("ακυρο", "άκυρο", "ακυρωση", "ακύρωση", "cancel", "skip")):
                self._post_analysis_waiting_missing = False
                self._append_comm("Σύστημα", "OK, ακυρώθηκε η συμπλήρωση δοντιών. Θέλεις να αποθηκεύσω την ανάλυση ή να κάνω εξαγωγή;")
                return True
            fdis = self._parse_fdi_list(text)
            if not fdis:
                self._append_comm("Σύστημα", "Δεν βρήκα έγκυρους αριθμούς FDI. Παράδειγμα: 11 12 21 22")
                return True
            added = self._auto_fill_missing_teeth(fdis)
            self._post_analysis_waiting_missing = False
            if added:
                try:
                    self._save_silent = True
                    self._save_silent_notes = "Auto-fill missing FDI: " + ", ".join(str(x) for x in added)
                except Exception:
                    pass
                try:
                    self.save_edited_results(False)
                except Exception:
                    pass
                try:
                    self._post_analysis_waiting_success = True
                except Exception:
                    self._post_analysis_waiting_success = False
                self._append_comm("AI", "Έγινε. Είναι πλέον πλήρης/σωστή η ανάλυση; (ναι/όχι)")
            else:
                self._append_comm("Σύστημα", "Δεν προστέθηκαν νέα δόντια (ίσως υπάρχουν ήδη).")
                self._append_comm("AI", "Θέλεις να αποθηκεύσω την ανάλυση ή να κάνω εξαγωγή;")
            return True
        return False

    def _parse_fdi_list(self, text: str) -> list[int]:
        s = str(text or "")
        found = re.findall(r"\b(\d{2})\b", s)
        out: list[int] = []
        for tok in found:
            try:
                v = int(tok)
            except Exception:
                continue
            q = v // 10
            t = v % 10
            if q in (1, 2, 3, 4) and 1 <= t <= 8:
                out.append(v)
        dedup = []
        seen = set()
        for v in out:
            if v in seen:
                continue
            seen.add(v)
            dedup.append(v)
        return dedup

    def _auto_fill_missing_teeth(self, fdis: list[int]) -> list[int]:
        try:
            if not getattr(self, "scene", None):
                return []
        except Exception:
            return []
        existing = set()
        try:
            for item in self.scene.items():
                if isinstance(item, EditableTextItem):
                    s = str(item.toPlainText() or "").strip()
                    if re.match(r"^\d+$", s):
                        existing.add(int(s))
        except Exception:
            existing = set()
        targets = [int(x) for x in (fdis or []) if int(x) not in existing]
        if not targets:
            return []

        rect = None
        try:
            rect = self.pixmap_item.boundingRect() if getattr(self, "pixmap_item", None) else self.scene.sceneRect()
        except Exception:
            rect = self.scene.sceneRect()
        w_scene = float(rect.width() or 1.0)
        h_scene = float(rect.height() or 1.0)

        sizes_w = []
        sizes_h = []
        pos_by_fdi: dict[int, tuple[float, float]] = {}
        try:
            if isinstance(getattr(self, "analysis_results", None), dict):
                boxes = (self.analysis_results or {}).get("boxes", []) or []
                fdi_list = (self.analysis_results or {}).get("fdi", []) or []
                for i, b in enumerate(boxes):
                    try:
                        x1, y1, x2, y2 = [float(v) for v in b]
                    except Exception:
                        continue
                    bw = max(1.0, x2 - x1)
                    bh = max(1.0, y2 - y1)
                    sizes_w.append(bw)
                    sizes_h.append(bh)
                    s = str(fdi_list[i] if i < len(fdi_list) else "").strip()
                    if re.match(r"^\d+$", s):
                        try:
                            pos_by_fdi[int(s)] = (x1 + bw / 2.0, y1 + bh / 2.0)
                        except Exception:
                            pass
        except Exception:
            pass
        if not sizes_w:
            sizes_w = [max(10.0, w_scene * 0.03)]
        if not sizes_h:
            sizes_h = [max(10.0, h_scene * 0.06)]
        sizes_w.sort()
        sizes_h.sort()
        bw = float(sizes_w[len(sizes_w) // 2])
        bh = float(sizes_h[len(sizes_h) // 2])

        def _median(vals: list[float]) -> float:
            if not vals:
                return 0.0
            v = sorted(vals)
            return float(v[len(v) // 2])

        def _jaw_of(v: int) -> str:
            q = int(v) // 10
            return "upper" if q in (1, 2) else "lower"

        def _side_of(v: int) -> str:
            q = int(v) // 10
            return "right" if q in (1, 4) else "left"

        upper_ys = []
        lower_ys = []
        for f, (cx, cy) in pos_by_fdi.items():
            if _jaw_of(f) == "upper":
                upper_ys.append(cy)
            else:
                lower_ys.append(cy)
        upper_y = _median(upper_ys) if upper_ys else h_scene * 0.35
        lower_y = _median(lower_ys) if lower_ys else h_scene * 0.65

        x_split = w_scene / 2.0
        try:
            if getattr(self, "vertical_separator_line", None) and self.vertical_separator_line.scene() == self.scene:
                x_split = float(self._get_vertical_split_x())
        except Exception:
            pass

        h_lines = []
        v_upper = []
        v_lower = []
        try:
            if bool(getattr(self, "grid_active", False)):
                h_lines = sorted([float(l.y()) for l in (getattr(self, "grid_lines_h", None) or []) if l and l.scene() == self.scene])
                v_upper = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v_upper", None) or []) if l and l.scene() == self.scene])
                v_lower = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v_lower", None) or []) if l and l.scene() == self.scene])
                if not v_upper and not v_lower:
                    v_common = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v", None) or []) if l and l.scene() == self.scene])
                    v_upper = v_common
                    v_lower = v_common
        except Exception:
            h_lines = []
            v_upper = []
            v_lower = []

        map_upper = [18, 17, 16, 15, 14, 13, 12, 11, 21, 22, 23, 24, 25, 26, 27, 28]
        map_lower = [48, 47, 46, 45, 44, 43, 42, 41, 31, 32, 33, 34, 35, 36, 37, 38]

        added: list[int] = []
        for fdi in targets:
            q = int(fdi) // 10
            ti = int(fdi) % 10
            same_q = {k: v for k, v in pos_by_fdi.items() if (k // 10) == q}
            cx = None
            if same_q:
                by_t = {k % 10: v for k, v in same_q.items()}
                left_t = max([t for t in by_t.keys() if t < ti], default=None)
                right_t = min([t for t in by_t.keys() if t > ti], default=None)
                if left_t is not None and right_t is not None:
                    cx = (float(by_t[left_t][0]) + float(by_t[right_t][0])) / 2.0
                elif left_t is not None:
                    xs = [float(v[0]) for v in by_t.values()]
                    xs.sort()
                    step = _median([abs(xs[i] - xs[i - 1]) for i in range(1, len(xs))]) if len(xs) >= 2 else bw * 1.2
                    cx = float(by_t[left_t][0]) + (step if _side_of(fdi) == "right" else -step)
                elif right_t is not None:
                    xs = [float(v[0]) for v in by_t.values()]
                    xs.sort()
                    step = _median([abs(xs[i] - xs[i - 1]) for i in range(1, len(xs))]) if len(xs) >= 2 else bw * 1.2
                    cx = float(by_t[right_t][0]) + (-step if _side_of(fdi) == "right" else step)
            if cx is None:
                side = _side_of(fdi)
                step = bw * 1.25
                dist = max(0, ti - 1)
                cx = x_split + (dist * step if side == "right" else -dist * step)
            cy = upper_y if _jaw_of(fdi) == "upper" else lower_y

            try:
                is_upper = (_jaw_of(fdi) == "upper")
                v_lines = v_upper if is_upper else (v_lower or v_upper)
                mapping = map_upper if is_upper else map_lower
                if v_lines and len(v_lines) >= 1 and int(fdi) in mapping:
                    slot = int(mapping.index(int(fdi)))
                    left_b = float(v_lines[slot - 1]) if slot > 0 and (slot - 1) < len(v_lines) else 0.0
                    right_b = float(v_lines[slot]) if slot < len(v_lines) else w_scene
                    cx = (left_b + right_b) / 2.0
                    if h_lines and len(h_lines) >= 3:
                        if is_upper:
                            cy = (float(h_lines[0]) + float(h_lines[1])) / 2.0
                        else:
                            cy = (float(h_lines[1]) + float(h_lines[2])) / 2.0
                    elif h_lines and len(h_lines) >= 2 and is_upper:
                        cy = (float(h_lines[0]) + float(h_lines[1])) / 2.0
            except Exception:
                pass

            x = float(cx) - bw / 2.0
            y = float(cy) - bh / 2.0
            try:
                if bool(getattr(self, "grid_active", False)) and (getattr(self, "grid_lines_h", None) or getattr(self, "grid_lines_v", None)):
                    x, y, _ = self._snap_to_grid(QPointF(float(cx), float(cy)), float(bw), float(bh))
            except Exception:
                pass
            try:
                j = getattr(self, "jaw_separator_line", None)
                if j is not None and j.scene() == self.scene:
                    zone_type = _jaw_of(fdi)
                    sep_y = float(j.get_y_at_x(float(x + bw / 2.0)))
                    pad = float(bh) * 0.55
                    cy_cur = float(y + bh / 2.0)
                    if zone_type == "lower":
                        cy_cur = max(cy_cur, sep_y + pad)
                    else:
                        cy_cur = min(cy_cur, sep_y - pad)
                    y = float(cy_cur) - bh / 2.0
            except Exception:
                pass
            x = max(0.0, min(w_scene - bw, x))
            y = max(0.0, min(h_scene - bh, y))
            rect_item = EditableRectItem(x=x, y=y, w=bw, h=bh, on_change_callback=self.debounced_recalculate_fdi)
            self.scene.addItem(rect_item)
            rect_item.set_statuses([], notify=False)
            text_item = EditableTextItem(str(fdi), rect_item=rect_item, on_change_callback=self.debounced_recalculate_fdi)
            text_item.setDefaultTextColor(QColor("red"))
            self.scene.addItem(text_item)
            self._position_label_for_rect(rect_item)
            try:
                self._apply_overlay_visibility(rect_item, text_item)
            except Exception:
                pass
            try:
                self.analysis_items.append(rect_item)
                self.analysis_items.append(text_item)
            except Exception:
                pass
            added.append(int(fdi))

        try:
            self.on_annotation_modified()
        except Exception:
            pass
        return added

    def _update_teach_button_ui(self):
        try:
            btn = getattr(self, "teach_btn", None)
            if btn is None:
                return
            active = bool(getattr(self, "_macro_recording_active", False))
            if active:
                btn.setText("Τέλος Εκμάθησης")
                btn.setToolTip("Τερματισμός εκμάθησης και αποθήκευση macro")
            else:
                btn.setText("Εκμάθηση")
                btn.setToolTip("Δίδαξε μια διαδικασία (macro) με φράση")
        except Exception:
            pass

    def _on_teach_button_clicked(self):
        try:
            if bool(getattr(self, "_macro_recording_active", False)):
                self._handle_text_command("/record stop")
                self._update_teach_button_ui()
                return
        except Exception:
            pass
        phrase = ""
        ok = False
        try:
            phrase, ok = QInputDialog.getText(
                self,
                "Εκμάθηση",
                "Φράση για τη διαδικασία (π.χ. «κάνε ανάλυση και αποθήκευση»):",
            )
        except Exception:
            phrase = ""
            ok = False
        if not ok:
            return
        phrase = str(phrase or "").strip()
        if not phrase:
            return
        self._handle_text_command(f"/teach {phrase}")
        self._update_teach_button_ui()

    def _start_macro_recording(self, name: str | None = None):
        n = str(name or "").strip()
        if not n:
            n = f"macro_{_fmt_ts_for_name()}"
        try:
            self._macro_recording_active = True
            self._macro_recording_name = n
            self._macro_recording_steps = []
            self._macro_recording_last_name = str(n)
        except Exception:
            return
        try:
            self._append_comm("Σύστημα", f"Καταγραφή ενεργειών: ενεργή ({n}). Κάνε τα βήματα σου και μετά /record stop.")
        except Exception:
            pass
        self._update_teach_button_ui()

    def _stop_macro_recording(self, save: bool = True):
        try:
            active = bool(getattr(self, "_macro_recording_active", False))
        except Exception:
            active = False
        if not active:
            try:
                self._append_comm("Σύστημα", "Δεν τρέχει καταγραφή ενεργειών.")
            except Exception:
                pass
            self._update_teach_button_ui()
            return
        try:
            self._macro_recording_active = False
        except Exception:
            pass
        name = str(getattr(self, "_macro_recording_name", "") or "").strip() or f"macro_{_fmt_ts_for_name()}"
        steps = getattr(self, "_macro_recording_steps", None)
        if not isinstance(steps, list):
            steps = []
        steps = [str(x).strip() for x in steps if str(x).strip() and self._is_allowed_ai_command(str(x))]
        steps = steps[:12]
        if not save:
            try:
                self._append_comm("Σύστημα", "Η καταγραφή ακυρώθηκε.")
            except Exception:
                pass
            return
        if not steps:
            try:
                self._append_comm("Σύστημα", "Η καταγραφή τελείωσε αλλά δεν γράφτηκαν βήματα. Σημείωση: η εκμάθηση καταγράφει μόνο εντολές/κουμπιά (π.χ. ανάλυση, αποθήκευση, εξαγωγή, πλέγμα, κλείδωμα), όχι χειροκίνητες διορθώσεις πάνω στην εικόνα.")
            except Exception:
                pass
            try:
                self._macro_recording_bind_phrase = ""
            except Exception:
                pass
            self._update_teach_button_ui()
            return
        if not isinstance(getattr(self, "comm_macros", None), dict):
            self.comm_macros = {}
        self.comm_macros[name] = steps
        try:
            self._save_viewer_prefs()
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", f"✅ Αποθηκεύτηκε macro: {name} ({len(steps)} βήματα). Τρέχει με: /macro run {name}")
            self._append_comm("Σύστημα", f"Προαιρετικά: /record bind <φράση> για να το λες με λόγια.")
        except Exception:
            pass
        try:
            if not isinstance(getattr(self, "comm_aliases", None), dict):
                self.comm_aliases = {}
            default_phrase = self._normalize_phrase_key("κάνε την ίδια διαδικασία")
            if default_phrase and default_phrase not in self.comm_aliases:
                self.comm_aliases[default_phrase] = f"/macro run {name}"
                try:
                    self._save_viewer_prefs()
                except Exception:
                    pass
                self._append_comm("Σύστημα", f"OK: «{default_phrase}» → /macro run {name}")
        except Exception:
            pass
        try:
            phrase = str(getattr(self, "_macro_recording_bind_phrase", "") or "").strip()
            self._macro_recording_bind_phrase = ""
            if phrase:
                self._bind_last_recorded_macro(phrase)
        except Exception:
            pass
        try:
            self._session_log("macro_record_saved", {"name": name, "steps": int(len(steps))})
        except Exception:
            pass
        self._update_teach_button_ui()

    def _bind_last_recorded_macro(self, phrase: str):
        p = self._normalize_phrase_key(str(phrase or "").strip())
        name = str(getattr(self, "_macro_recording_last_name", "") or "").strip()
        if not p or not name:
            self._append_comm("Σύστημα", "Χρήση: /record bind <φράση> (αφού έχει αποθηκευτεί macro).")
            return
        if not isinstance(getattr(self, "comm_aliases", None), dict):
            self.comm_aliases = {}
        self.comm_aliases[p] = f"/macro run {name}"
        try:
            self._save_viewer_prefs()
        except Exception:
            pass
        self._append_comm("Σύστημα", f"OK: «{p}» → /macro run {name}")

    def _set_cloud_api_key_persist(self, api_key: str):
        k = str(api_key or "").strip()
        if not k:
            try:
                self._comm_cloud_api_key_dpapi = ""
            except Exception:
                pass
            try:
                if "OPENAI_API_KEY" in os.environ:
                    del os.environ["OPENAI_API_KEY"]
            except Exception:
                pass
            try:
                self._save_viewer_prefs()
            except Exception:
                pass
            return
        try:
            enc = _dpapi_encrypt_text_to_b64(k)
            self._comm_cloud_api_key_dpapi = enc
        except Exception:
            try:
                self._comm_cloud_api_key_dpapi = ""
            except Exception:
                pass
        try:
            os.environ["OPENAI_API_KEY"] = k
        except Exception:
            pass
        try:
            self._save_viewer_prefs()
        except Exception:
            pass

    def _load_viewer_prefs(self):
        try:
            prefs_path = self._viewer_prefs_path()
            if prefs_path.exists():
                with open(prefs_path, "r", encoding="utf-8") as f:
                    data = json.load(f) or {}
                global_msgs = None
                if isinstance(data, dict) and "right_splitter_sizes" in data:
                    try:
                        v = data.get("right_splitter_sizes")
                        if isinstance(v, list) and len(v) >= 2:
                            vals = []
                            for x in v[:2]:
                                try:
                                    n = int(x)
                                except Exception:
                                    n = 0
                                if n > 0:
                                    vals.append(n)
                            if len(vals) >= 2:
                                self._right_splitter_sizes_pref = vals[:2]
                    except Exception:
                        pass
                if isinstance(data, dict) and "left_splitter_sizes" in data:
                    try:
                        v = data.get("left_splitter_sizes")
                        if isinstance(v, list) and len(v) >= 2:
                            vals = []
                            for x in v[:2]:
                                try:
                                    n = int(x)
                                except Exception:
                                    n = 0
                                if n > 0:
                                    vals.append(n)
                            if len(vals) >= 2:
                                self._left_splitter_sizes_pref = vals[:2]
                    except Exception:
                        pass
                if isinstance(data, dict) and "main_splitter_sizes" in data:
                    try:
                        v = data.get("main_splitter_sizes")
                        if isinstance(v, list) and len(v) >= 2:
                            vals = []
                            for x in v[:2]:
                                try:
                                    n = int(x)
                                except Exception:
                                    n = 0
                                if n > 0:
                                    vals.append(n)
                            if len(vals) >= 2:
                                self._main_splitter_sizes_pref = vals[:2]
                    except Exception:
                        pass
                if isinstance(data, dict) and "ui_right_preset" in data:
                    self._ui_right_preset = str(data.get("ui_right_preset") or "").strip()
                if isinstance(data, dict) and "auto_fdi_enabled" in data:
                    self.auto_fdi_enabled = bool(data.get("auto_fdi_enabled"))
                if isinstance(data, dict) and "layout_locked" in data:
                    self.layout_locked = bool(data.get("layout_locked"))
                try:
                    if isinstance(data, dict) and "view_fit_mode" in data:
                        vfm = str(data.get("view_fit_mode") or "").strip().lower()
                        self.view_fit_mode = "height" if vfm == "height" else "scene"
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and "fdi_from_grid_enabled" in data:
                        self.fdi_from_grid_enabled = bool(data.get("fdi_from_grid_enabled"))
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and "tools_location" in data:
                        v = str(data.get("tools_location") or "").strip().lower()
                        self.tools_location = "bottom" if v == "bottom" else "top"
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and "dock_geometry_b64" in data:
                        self._dock_geometry_b64 = str(data.get("dock_geometry_b64") or "").strip()
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and "dock_state_b64" in data:
                        self._dock_state_b64 = str(data.get("dock_state_b64") or "").strip()
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and isinstance(data.get("button_order"), dict):
                        bo = {}
                        for kk, vv in (data.get("button_order") or {}).items():
                            if not isinstance(vv, list):
                                continue
                            k2 = str(kk or "").strip()
                            if not k2:
                                continue
                            bo[k2] = [str(x or "").strip() for x in vv if str(x or "").strip()]
                        self._button_order_prefs = bo
                except Exception:
                    pass
                if not getattr(self, "radiograph_path", None):
                    try:
                        if isinstance(data, dict) and "radiograph_path" in data:
                            rp = str(data.get("radiograph_path") or "").strip()
                            if rp and os.path.isdir(rp):
                                self.radiograph_path = rp
                    except Exception:
                        pass
                try:
                    if isinstance(data, dict) and "last_radiograph_import_dir" in data:
                        p = str(data.get("last_radiograph_import_dir") or "").strip()
                        if p and os.path.isdir(p):
                            self.last_radiograph_import_dir = p
                except Exception:
                    pass
                if isinstance(data, dict) and "comm_stt_url" in data:
                    self.comm_stt_url = str(data.get("comm_stt_url") or "").strip()
                if isinstance(data, dict) and "comm_stt_lang" in data:
                    self.comm_stt_lang = str(data.get("comm_stt_lang") or "el").strip() or "el"
                try:
                    if isinstance(data, dict) and "change_overlay_enabled" in data:
                        self.change_overlay_enabled = bool(data.get("change_overlay_enabled"))
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and "change_overlay_alpha" in data:
                        self.change_overlay_alpha = float(data.get("change_overlay_alpha"))
                except Exception:
                    pass
                try:
                    if isinstance(data, dict) and "change_overlay_percentile" in data:
                        self.change_overlay_percentile = float(data.get("change_overlay_percentile"))
                except Exception:
                    pass
                if isinstance(data, dict) and "comm_stt_backend" in data:
                    self.comm_stt_backend = str(data.get("comm_stt_backend") or "api").strip() or "api"
                if isinstance(data, dict) and "comm_whispercpp_cli" in data:
                    self.comm_whispercpp_cli = str(data.get("comm_whispercpp_cli") or "").strip()
                if isinstance(data, dict) and "comm_whispercpp_model" in data:
                    self.comm_whispercpp_model = str(data.get("comm_whispercpp_model") or "").strip()
                if isinstance(data, dict) and "comm_voice_auto_transcribe" in data:
                    self.comm_voice_auto_transcribe = bool(data.get("comm_voice_auto_transcribe"))
                if isinstance(data, dict) and "comm_voice_auto_send" in data:
                    self.comm_voice_auto_send = bool(data.get("comm_voice_auto_send"))
                if isinstance(data, dict) and "comm_voice_chat_enabled" in data:
                    self.comm_voice_chat_enabled = bool(data.get("comm_voice_chat_enabled"))
                if isinstance(data, dict) and "comm_voice_handsfree" in data:
                    self.comm_voice_handsfree = bool(data.get("comm_voice_handsfree"))
                if isinstance(data, dict) and "comm_voice_push_to_talk" in data:
                    self.comm_voice_push_to_talk = bool(data.get("comm_voice_push_to_talk"))
                if isinstance(data, dict) and "comm_voice_continuous" in data:
                    self.comm_voice_continuous = bool(data.get("comm_voice_continuous"))
                if isinstance(data, dict) and not bool(data.get("voice_chat_defaults_v1")):
                    self.comm_voice_chat_enabled = False
                    self.comm_voice_handsfree = False
                    self.comm_voice_continuous = False
                    self.comm_voice_push_to_talk = False
                    self.comm_voice_auto_transcribe = False
                    self.comm_voice_auto_send = False
                    self._voice_chat_defaults_v1 = True
                if isinstance(data, dict) and "comm_tts_enabled" in data:
                    self.comm_tts_enabled = bool(data.get("comm_tts_enabled"))
                if isinstance(data, dict) and "comm_action_tts_enabled" in data:
                    self.comm_action_tts_enabled = bool(data.get("comm_action_tts_enabled"))
                if isinstance(data, dict) and "comm_scan_tts_enabled" in data:
                    self.comm_scan_tts_enabled = bool(data.get("comm_scan_tts_enabled"))
                if isinstance(data, dict) and "auto_train_after_analysis" in data:
                    self.auto_train_after_analysis = bool(data.get("auto_train_after_analysis"))
                if isinstance(data, dict) and "auto_train_every_save" in data:
                    self.auto_train_every_save = bool(data.get("auto_train_every_save"))
                if isinstance(data, dict) and "auto_save_manual_edits" in data:
                    self.auto_save_manual_edits = bool(data.get("auto_save_manual_edits"))
                if isinstance(data, dict) and "auto_pipeline_enabled" in data:
                    self.auto_pipeline_enabled = bool(data.get("auto_pipeline_enabled"))
                if isinstance(data, dict) and "auto_analyze_on_open" in data:
                    self.auto_analyze_on_open = bool(data.get("auto_analyze_on_open"))
                if isinstance(data, dict) and "auto_sync_multiclass_on_save" in data:
                    self.auto_sync_multiclass_on_save = bool(data.get("auto_sync_multiclass_on_save"))
                if isinstance(data, dict) and "auto_pipeline_require_confirm" in data:
                    self.auto_pipeline_require_confirm = bool(data.get("auto_pipeline_require_confirm"))
                if isinstance(data, dict) and "auto_detect_retrain_enabled" in data:
                    self.auto_detect_retrain_enabled = bool(data.get("auto_detect_retrain_enabled"))
                if isinstance(data, dict) and "auto_toothcls_train_enabled" in data:
                    self.auto_toothcls_train_enabled = bool(data.get("auto_toothcls_train_enabled"))
                if isinstance(data, dict) and "auto_detect_retrain_threshold" in data:
                    try:
                        self.auto_detect_retrain_threshold = int(data.get("auto_detect_retrain_threshold"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_toothcls_train_threshold" in data:
                    try:
                        self.auto_toothcls_train_threshold = int(data.get("auto_toothcls_train_threshold"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_detect_min_interval_s" in data:
                    try:
                        self.auto_detect_min_interval_s = int(data.get("auto_detect_min_interval_s"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_toothcls_min_interval_s" in data:
                    try:
                        self.auto_toothcls_min_interval_s = int(data.get("auto_toothcls_min_interval_s"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_detect_save_count" in data:
                    try:
                        self._auto_detect_save_count = int(data.get("auto_detect_save_count"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_toothcls_save_count" in data:
                    try:
                        self._auto_toothcls_save_count = int(data.get("auto_toothcls_save_count"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_detect_last_train_ts" in data:
                    try:
                        self._auto_detect_last_train_ts = float(data.get("auto_detect_last_train_ts"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "auto_toothcls_last_train_ts" in data:
                    try:
                        self._auto_toothcls_last_train_ts = float(data.get("auto_toothcls_last_train_ts"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "comm_confirm_new_commands" in data:
                    self.comm_confirm_new_commands = bool(data.get("comm_confirm_new_commands"))
                if isinstance(data, dict) and "comm_confirm_threshold" in data:
                    try:
                        self.comm_confirm_threshold = int(data.get("comm_confirm_threshold"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "comm_confirm_counts" in data and isinstance(data.get("comm_confirm_counts"), dict):
                    try:
                        self.comm_confirm_counts = {str(k): int(v) for k, v in (data.get("comm_confirm_counts") or {}).items() if str(k).strip()}
                    except Exception:
                        pass
                if isinstance(data, dict) and "comm_tts_backend" in data:
                    self.comm_tts_backend = str(data.get("comm_tts_backend") or "qt").strip() or "qt"
                if isinstance(data, dict) and "comm_tts_voice_id" in data:
                    self.comm_tts_voice_id = str(data.get("comm_tts_voice_id") or "").strip()
                if isinstance(data, dict) and "comm_piper_cli" in data:
                    self.comm_piper_cli = str(data.get("comm_piper_cli") or "").strip()
                if isinstance(data, dict) and "comm_piper_voice_model" in data:
                    self.comm_piper_voice_model = str(data.get("comm_piper_voice_model") or "").strip()
                if isinstance(data, dict) and "comm_piper_length_scale" in data:
                    try:
                        v = data.get("comm_piper_length_scale")
                        self.comm_piper_length_scale = float(v) if v is not None else None
                    except Exception:
                        pass
                if isinstance(data, dict) and "comm_tts_rate" in data:
                    try:
                        self.comm_tts_rate = float(data.get("comm_tts_rate"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "comm_tts_volume" in data:
                    try:
                        self.comm_tts_volume = float(data.get("comm_tts_volume"))
                    except Exception:
                        pass
                if isinstance(data, dict) and "comm_templates" in data and isinstance(data.get("comm_templates"), dict):
                    self.comm_templates = {str(k): str(v) for k, v in (data.get("comm_templates") or {}).items() if str(k).strip()}
                if isinstance(data, dict) and "comm_last_template" in data:
                    self.comm_last_template = str(data.get("comm_last_template") or "")
                if isinstance(data, dict) and "comm_aliases" in data and isinstance(data.get("comm_aliases"), dict):
                    self.comm_aliases = {str(k): str(v) for k, v in (data.get("comm_aliases") or {}).items() if str(k).strip()}
                if isinstance(data, dict) and "comm_macros" in data and isinstance(data.get("comm_macros"), dict):
                    loaded = {}
                    for k, v in (data.get("comm_macros") or {}).items():
                        name = str(k or "").strip()
                        if not name:
                            continue
                        if isinstance(v, list):
                            cmds = [str(x or "").strip() for x in v if str(x or "").strip()]
                        else:
                            cmds = [str(v or "").strip()] if str(v or "").strip() else []
                        if not cmds:
                            continue
                        loaded[name] = cmds[:12]
                    self.comm_macros = loaded
                if isinstance(data, dict) and "comm_ai_enabled" in data:
                    self.comm_ai_enabled = bool(data.get("comm_ai_enabled"))
                if isinstance(data, dict) and "comm_ai_auto_execute" in data:
                    self.comm_ai_auto_execute = bool(data.get("comm_ai_auto_execute"))
                if isinstance(data, dict) and "comm_advanced_expanded" in data:
                    self._comm_advanced_expanded_pref = bool(data.get("comm_advanced_expanded"))
                self.comm_confirm_new_commands = False
                self.comm_ai_auto_execute = True
                if isinstance(data, dict) and "comm_learning_enabled" in data:
                    self.comm_learning_enabled = bool(data.get("comm_learning_enabled"))
                if isinstance(data, dict) and "comm_learning_auto_accept" in data:
                    self.comm_learning_auto_accept = bool(data.get("comm_learning_auto_accept"))
                if isinstance(data, dict) and "comm_conversation_enabled" in data:
                    self.comm_conversation_enabled = bool(data.get("comm_conversation_enabled"))
                if isinstance(data, dict) and "comm_ai_stream_enabled" in data:
                    self.comm_ai_stream_enabled = bool(data.get("comm_ai_stream_enabled"))
                if isinstance(data, dict) and "comm_chat_visible" in data:
                    self.comm_chat_visible = bool(data.get("comm_chat_visible"))
                if isinstance(data, dict) and "comm_ai_backend_mode" in data:
                    mode = str(data.get("comm_ai_backend_mode") or "").strip().lower()
                    if mode in ("cloud", "hybrid"):
                        mode = "local"
                    self.comm_ai_backend_mode = mode or "local"
                if isinstance(data, dict) and "comm_cloud_api_base" in data:
                    self.comm_cloud_api_base = str(data.get("comm_cloud_api_base") or "").strip() or "https://api.openai.com/v1"
                if isinstance(data, dict) and "comm_cloud_model" in data:
                    self.comm_cloud_model = str(data.get("comm_cloud_model") or "").strip() or "gpt-4o-mini"
                try:
                    if isinstance(data, dict) and "comm_cloud_api_key_dpapi" in data:
                        self._comm_cloud_api_key_dpapi = str(data.get("comm_cloud_api_key_dpapi") or "").strip()
                        if self._comm_cloud_api_key_dpapi:
                            try:
                                k = _dpapi_decrypt_b64_to_text(self._comm_cloud_api_key_dpapi)
                                if str(k or "").strip():
                                    os.environ["OPENAI_API_KEY"] = str(k).strip()
                            except Exception:
                                pass
                except Exception:
                    pass
                if isinstance(data, dict) and "comm_llm_url" in data:
                    self.comm_llm_url = str(data.get("comm_llm_url") or "").strip()
                if isinstance(data, dict) and "comm_llm_model" in data:
                    self.comm_llm_model = str(data.get("comm_llm_model") or "").strip()
                if isinstance(data, dict) and "comm_llm_system_prompt" in data:
                    self.comm_llm_system_prompt = str(data.get("comm_llm_system_prompt") or "").strip() or self.comm_llm_system_prompt
                if isinstance(data, dict) and "comm_memory_text" in data:
                    self.comm_memory_text = str(data.get("comm_memory_text") or "").strip()
                if isinstance(data, dict) and "comm_ai_messages" in data and isinstance(data.get("comm_ai_messages"), list):
                    msgs = []
                    for m in (data.get("comm_ai_messages") or [])[-50:]:
                        if not isinstance(m, dict):
                            continue
                        role = str(m.get("role") or "").strip()
                        if role not in ("user", "assistant"):
                            continue
                        content = str(m.get("content") or "")
                        if not content.strip():
                            continue
                        if len(content) > 4000:
                            content = content[:4000]
                        msgs.append({"role": role, "content": content})
                    global_msgs = msgs[-20:]
                    self._ai_messages = list(global_msgs)
                if isinstance(data, dict) and "comm_patient_memory" in data and isinstance(data.get("comm_patient_memory"), dict):
                    self.comm_patient_memory = {
                        str(k): str(v or "").strip()[:2000]
                        for k, v in (data.get("comm_patient_memory") or {}).items()
                        if str(k).strip()
                    }
                if isinstance(data, dict) and "comm_patient_ai_messages" in data and isinstance(data.get("comm_patient_ai_messages"), dict):
                    by_patient = {}
                    for pk, lst in (data.get("comm_patient_ai_messages") or {}).items():
                        if not str(pk).strip() or not isinstance(lst, list):
                            continue
                        msgs = []
                        for m in (lst or [])[-50:]:
                            if not isinstance(m, dict):
                                continue
                            role = str(m.get("role") or "").strip()
                            if role not in ("user", "assistant"):
                                continue
                            content = str(m.get("content") or "")
                            if not content.strip():
                                continue
                            if len(content) > 4000:
                                content = content[:4000]
                            msgs.append({"role": role, "content": content})
                        by_patient[str(pk).strip()] = msgs[-20:]
                    self.comm_patient_ai_messages = by_patient
                if isinstance(data, dict) and "layout_snapshot_by_patient" in data and isinstance(data.get("layout_snapshot_by_patient"), dict):
                    self.layout_snapshot_by_patient = data.get("layout_snapshot_by_patient") or {}
                key = self._get_patient_key()
                if key != "general":
                    try:
                        pm = getattr(self, "comm_patient_ai_messages", None)
                        if isinstance(pm, dict) and isinstance(pm.get(key), list) and pm.get(key):
                            self._ai_messages = list(pm.get(key) or [])[-20:]
                        else:
                            self._ai_messages = []
                    except Exception:
                        pass
        except Exception:
            pass

    def _save_viewer_prefs(self):
        try:
            prefs_path = self._viewer_prefs_path()
            tmp_path = str(prefs_path) + ".tmp"
            comm_url = self.comm_stt_url
            comm_lang = self.comm_stt_lang
            try:
                if hasattr(self, "comm_stt_url_edit"):
                    comm_url = str(self.comm_stt_url_edit.text() or "").strip()
                if hasattr(self, "comm_stt_lang_edit"):
                    comm_lang = str(self.comm_stt_lang_edit.text() or "el").strip() or "el"
            except Exception:
                pass
            key = self._get_patient_key()
            pmem = getattr(self, "comm_patient_memory", None)
            if not isinstance(pmem, dict):
                pmem = {}
                self.comm_patient_memory = pmem
            pmsg = getattr(self, "comm_patient_ai_messages", None)
            if not isinstance(pmsg, dict):
                pmsg = {}
                self.comm_patient_ai_messages = pmsg
            if key != "general":
                pmsg[key] = [
                    {"role": str((m or {}).get("role") or ""), "content": str((m or {}).get("content") or "")}
                    for m in ((getattr(self, "_ai_messages", None) or [])[-20:])
                    if isinstance(m, dict) and str((m or {}).get("role") or "") in ("user", "assistant") and str((m or {}).get("content") or "").strip()
                ]

            data = {
                "radiograph_path": str(getattr(self, "radiograph_path", "") or "").strip(),
                "last_radiograph_import_dir": str(getattr(self, "last_radiograph_import_dir", "") or "").strip(),
                "change_overlay_enabled": bool(getattr(self, "change_overlay_enabled", True)),
                "change_overlay_alpha": float(getattr(self, "change_overlay_alpha", 0.45) or 0.45),
                "change_overlay_percentile": float(getattr(self, "change_overlay_percentile", 92.0) or 92.0),
                "right_splitter_sizes": getattr(self, "_right_splitter_sizes", None) if isinstance(getattr(self, "_right_splitter_sizes", None), list) else getattr(self, "_right_splitter_sizes_pref", None),
                "left_splitter_sizes": getattr(self, "_left_splitter_sizes", None) if isinstance(getattr(self, "_left_splitter_sizes", None), list) else getattr(self, "_left_splitter_sizes_pref", None),
                "main_splitter_sizes": getattr(self, "_main_splitter_sizes", None) if isinstance(getattr(self, "_main_splitter_sizes", None), list) else getattr(self, "_main_splitter_sizes_pref", None),
                "ui_right_preset": str(getattr(self, "_ui_right_preset", "") or "").strip(),
                "auto_fdi_enabled": bool(self.auto_fdi_enabled),
                "layout_locked": bool(self.layout_locked),
                "view_fit_mode": str(getattr(self, "view_fit_mode", "scene") or "scene"),
                "fdi_from_grid_enabled": bool(getattr(self, "fdi_from_grid_enabled", False)),
                "tools_location": str(getattr(self, "tools_location", "top") or "top"),
                "dock_geometry_b64": str(getattr(self, "_dock_geometry_b64", "") or "").strip(),
                "dock_state_b64": str(getattr(self, "_dock_state_b64", "") or "").strip(),
                "button_order": getattr(self, "_button_order_prefs", None) if isinstance(getattr(self, "_button_order_prefs", None), dict) else {},
                "comm_stt_url": str(comm_url or "").strip(),
                "comm_stt_lang": str(comm_lang or "el").strip() or "el",
                "comm_stt_backend": str(getattr(self, "comm_stt_backend", "api") or "api").strip() or "api",
                "comm_whispercpp_cli": str(getattr(self, "comm_whispercpp_cli", "") or "").strip(),
                "comm_whispercpp_model": str(getattr(self, "comm_whispercpp_model", "") or "").strip(),
                "comm_voice_auto_transcribe": bool(getattr(self, "comm_voice_auto_transcribe", True)),
                "comm_voice_auto_send": bool(getattr(self, "comm_voice_auto_send", True)),
                "comm_voice_chat_enabled": bool(getattr(self, "comm_voice_chat_enabled", False)),
                "comm_voice_handsfree": bool(getattr(self, "comm_voice_handsfree", True)),
                "comm_voice_push_to_talk": bool(getattr(self, "comm_voice_push_to_talk", False)),
                "comm_voice_continuous": bool(getattr(self, "comm_voice_continuous", True)),
                "voice_chat_defaults_v1": bool(getattr(self, "_voice_chat_defaults_v1", False)),
                "comm_tts_enabled": bool(getattr(self, "comm_tts_enabled", False)),
                "comm_action_tts_enabled": bool(getattr(self, "comm_action_tts_enabled", False)),
                "comm_scan_tts_enabled": bool(getattr(self, "comm_scan_tts_enabled", False)),
                "auto_train_after_analysis": bool(getattr(self, "auto_train_after_analysis", True)),
                "auto_train_every_save": bool(getattr(self, "auto_train_every_save", True)),
                "auto_save_manual_edits": bool(getattr(self, "auto_save_manual_edits", True)),
                "auto_pipeline_enabled": bool(getattr(self, "auto_pipeline_enabled", True)),
                "auto_analyze_on_open": bool(getattr(self, "auto_analyze_on_open", True)),
                "auto_sync_multiclass_on_save": bool(getattr(self, "auto_sync_multiclass_on_save", True)),
                "auto_pipeline_require_confirm": bool(getattr(self, "auto_pipeline_require_confirm", True)),
                "auto_detect_retrain_enabled": bool(getattr(self, "auto_detect_retrain_enabled", True)),
                "auto_toothcls_train_enabled": bool(getattr(self, "auto_toothcls_train_enabled", True)),
                "auto_detect_retrain_threshold": int(getattr(self, "auto_detect_retrain_threshold", 8) or 8),
                "auto_toothcls_train_threshold": int(getattr(self, "auto_toothcls_train_threshold", 30) or 30),
                "auto_detect_min_interval_s": int(getattr(self, "auto_detect_min_interval_s", 6 * 3600) or 0),
                "auto_toothcls_min_interval_s": int(getattr(self, "auto_toothcls_min_interval_s", 12 * 3600) or 0),
                "auto_detect_save_count": int(getattr(self, "_auto_detect_save_count", 0) or 0),
                "auto_toothcls_save_count": int(getattr(self, "_auto_toothcls_save_count", 0) or 0),
                "auto_detect_last_train_ts": float(getattr(self, "_auto_detect_last_train_ts", 0.0) or 0.0),
                "auto_toothcls_last_train_ts": float(getattr(self, "_auto_toothcls_last_train_ts", 0.0) or 0.0),
                "comm_confirm_new_commands": bool(getattr(self, "comm_confirm_new_commands", True)),
                "comm_confirm_threshold": int(getattr(self, "comm_confirm_threshold", 1) or 1),
                "comm_confirm_counts": getattr(self, "comm_confirm_counts", {}) if isinstance(getattr(self, "comm_confirm_counts", None), dict) else {},
                "comm_tts_backend": str(getattr(self, "comm_tts_backend", "qt") or "qt").strip() or "qt",
                "comm_tts_voice_id": str(getattr(self, "comm_tts_voice_id", "") or "").strip(),
                "comm_piper_cli": str(getattr(self, "comm_piper_cli", "") or "").strip(),
                "comm_piper_voice_model": str(getattr(self, "comm_piper_voice_model", "") or "").strip(),
                "comm_piper_length_scale": float(getattr(self, "comm_piper_length_scale", 0.0)) if getattr(self, "comm_piper_length_scale", None) is not None else None,
                "comm_tts_rate": float(getattr(self, "comm_tts_rate", 0.0) or 0.0),
                "comm_tts_volume": float(getattr(self, "comm_tts_volume", 1.0) or 1.0),
                "comm_templates": self.comm_templates if isinstance(getattr(self, "comm_templates", None), dict) else {},
                "comm_last_template": str(getattr(self, "comm_last_template", "") or ""),
                "comm_aliases": self.comm_aliases if isinstance(getattr(self, "comm_aliases", None), dict) else {},
                "comm_macros": self.comm_macros if isinstance(getattr(self, "comm_macros", None), dict) else {},
                "comm_ai_enabled": bool(getattr(self, "comm_ai_enabled", False)),
                "comm_ai_auto_execute": bool(getattr(self, "comm_ai_auto_execute", False)),
                "comm_advanced_expanded": bool(getattr(self, "_comm_advanced_expanded_pref", False)),
                "comm_learning_enabled": bool(getattr(self, "comm_learning_enabled", True)),
                "comm_learning_auto_accept": bool(getattr(self, "comm_learning_auto_accept", False)),
                "comm_conversation_enabled": bool(getattr(self, "comm_conversation_enabled", True)),
                "comm_ai_stream_enabled": bool(getattr(self, "comm_ai_stream_enabled", True)),
                "comm_chat_visible": bool(getattr(self, "comm_chat_visible", False)),
                "comm_ai_backend_mode": str(getattr(self, "comm_ai_backend_mode", "hybrid") or "hybrid"),
                "comm_cloud_api_base": str(getattr(self, "comm_cloud_api_base", "https://api.openai.com/v1") or "https://api.openai.com/v1"),
                "comm_cloud_model": str(getattr(self, "comm_cloud_model", "gpt-4o-mini") or "gpt-4o-mini"),
                "comm_cloud_api_key_dpapi": str(getattr(self, "_comm_cloud_api_key_dpapi", "") or "").strip(),
                "comm_llm_url": str(getattr(self, "comm_llm_url", "") or "").strip(),
                "comm_llm_model": str(getattr(self, "comm_llm_model", "") or "").strip(),
                "comm_llm_system_prompt": str(getattr(self, "comm_llm_system_prompt", "") or "").strip(),
                "comm_memory_text": str(getattr(self, "comm_memory_text", "") or "").strip(),
                "comm_ai_messages": [
                    {"role": str((m or {}).get("role") or ""), "content": str((m or {}).get("content") or "")}
                    for m in ((getattr(self, "_ai_messages", None) or [])[-20:])
                    if isinstance(m, dict) and str((m or {}).get("role") or "") in ("user", "assistant") and str((m or {}).get("content") or "").strip()
                ],
                "comm_patient_memory": {
                    str(k): str(v or "").strip()[:2000]
                    for k, v in (pmem or {}).items()
                    if str(k).strip()
                },
                "comm_patient_ai_messages": {
                    str(pk): [
                        {"role": str((m or {}).get("role") or ""), "content": str((m or {}).get("content") or "")}
                        for m in ((lst or [])[-20:])
                        if isinstance(m, dict) and str((m or {}).get("role") or "") in ("user", "assistant") and str((m or {}).get("content") or "").strip()
                    ]
                    for pk, lst in (pmsg or {}).items()
                    if str(pk).strip() and isinstance(lst, list)
                },
                "layout_snapshot_by_patient": getattr(self, "layout_snapshot_by_patient", {}) if isinstance(getattr(self, "layout_snapshot_by_patient", None), dict) else {},
            }
            with open(tmp_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                f.flush()
                os.fsync(f.fileno())
            os.replace(tmp_path, prefs_path)
        except Exception:
            pass

    def _schedule_prefs_save(self, delay_ms: int = 800):
        try:
            if getattr(self, "_prefs_save_timer", None) is None:
                self._prefs_save_timer = QTimer(self)
                self._prefs_save_timer.setSingleShot(True)
                self._prefs_save_timer.timeout.connect(self._save_viewer_prefs)
            self._prefs_save_timer.start(max(0, int(delay_ms)))
        except Exception:
            pass

    def _apply_left_splitter_prefs(self):
        try:
            sp = getattr(self, "left_splitter", None)
            if sp is None:
                return
            sizes = getattr(self, "_left_splitter_sizes_pref", None)
            if isinstance(sizes, list) and len(sizes) >= 2:
                a = int(sizes[0] or 0)
                b = int(sizes[1] or 0)
                if a > 0 and b > 0:
                    total = a + b
                    min_top = 180
                    min_bot = 140
                    if total - min_bot < min_top:
                        min_top = max(140, int(total * 0.60))
                        min_bot = max(120, total - min_top)
                    if b < min_bot:
                        b = min_bot
                        a = max(min_top, total - b)
                    if a < min_top:
                        a = min_top
                        b = max(min_bot, total - a)
                    sp.setSizes([a, b])
                    self._left_splitter_sizes = [int(a), int(b)]
        except Exception:
            pass

    def _on_left_splitter_moved(self):
        try:
            sp = getattr(self, "left_splitter", None)
            if sp is None:
                return
            sizes = sp.sizes()
            if isinstance(sizes, list) and len(sizes) >= 2:
                a = int(sizes[0] or 0)
                b = int(sizes[1] or 0)
                if a > 0 and b > 0:
                    total = a + b
                    min_top = 180
                    min_bot = 140
                    if total - min_bot < min_top:
                        min_top = max(140, int(total * 0.60))
                        min_bot = max(120, total - min_top)
                    if b < min_bot:
                        b = min_bot
                        a = max(min_top, total - b)
                        try:
                            sp.setSizes([a, b])
                        except Exception:
                            pass
                    if a < min_top:
                        a = min_top
                        b = max(min_bot, total - a)
                        try:
                            sp.setSizes([a, b])
                        except Exception:
                            pass
                    self._left_splitter_sizes = [int(a), int(b)]
                    self._schedule_prefs_save(900)
        except Exception:
            pass

    def _apply_main_splitter_prefs(self):
        try:
            sp = getattr(self, "main_splitter", None)
            if sp is None:
                return
            sizes = getattr(self, "_main_splitter_sizes_pref", None)
            if isinstance(sizes, list) and len(sizes) >= 2:
                a = int(sizes[0] or 0)
                b = int(sizes[1] or 0)
                if a > 0 and b > 0:
                    total = a + b
                    min_left = 320
                    min_right = 520
                    if total - min_right < min_left:
                        min_left = max(300, int(total * 0.30))
                        min_right = max(480, total - min_left)
                    if a < min_left:
                        a = min_left
                        b = max(min_right, total - a)
                    if b < min_right:
                        b = min_right
                        a = max(min_left, total - b)
                    sp.setSizes([a, b])
                    self._main_splitter_sizes = [int(a), int(b)]
        except Exception:
            pass

    def _on_main_splitter_moved(self):
        try:
            sp = getattr(self, "main_splitter", None)
            if sp is None:
                return
            sizes = sp.sizes()
            if isinstance(sizes, list) and len(sizes) >= 2:
                a = int(sizes[0] or 0)
                b = int(sizes[1] or 0)
                if a > 0 and b > 0:
                    total = a + b
                    min_left = 320
                    min_right = 520
                    if total - min_right < min_left:
                        min_left = max(300, int(total * 0.30))
                        min_right = max(480, total - min_left)
                    if a < min_left:
                        a = min_left
                        b = max(min_right, total - a)
                        try:
                            sp.setSizes([a, b])
                        except Exception:
                            pass
                    if b < min_right:
                        b = min_right
                        a = max(min_left, total - b)
                        try:
                            sp.setSizes([a, b])
                        except Exception:
                            pass
                    self._main_splitter_sizes = [int(a), int(b)]
                    self._schedule_prefs_save(900)
        except Exception:
            pass

    def _apply_right_splitter_prefs(self):
        try:
            sp = getattr(self, "right_splitter", None)
            if sp is None:
                return
            sizes = getattr(self, "_right_splitter_sizes_pref", None)
            if isinstance(sizes, list) and len(sizes) >= 2:
                a = int(sizes[0] or 0)
                b = int(sizes[1] or 0)
                if a > 0 and b > 0:
                    total_avail = 0
                    try:
                        total_avail = int(sp.size().height() or 0)
                    except Exception:
                        total_avail = 0
                    if total_avail <= 0:
                        total_avail = a + b
                    min_top = 260
                    min_bot = 220
                    if total_avail - min_bot < min_top:
                        min_top = max(180, int(total_avail * 0.55))
                        min_bot = max(160, total_avail - min_top)
                    if b < min_bot:
                        b = min_bot
                        a = max(min_top, total_avail - b)
                    if a < min_top:
                        a = min_top
                        b = max(min_bot, total_avail - a)
                    sp.setSizes([a, b])
                    self._right_splitter_sizes = [int(a), int(b)]
                    return
            preset = str(getattr(self, "_ui_right_preset", "") or "").strip().lower()
            if preset in ("panorama", "chat", "balance"):
                self._set_right_preset(preset, save=False)
        except Exception:
            pass

    def _on_right_splitter_moved(self):
        try:
            sp = getattr(self, "right_splitter", None)
            if sp is None:
                return
            sizes = sp.sizes()
            if isinstance(sizes, list) and len(sizes) >= 2:
                a = int(sizes[0] or 0)
                b = int(sizes[1] or 0)
                if a > 0 and b > 0:
                    total_avail = a + b
                    min_top = 260
                    min_bot = 220
                    if total_avail - min_bot < min_top:
                        min_top = max(180, int(total_avail * 0.55))
                        min_bot = max(160, total_avail - min_top)
                    if b < min_bot:
                        b = min_bot
                        a = max(min_top, total_avail - b)
                        try:
                            sp.setSizes([a, b])
                        except Exception:
                            pass
                    if a < min_top:
                        a = min_top
                        b = max(min_bot, total_avail - a)
                        try:
                            sp.setSizes([a, b])
                        except Exception:
                            pass
                    self._right_splitter_sizes = [int(a), int(b)]
                    self._ui_right_preset = ""
                    self._schedule_prefs_save(900)
        except Exception:
            pass

    def _set_right_preset(self, preset: str, save: bool = True):
        try:
            sp = getattr(self, "right_splitter", None)
            if sp is None:
                return
            p = str(preset or "").strip().lower()
            total = 0
            try:
                total = int(sp.size().height() or 0)
            except Exception:
                total = 0
            if total <= 0:
                try:
                    sizes = sp.sizes()
                    if isinstance(sizes, list):
                        total = int(sum(int(x or 0) for x in sizes))
                except Exception:
                    total = 0
            if total <= 0:
                total = 1200
            min_top = 200
            min_bot = 140
            if p == "balance":
                factor = 0.50
            elif p == "chat":
                factor = 0.32
            else:
                factor = 0.72
                p = "panorama"
            try:
                top = int(total * float(factor))
            except Exception:
                top = int(total * 0.60)
            if total - min_bot < min_top:
                min_top = max(120, int(total * 0.55))
                min_bot = max(100, total - min_top)
            top = max(min_top, min(top, max(min_top, total - min_bot)))
            bot = max(min_bot, total - top)
            def _apply():
                try:
                    sp.setSizes([int(top), int(bot)])
                except Exception:
                    pass
                try:
                    sp.update()
                except Exception:
                    pass
                try:
                    if hasattr(self, "layout_save_label") and self.layout_save_label is not None:
                        name = "Πανόραμα"
                        if p == "chat":
                            name = "Συνομιλία"
                        if p == "balance":
                            name = "Ισορροπία"
                        try:
                            cur = sp.sizes()
                            if isinstance(cur, list) and len(cur) >= 2:
                                self.layout_save_label.setText(f"Preset: {name} ({int(cur[0])}/{int(cur[1])})")
                            else:
                                self.layout_save_label.setText(f"Preset: {name}")
                        except Exception:
                            self.layout_save_label.setText(f"Preset: {name}")
                        QTimer.singleShot(1200, self._clear_layout_save_label)
                except Exception:
                    pass
            _apply()
            try:
                QTimer.singleShot(60, _apply)
                QTimer.singleShot(220, _apply)
            except Exception:
                pass
            self._right_splitter_sizes = [top, bot]
            self._ui_right_preset = p
            if save:
                self._schedule_prefs_save(250)
            try:
                name = "Πανόραμα"
                if p == "chat":
                    name = "Συνομιλία"
                if p == "balance":
                    name = "Ισορροπία"
                self._announce_action_done(f"Preset: {name}")
            except Exception:
                pass
        except Exception:
            pass

    def _load_gray_uint8_for_path(self, file_path: str):
        return _worker_load_gray_uint8_for_path(file_path)

    def _find_latest_analysis_json(self, exclude_current: bool = True) -> str:
        try:
            base_dir = str(getattr(self, "radiograph_path", "") or "").strip()
            if not base_dir or not os.path.isdir(base_dir):
                return ""
        except Exception:
            return ""
        cur_json = ""
        if exclude_current:
            try:
                if getattr(self, "current_image_path", None):
                    cur_json = os.path.splitext(str(self.current_image_path))[0] + "_analysis.json"
            except Exception:
                cur_json = ""
        best = ("", 0.0)
        try:
            for fn in os.listdir(base_dir):
                if not str(fn).lower().endswith("_analysis.json"):
                    continue
                p = os.path.join(base_dir, fn)
                if exclude_current and cur_json and os.path.normcase(p) == os.path.normcase(cur_json):
                    continue
                try:
                    m = float(os.path.getmtime(p))
                except Exception:
                    m = 0.0
                if m > best[1]:
                    best = (p, m)
        except Exception:
            return ""
        return str(best[0] or "")

    def _compute_prev_to_current_affine(self, prev_gray: np.ndarray, cur_gray: np.ndarray):
        return _worker_compute_prev_to_current_affine(prev_gray, cur_gray)

    def _clear_change_overlay(self):
        try:
            self._clear_change_hotspots()
        except Exception:
            pass
        try:
            it = getattr(self, "change_overlay_item", None)
            if it is not None and it.scene() == self.scene:
                self._safe_remove_scene_item(it)
        except Exception:
            pass
        try:
            self.change_overlay_item = None
        except Exception:
            pass
        try:
            self._change_overlay_cache_key = ""
            self._change_overlay_cached_pixmap = None
            self._change_overlay_cached_heat = None
        except Exception:
            pass

    def _clear_change_hotspots(self):
        try:
            for it in list(getattr(self, "change_hotspot_items", []) or []):
                try:
                    if it is not None and it.scene() == self.scene:
                        self._safe_remove_scene_item(it)
                except Exception:
                    pass
        except Exception:
            pass
        try:
            self.change_hotspot_items = []
        except Exception:
            pass
        try:
            self.change_hotspots = []
        except Exception:
            pass
        try:
            self._update_hotspot_picker([])
        except Exception:
            pass

    def _update_hotspot_picker(self, hotspots):
        cb = getattr(self, "hotspot_combo", None)
        if cb is None:
            return
        hs = list(hotspots or [])
        try:
            cb.blockSignals(True)
        except Exception:
            pass
        try:
            cb.clear()
        except Exception:
            pass
        if not hs:
            try:
                cb.addItem("Hotspots: κανένα", 0)
            except Exception:
                pass
            try:
                cb.setEnabled(False)
            except Exception:
                pass
            try:
                cb.blockSignals(False)
            except Exception:
                pass
            return
        try:
            cb.addItem("Επιλογή hotspot…", 0)
        except Exception:
            pass
        for i in range(1, min(5, len(hs)) + 1):
            try:
                desc = str((hs[i - 1] or {}).get("desc") or "").strip()
                label = f"Hotspot {i}" + (f" — {desc}" if desc else "")
                cb.addItem(label, i)
            except Exception:
                pass
        try:
            cb.setCurrentIndex(0)
        except Exception:
            pass
        try:
            cb.setEnabled(True)
        except Exception:
            pass
        try:
            cb.blockSignals(False)
        except Exception:
            pass

    def _on_hotspot_combo_activated(self, idx: int):
        cb = getattr(self, "hotspot_combo", None)
        if cb is None:
            return
        try:
            val = cb.currentData()
        except Exception:
            val = None
        try:
            n = int(val or 0)
        except Exception:
            n = 0
        if n <= 0:
            return
        try:
            self.jump_to_change_hotspot(n)
        except Exception:
            pass
        try:
            cb.blockSignals(True)
            cb.setCurrentIndex(0)
            cb.blockSignals(False)
        except Exception:
            pass

    def _compute_change_hotspots(self, heat: np.ndarray, max_n: int = 5):
        if heat is None:
            return []
        try:
            h, w = heat.shape[:2]
        except Exception:
            return []
        if w <= 0 or h <= 0:
            return []
        max_n = max(1, min(8, int(max_n)))

        def _quadrant_desc(cx: float, cy: float) -> str:
            try:
                vx = None; jy = None
                if self.vertical_separator_line and self.vertical_separator_line.scene() == self.scene:
                    vx = float(self.vertical_separator_line.pos().x())
                if self.jaw_separator_line and self.jaw_separator_line.scene() == self.scene:
                    try:
                        jy = float(self.jaw_separator_line.get_y_at_x(cx))
                    except Exception:
                        jy = float(self.jaw_separator_line.pos().y())
                if vx is None:
                    vx = float(w) / 2.0
                if jy is None:
                    jy = float(h) / 2.0
                side = "δεξιά" if cx > vx else "αριστερά"
                arch = "άνω" if cy < jy else "κάτω"
                return f"{arch} {side}"
            except Exception:
                return "—"

        if cv2 is not None:
            try:
                thr = 0.55
                mask = (heat > float(thr)).astype(np.uint8) * 255
                k = max(3, int(round(min(h, w) * 0.01)) | 1)
                kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (k, k))
                mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1)
                num, labels, stats, _ = cv2.connectedComponentsWithStats(mask, connectivity=8)
                out = []
                min_area = max(80, int((h * w) * 0.0004))
                for i in range(1, int(num)):
                    x = int(stats[i, cv2.CC_STAT_LEFT])
                    y = int(stats[i, cv2.CC_STAT_TOP])
                    ww = int(stats[i, cv2.CC_STAT_WIDTH])
                    hh = int(stats[i, cv2.CC_STAT_HEIGHT])
                    area = int(stats[i, cv2.CC_STAT_AREA])
                    if area < min_area:
                        continue
                    try:
                        score = float(np.sum(heat[labels == i]))
                    except Exception:
                        score = float(area)
                    cx = float(x + ww / 2)
                    cy = float(y + hh / 2)
                    out.append({"bbox": [float(x), float(y), float(x + ww), float(y + hh)], "center": [cx, cy], "score": score, "desc": _quadrant_desc(cx, cy)})
                out.sort(key=lambda d: float(d.get("score", 0.0)), reverse=True)
                return out[:max_n]
            except Exception:
                pass

        try:
            step = 18
            gh = max(1, h // step)
            gw = max(1, w // step)
            pooled = heat[: gh * step, : gw * step].reshape(gh, step, gw, step).max(axis=(1, 3))
            flat = pooled.reshape(-1)
            if flat.size <= 0:
                return []
            k = min(max_n, int(flat.size))
            idxs = np.argpartition(-flat, range(k))[:k]
            out = []
            for ridx in idxs:
                r = int(ridx) // int(gw)
                c = int(ridx) % int(gw)
                x1 = float(c * step)
                y1 = float(r * step)
                x2 = float(min(w, (c + 1) * step))
                y2 = float(min(h, (r + 1) * step))
                cx = (x1 + x2) / 2.0
                cy = (y1 + y2) / 2.0
                out.append({"bbox": [x1, y1, x2, y2], "center": [cx, cy], "score": float(flat[int(ridx)]), "desc": _quadrant_desc(cx, cy)})
            out.sort(key=lambda d: float(d.get("score", 0.0)), reverse=True)
            return out[:max_n]
        except Exception:
            return []

    def _render_change_hotspots(self, hotspots):
        self._clear_change_hotspots()
        if not hotspots:
            return
        out = []
        try:
            for i, hs in enumerate(list(hotspots)[:5], start=1):
                bbox = hs.get("bbox") or []
                ctr = hs.get("center") or []
                if len(bbox) != 4 or len(ctr) != 2:
                    continue
                x1, y1, x2, y2 = [float(x) for x in bbox]
                cx, cy = float(ctr[0]), float(ctr[1])
                rect = QRectF(x1, y1, max(1.0, x2 - x1), max(1.0, y2 - y1))
                r = float(max(10.0, min(18.0, 6.0 + math.sqrt(max(1.0, rect.width() * rect.height())) * 0.05)))
                it = ChangeHotspotMarkerItem(self, i, rect, cx, cy, r=r)
                self.scene.addItem(it)
                out.append(it)
        except Exception:
            out = []
        self.change_hotspot_items = out
        self.change_hotspots = hotspots[: len(out)]
        try:
            self._update_hotspot_picker(self.change_hotspots)
        except Exception:
            pass

    def jump_to_change_hotspot(self, idx: int):
        try:
            n = int(idx)
        except Exception:
            n = 0
        if n <= 0:
            return
        hs = None
        try:
            arr = getattr(self, "change_hotspots", None) or []
            if 1 <= n <= len(arr):
                hs = arr[n - 1]
        except Exception:
            hs = None
        if not hs:
            return
        bbox = hs.get("bbox") or []
        if len(bbox) != 4:
            return
        try:
            x1, y1, x2, y2 = [float(x) for x in bbox]
        except Exception:
            return
        rect = QRectF(x1, y1, max(2.0, x2 - x1), max(2.0, y2 - y1))
        pad = max(20.0, min(120.0, max(rect.width(), rect.height()) * 0.8))
        try:
            r2 = rect.adjusted(-pad, -pad, pad, pad)
            self.view.fitInView(r2, Qt.AspectRatioMode.KeepAspectRatio)
        except Exception:
            try:
                self.view.centerOn(QPointF((x1 + x2) / 2.0, (y1 + y2) / 2.0))
            except Exception:
                pass

    def _build_change_overlay_pixmap(self, prev_gray: np.ndarray, cur_gray: np.ndarray, M):
        try:
            pctl = float(getattr(self, "change_overlay_percentile", 92.0) or 92.0)
            alpha = float(getattr(self, "change_overlay_alpha", 0.45) or 0.45)
            qimg, heat = _worker_build_change_overlay_pixmap(prev_gray, cur_gray, M, pctl, alpha)
            if qimg is None:
                return None, None
            return QPixmap.fromImage(qimg), heat
        except Exception:
            return None, None

    def on_change_overlay_ready(self, qimg, heat, cache_key):
        if not cache_key or cache_key != str(getattr(self, "_change_overlay_cache_key", "") or ""):
            return
        
        try:
            if qimg is None:
                self._clear_change_overlay()
                if hasattr(self, "results_text_edit") and self.results_text_edit:
                    self.results_text_edit.append("ℹ️ Αλλαγές: δεν βρέθηκαν αρκετές διαφορές ή δεν υπάρχει προηγούμενη εικόνα.")
                return

            # Convert QImage to QPixmap if needed (async result is QImage, cache is QPixmap)
            pix = None
            if isinstance(qimg, QPixmap):
                pix = qimg
            elif qimg:
                pix = QPixmap.fromImage(qimg)
            
            if pix is None or pix.isNull():
                self._clear_change_overlay()
                return

            self._change_overlay_cached_pixmap = pix
            self._change_overlay_cached_heat = heat
            
            try:
                self._clear_change_overlay()
            except Exception:
                pass
                
            try:
                it = QGraphicsPixmapItem(pix)
                it.setPos(0, 0)
                it.setZValue(-9)
                self.scene.addItem(it)
                self.change_overlay_item = it
            except Exception:
                self._clear_change_overlay()
                return

            try:
                hs = self._compute_change_hotspots(heat, max_n=5)
                self._render_change_hotspots(hs)
                if hs:
                    msg = "Hotspots αλλαγών: " + ", ".join(str(i) for i in range(1, min(5, len(hs)) + 1)) + " (κλικ ή /spot N)"
                else:
                    msg = "Hotspots αλλαγών: κανένα"
                try:
                    if hasattr(self, "results_text_edit") and self.results_text_edit is not None and not bool(getattr(self, "analysis_results", None)):
                        self.results_text_edit.append(msg)
                except Exception:
                    pass
            except Exception:
                pass
                
        except Exception as e:
            print(f"Error applying change overlay: {e}")
            self._clear_change_overlay()

    def _start_change_overlay_worker(self, prev_path, cur_path, cache_key):
        if hasattr(self, "change_overlay_worker") and self.change_overlay_worker is not None:
             if self.change_overlay_worker.isRunning():
                 self.change_overlay_worker.terminate()
                 self.change_overlay_worker.wait(200)
        
        pctl = float(getattr(self, "change_overlay_percentile", 92.0) or 92.0)
        alpha = float(getattr(self, "change_overlay_alpha", 0.45) or 0.45)
        
        self.change_overlay_worker = ChangeOverlayWorker(prev_path, cur_path, pctl, alpha, cache_key)
        self.change_overlay_worker.finished_signal.connect(self.on_change_overlay_ready)
        self.change_overlay_worker.start()

    def toggle_change_overlay(self, checked: bool = False):
        want = bool(checked)
        try:
            if hasattr(self, "change_overlay_button") and self.change_overlay_button is not None:
                want = bool(self.change_overlay_button.isChecked())
        except Exception:
            pass
        try:
            if hasattr(self, "change_overlay_quick_button") and self.change_overlay_quick_button is not None:
                want = bool(self.change_overlay_quick_button.isChecked())
        except Exception:
            pass
        try:
            if hasattr(self, "change_overlay_button") and self.change_overlay_button is not None:
                self.change_overlay_button.blockSignals(True)
                self.change_overlay_button.setChecked(bool(want))
                self.change_overlay_button.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "change_overlay_quick_button") and self.change_overlay_quick_button is not None:
                self.change_overlay_quick_button.blockSignals(True)
                self.change_overlay_quick_button.setChecked(bool(want))
                self.change_overlay_quick_button.blockSignals(False)
        except Exception:
            pass
        if not want:
            self._clear_change_overlay()
            try:
                self.change_overlay_enabled = False
                self._schedule_prefs_save(0)
            except Exception:
                pass
            return

        try:
            self.change_overlay_enabled = True
            self._schedule_prefs_save(0)
        except Exception:
            pass

        prev_json = self._find_latest_analysis_json(exclude_current=True)
        if not prev_json or not os.path.exists(prev_json):
            self._clear_change_overlay()
            return

        cache_key = ""
        try:
            cache_key = f"{os.path.normcase(str(getattr(self, 'current_image_path', '') or ''))}|{os.path.normcase(prev_json)}|{int(os.path.getmtime(prev_json))}"
        except Exception:
            cache_key = f"{os.path.normcase(str(getattr(self, 'current_image_path', '') or ''))}|{os.path.normcase(prev_json)}"

        self._change_overlay_cache_key = cache_key

        if getattr(self, "_change_overlay_cached_pixmap", None) is not None:
            self.on_change_overlay_ready(getattr(self, "_change_overlay_cached_pixmap", None), getattr(self, "_change_overlay_cached_heat", None), cache_key)
        else:
            try:
                with open(prev_json, "r", encoding="utf-8") as f:
                    prev_data = json.load(f) or {}
            except Exception:
                prev_data = {}
            prev_img_path = str((prev_data or {}).get("image_path") or "").strip()
            if not prev_img_path or not os.path.exists(prev_img_path):
                try:
                    stem = prev_json[:-len("_analysis.json")] if prev_json.lower().endswith("_analysis.json") else ""
                    for ext in (".jpg", ".jpeg", ".png", ".bmp", ".tif", ".tiff", ".jfif", ".dcm"):
                        cand = stem + ext
                        if cand and os.path.exists(cand):
                            prev_img_path = cand
                            break
                except Exception:
                    pass
            
            if hasattr(self, "results_text_edit") and self.results_text_edit is not None:
                self.results_text_edit.append("⏳ Υπολογισμός αλλαγών...")
                
            self._start_change_overlay_worker(prev_img_path, getattr(self, "current_image_path", None), cache_key)

    def transfer_previous_analysis(self):
        if not getattr(self, "current_image_path", None):
            return
        prev_json = self._find_latest_analysis_json(exclude_current=True)
        if not prev_json or not os.path.exists(prev_json):
            try:
                self._announce_action_failed("Μεταφορά: δεν βρέθηκε προηγούμενη ανάλυση")
            except Exception:
                pass
            return
        try:
            with open(prev_json, "r", encoding="utf-8") as f:
                prev_data = json.load(f) or {}
        except Exception:
            prev_data = {}
        if not isinstance(prev_data, dict):
            prev_data = {}

        prev_img_path = str(prev_data.get("image_path") or "").strip()
        if not prev_img_path or not os.path.exists(prev_img_path):
            try:
                base = str(prev_json)
                if base.lower().endswith("_analysis.json"):
                    stem = base[:-len("_analysis.json")]
                    for ext in (".jpg", ".jpeg", ".png", ".bmp", ".tif", ".tiff", ".jfif", ".dcm"):
                        cand = stem + ext
                        if os.path.exists(cand):
                            prev_img_path = cand
                            break
            except Exception:
                pass

        prev_gray = self._load_gray_uint8_for_path(prev_img_path)
        cur_gray = self._load_gray_uint8_for_path(self.current_image_path)
        M = self._compute_prev_to_current_affine(prev_gray, cur_gray)
        if M is None:
            try:
                ph, pw = prev_gray.shape[:2]
                ch, cw = cur_gray.shape[:2]
                sx = float(cw) / float(pw) if pw else 1.0
                sy = float(ch) / float(ph) if ph else 1.0
            except Exception:
                sx, sy = 1.0, 1.0
            M = np.array([[sx, 0.0, 0.0], [0.0, sy, 0.0]], dtype=np.float64)

        boxes = prev_data.get("boxes", []) or []
        fdis = prev_data.get("fdi", []) or []
        statuses = prev_data.get("statuses", []) or []
        notes = prev_data.get("notes", []) or []
        last_updated = prev_data.get("last_updated", []) or []
        label_offsets = prev_data.get("label_offsets", []) or []

        try:
            ch, cw = cur_gray.shape[:2]
        except Exception:
            try:
                br = self.pixmap_item.boundingRect() if self.pixmap_item else QRectF()
                cw = int(br.width())
                ch = int(br.height())
            except Exception:
                cw, ch = 0, 0

        new_boxes = []
        new_labels = []
        new_statuses = []
        new_notes = []
        new_last = []
        new_offsets = []
        for i, box in enumerate(boxes):
            try:
                x1, y1, x2, y2 = [float(c) for c in box]
            except Exception:
                continue
            pts = np.array([[x1, y1], [x2, y1], [x2, y2], [x1, y2]], dtype=np.float64)
            try:
                pts2 = (pts @ M[:, :2].T) + M[:, 2]
            except Exception:
                continue
            nx1 = float(np.min(pts2[:, 0]))
            ny1 = float(np.min(pts2[:, 1]))
            nx2 = float(np.max(pts2[:, 0]))
            ny2 = float(np.max(pts2[:, 1]))
            if cw > 0 and ch > 0:
                nx1 = max(0.0, min(float(cw - 1), nx1))
                nx2 = max(0.0, min(float(cw - 1), nx2))
                ny1 = max(0.0, min(float(ch - 1), ny1))
                ny2 = max(0.0, min(float(ch - 1), ny2))
            if (nx2 - nx1) < 4 or (ny2 - ny1) < 4:
                continue
            new_boxes.append([nx1, ny1, nx2, ny2])
            lbl = str(fdis[i]).strip() if i < len(fdis) else "?"
            new_labels.append(lbl if lbl else "?")
            new_statuses.append(statuses[i] if i < len(statuses) else [])
            new_notes.append(str(notes[i]) if i < len(notes) else "")
            new_last.append(str(last_updated[i]) if i < len(last_updated) else "")
            new_offsets.append(label_offsets[i] if i < len(label_offsets) else [0.0, -20.0])

        if not new_boxes:
            try:
                self._announce_action_failed("Μεταφορά: δεν βρέθηκαν έγκυρα πλαίσια από την προηγούμενη ανάλυση")
            except Exception:
                pass
            return

        res = {
            "device": "transferred",
            "boxes": new_boxes,
            "labels": new_labels,
            "scores": [1.0 for _ in range(len(new_boxes))],
            "fdi": list(new_labels),
            "statuses": new_statuses,
            "bypass_grid": [True for _ in range(len(new_boxes))],
            "notes": new_notes,
            "last_updated": new_last,
            "label_offsets": new_offsets,
            "debug": {"transfer_from": os.path.basename(prev_img_path or prev_json or ""), "transfer_boxes": int(len(new_boxes))},
        }

        try:
            self.analysis_results = res
            self.raw_analysis_results = copy.deepcopy(res)
        except Exception:
            pass
        try:
            self.display_analysis_results(res)
        except Exception:
            pass
        try:
            self.save_analysis_button.setEnabled(True)
        except Exception:
            pass
        try:
            self.clear_analysis_button.setEnabled(True)
        except Exception:
            pass

    def add_new_radiograph(self):
        if not self._ensure_radiograph_dir():
            QMessageBox.warning(self, "Σφάλμα", "Δεν βρέθηκε/δεν δημιουργήθηκε φάκελος ακτινογραφιών.")
            return
        started = None
        try:
            started = time.perf_counter()
        except Exception:
            started = None
        initial_dir = ""
        try:
            p = str(getattr(self, "last_radiograph_import_dir", "") or "").strip()
            if p and os.path.isdir(p):
                initial_dir = p
        except Exception:
            initial_dir = ""
        if not initial_dir:
            try:
                cur = str(getattr(self, "current_image_path", "") or "").strip()
                if cur and os.path.exists(cur):
                    initial_dir = os.path.dirname(cur)
            except Exception:
                initial_dir = ""
        file_path, _ = QFileDialog.getOpenFileName(self, "Επιλογή Ακτινογραφίας", initial_dir, "Images (*.jpg *.jpeg *.png *.bmp *.dcm *.tif *.tiff *.jfif)")
        if not file_path:
            try:
                self._announce_action_done("Προσθήκη ακτινογραφίας: ακυρώθηκε", elapsed_ms=(time.perf_counter() - started) * 1000.0 if started else None)
            except Exception:
                pass
            return
        try:
            pdir = os.path.dirname(str(file_path))
            if pdir and os.path.isdir(pdir):
                self.last_radiograph_import_dir = pdir
                self._schedule_prefs_save(0)
        except Exception:
            pass
        dest_dir = getattr(self, "radiograph_path", None)
        if not dest_dir or not os.path.isdir(str(dest_dir)):
            QMessageBox.warning(self, "Σφάλμα", "Δεν βρέθηκε φάκελος ακτινογραφιών για προσθήκη.")
            return
        try:
            base = os.path.basename(str(file_path))
            base = base.strip() or "radiograph"
            name, ext = os.path.splitext(base)
            ext_low = str(ext or "").lower()
            allowed = {'.jpg', '.jpeg', '.png', '.bmp', '.dcm', '.tif', '.tiff', '.jfif'}
            if ext_low and ext_low not in allowed:
                QMessageBox.warning(self, "Μη υποστηριζόμενος τύπος", f"Ο τύπος αρχείου {ext} δεν υποστηρίζεται.")
                return

            dest_path = os.path.join(str(dest_dir), base)
            if os.path.exists(dest_path):
                i = 1
                while True:
                    candidate = os.path.join(str(dest_dir), f"{name}_{i}{ext}")
                    if not os.path.exists(candidate):
                        dest_path = candidate
                        break
                    i += 1

            shutil.copy2(file_path, dest_path)
            self.load_images_from_directory()
            added_name = os.path.basename(dest_path)
            for i in range(self.image_list_widget.count()):
                it = self.image_list_widget.item(i)
                if it and str(it.text() or "") == added_name:
                    self.image_list_widget.setCurrentRow(i)
                    self.display_selected_image(it)
                    break
            self._announce_action_done(f"Προσθήκη ακτινογραφίας: {added_name}", elapsed_ms=(time.perf_counter() - started) * 1000.0 if started else None)
        except Exception as e:
            try:
                self._announce_action_failed(f"Προσθήκη ακτινογραφίας: {e}")
            except Exception:
                pass
            QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία προσθήκης: {e}")

    def manage_duplicate_images(self):
        try:
            from app.widgets.duplicate_deletion_dialog import DuplicateDeletionDialog
            directory = getattr(self, "radiograph_path", None)
            if not directory or not os.path.isdir(str(directory)):
                if not self._ensure_radiograph_dir():
                    QMessageBox.warning(self, "Σφάλμα", "Δεν βρέθηκε/δεν δημιουργήθηκε φάκελος ακτινογραφιών.")
                    return
                directory = getattr(self, "radiograph_path", None)
            dlg = DuplicateDeletionDialog(str(directory), self)
            dlg.exec()
            try:
                self._announce_action_done("Διαχείριση διπλότυπων: ολοκληρώθηκε")
            except Exception:
                pass
        except ImportError:
            try:
                self._announce_action_failed("Διαχείριση διπλότυπων: μη διαθέσιμη λειτουργία")
            except Exception:
                pass
            QMessageBox.warning(self, "Σφάλμα", "Η λειτουργία δεν είναι διαθέσιμη.")

    def _start_scanning_animation(self):
        self._stop_scanning_animation()
        
        if not self.pixmap_item: return
        
        try:
            rect = self.pixmap_item.boundingRect()
            w = rect.width()
            h = rect.height()
            
            # Create Beam
            beam_w = w * 0.03 # 3% width (Thinner is more sci-fi)
            self.scanning_beam = ScanningBeamItem(QRectF(0, 0, beam_w, h))
            self.scanning_beam.setZValue(100) # Ensure it is on top
            self.scene.addItem(self.scanning_beam)
            
            # Animation State
            # 0: Center -> Right (Upper/Lower Right)
            # 1: Center -> Left (Upper/Lower Left)
            self.scan_phase = 0 
            self.scan_x = w / 2
            
            self.scan_timer = QTimer(self)
            self.scan_timer.setInterval(16) # ~60 FPS
            
            def _animate():
                if not getattr(self, "scanning_beam", None): return
                
                step = w * 0.015 # Speed
                
                if self.scan_phase == 0: # Right
                    self.scan_x += step
                    if self.scan_x > w:
                        self.scan_phase = 1
                        self.scan_x = w / 2
                else: # Left
                    self.scan_x -= step
                    if self.scan_x < 0:
                        self.scan_phase = 0
                        self.scan_x = w / 2
                
                self.scanning_beam.setPos(self.scan_x - beam_w/2, 0)
                
            self.scan_timer.timeout.connect(_animate)
            self.scan_timer.start()
        except Exception as e:
            print(f"Anim Error: {e}")

    def _stop_scanning_animation(self):
        try:
            if hasattr(self, 'scan_timer') and self.scan_timer:
                self.scan_timer.stop()
                self.scan_timer.deleteLater()
                self.scan_timer = None
                
            if hasattr(self, 'scanning_beam') and self.scanning_beam:
                try:
                    if self.scanning_beam.scene() == self.scene:
                        self.scene.removeItem(self.scanning_beam)
                except Exception:
                    pass
                self.scanning_beam = None
        except Exception:
            pass

    def _update_scanning_beam_pos(self, x, y, w, h, intensity=50, found_label=None):
        # Update the sci-fi beam to the actual scan position
        
        # Stop the "fake" animation loop since we have real data now
        if getattr(self, "scan_timer", None):
            self.scan_timer.stop()
            self.scan_timer = None
            
        if not getattr(self, "scanning_beam", None):
             # Create MANUALLY without starting animation loop
             # Use the tile rect as initial shape
             try:
                self.scanning_beam = ScanningBeamItem(QRectF(float(x), float(y), float(w), float(h)))
                self.scanning_beam.setZValue(100) # Ensure it is on top
                self.scene.addItem(self.scanning_beam)
             except Exception:
                pass
        else:
             # Ensure position is reset (animation moves it via setPos)
             self.scanning_beam.setPos(0, 0)
             self.scanning_beam.setZValue(100) # Ensure it is on top
            
        try:
            # User Request: "See the cells one by one"
            # We draw the TILE rectangle
            
            if found_label:
                # "Blink" Mode: Found something
                # Draw Box with label tooltip
                rect = QRectF(float(x), float(y), float(w), float(h))
                color = QColor(0, 255, 255, 60) # Cyan semi-transparent (more visible)
                self.scanning_beam.setRect(rect)
                self.scanning_beam.setBrush(QBrush(color))
                self.scanning_beam.setPen(QPen(QColor(0, 255, 255), 4))
                self.scanning_beam.setToolTip(f"Εντοπίστηκε: {found_label}")
            else:
                # Normal Scan Mode: Show the Tile
                rect = QRectF(float(x), float(y), float(w), float(h))
                
                # Color based on intensity (std dev)
                # Low intensity = empty/black area = faint gray
                # High intensity = teeth/bone = green/orange
                alpha = 80 # Increased alpha for better visibility
                if intensity > 60:
                    color = QColor(0, 255, 0, alpha) # Greenish for content
                else:
                    color = QColor(200, 200, 200, 30) # Faint gray for empty
                
                self.scanning_beam.setRect(rect)
                self.scanning_beam.setBrush(QBrush(color))
                self.scanning_beam.setPen(QPen(QColor(0, 255, 0, 200), 3, Qt.PenStyle.SolidLine)) # Thicker, solid line
                self.scanning_beam.setToolTip(f"Cell: {int(x)},{int(y)}")

        except Exception:
            pass

    def _ai_scan_quadrant_meta_for_rect(self, x: int, y: int, w: int, h: int) -> dict:
        out = {"phase": "Q1", "y1": None, "y2": None, "color": "#3498db", "title": "Q1"}
        try:
            if not getattr(self, "pixmap_item", None) or not getattr(self, "scene", None):
                return out
        except Exception:
            return out
        try:
            try:
                rect = self.pixmap_item.mapToScene(self.pixmap_item.boundingRect()).boundingRect()
            except Exception:
                rect = self.pixmap_item.boundingRect()
            top = float(rect.top())
            bottom = float(rect.bottom())
        except Exception:
            top, bottom = 0.0, 0.0
        try:
            cx = float(x) + (float(w) / 2.0)
            cy = float(y) + (float(h) / 2.0)
        except Exception:
            cx, cy = 0.0, 0.0
        try:
            mid_x = float(self._get_vertical_split_x() or 0.0)
        except Exception:
            mid_x = 0.0
        if mid_x <= 0:
            try:
                mid_x = float(rect.center().x())
            except Exception:
                mid_x = 0.0
        sep_y = None
        try:
            j = getattr(self, "jaw_separator_line", None)
            if j is not None and j.scene() == self.scene and hasattr(j, "get_y_at_x"):
                sep_y = float(j.get_y_at_x(float(cx)))
        except Exception:
            sep_y = None
        if sep_y is None:
            try:
                sep_y = float(rect.center().y())
            except Exception:
                sep_y = (top + bottom) / 2.0 if bottom else 0.0

        is_upper = float(cy) < float(sep_y)
        is_left = float(cx) < float(mid_x)
        if is_upper and is_left:
            phase = "Q1"
            color = "#3498db"
            title = "Q1 (Άνω Δεξιά)"
        elif is_upper and (not is_left):
            phase = "Q2"
            color = "#9b59b6"
            title = "Q2 (Άνω Αριστερά)"
        elif (not is_upper) and (not is_left):
            phase = "Q3"
            color = "#e67e22"
            title = "Q3 (Κάτω Αριστερά)"
        else:
            phase = "Q4"
            color = "#2ecc71"
            title = "Q4 (Κάτω Δεξιά)"

        try:
            if is_upper:
                y1 = float(top)
                y2 = float(sep_y)
            else:
                y1 = float(sep_y)
                y2 = float(bottom)
        except Exception:
            y1, y2 = top, bottom
        try:
            out = {"phase": str(phase), "y1": float(y1), "y2": float(y2), "color": str(color), "title": str(title)}
        except Exception:
            out = {"phase": "Q1", "y1": top, "y2": bottom, "color": "#3498db", "title": "Q1"}
        return out

    def _start_ai_q1_scan_overlay(self):
        try:
            if getattr(self, "_ai_q1_scan_active", False):
                return
            if not getattr(self, "pixmap_item", None) or not getattr(self, "scene", None):
                return
            try:
                rect = self.pixmap_item.mapToScene(self.pixmap_item.boundingRect()).boundingRect()
            except Exception:
                rect = self.pixmap_item.boundingRect()
            mid_x = float(self._get_vertical_split_x() or 0.0)
            if mid_x <= 0:
                mid_x = float(rect.center().x())
            try:
                lims = self._get_condyle_x_limits(tolerance_px=0.0)
                if lims is not None:
                    mid_x = min(max(float(mid_x), float(lims[0])), float(lims[1]))
            except Exception:
                pass
            top = float(rect.top())
            bottom = float(rect.bottom())
            self._ai_q1_scan_current_x = float(mid_x)
            self._ai_q1_scan_target_x = None
            self._ai_q1_scan_current_y1 = float(top)
            self._ai_q1_scan_current_y2 = float(bottom)
            self._ai_q1_scan_target_y1 = None
            self._ai_q1_scan_target_y2 = None
            self._ai_q1_scan_pause_until = 0.0
            self._ai_q1_scan_queue = []
            self._ai_q1_scan_last_time = time.perf_counter()
            self._ai_q1_scan_active = True
            self._ai_q1_scan_active = True
            self._ai_q1_scan_last_enqueued_x = float(mid_x)
            self._ai_q1_scan_phase = "Q1"

            self._ai_q1_scan_line = QGraphicsLineItem(float(mid_x), float(top), float(mid_x), float(bottom))
            pen = QPen(QColor("#3498db"))
            pen.setWidth(4)
            self._ai_q1_scan_line.setPen(pen)
            self._ai_q1_scan_line.setZValue(10050)
            try:
                self._ai_q1_scan_line.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
                self._ai_q1_scan_line.setAcceptHoverEvents(False)
            except Exception:
                pass
            self.scene.addItem(self._ai_q1_scan_line)
            try:
                self._ai_q1_scan_phase_label = QGraphicsTextItem("Q1")
                self._ai_q1_scan_phase_label.setDefaultTextColor(QColor("#3498db"))
                f = QFont()
                f.setBold(True)
                f.setPointSize(11)
                self._ai_q1_scan_phase_label.setFont(f)
                self._ai_q1_scan_phase_label.setZValue(10051)
                self._ai_q1_scan_phase_label.setPos(float(mid_x) - 70, float(top) + 10)
                try:
                    self._ai_q1_scan_phase_label.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
                except Exception:
                    pass
                self.scene.addItem(self._ai_q1_scan_phase_label)
            except Exception:
                self._ai_q1_scan_phase_label = None

            self._ai_q1_scan_timer = QTimer(self)
            self._ai_q1_scan_timer.setInterval(40)
            self._ai_q1_scan_timer.timeout.connect(self._tick_ai_q1_scan_overlay)
            self._ai_q1_scan_timer.start()
        except Exception:
            pass

    def _stop_ai_q1_scan_overlay(self):
        try:
            t = getattr(self, "_ai_q1_scan_timer", None)
            if t is not None:
                try:
                    t.stop()
                except Exception:
                    pass
            self._ai_q1_scan_timer = None
        except Exception:
            pass
        try:
            it = getattr(self, "_ai_q1_scan_line", None)
            if it is not None and hasattr(it, "scene") and it.scene() == self.scene:
                self.scene.removeItem(it)
        except Exception:
            pass
        self._ai_q1_scan_line = None
        try:
            it2 = getattr(self, "_ai_q1_scan_phase_label", None)
            if it2 is not None and hasattr(it2, "scene") and it2.scene() == self.scene:
                self.scene.removeItem(it2)
        except Exception:
            pass
        self._ai_q1_scan_phase_label = None
        try:
            self._ai_q1_scan_active = False
        except Exception:
            pass
        try:
            self._ai_q1_scan_queue = []
        except Exception:
            pass

    def _enqueue_ai_q1_scan_target(self, x: float, pause_ms: int = 0, announce=None, y1: float | None = None, y2: float | None = None, color: str | None = None, title: str | None = None, phase: str | None = None):
        try:
            self._start_ai_q1_scan_overlay()
            if not getattr(self, "_ai_q1_scan_active", False):
                return
            try:
                lims = self._get_condyle_x_limits(tolerance_px=0.0)
                if lims is not None:
                    x = float(min(max(float(x), float(lims[0])), float(lims[1])))
            except Exception:
                pass
            q = getattr(self, "_ai_q1_scan_queue", None)
            if not isinstance(q, list):
                q = []
                self._ai_q1_scan_queue = q
            try:
                last = getattr(self, "_ai_q1_scan_last_enqueued_x", None)
                meta_present = (y1 is not None) or (y2 is not None) or bool(color) or bool(title) or bool(phase)
                if last is not None and abs(float(x) - float(last)) < 4.0 and (not announce) and (not meta_present):
                    return
            except Exception:
                pass
            self._ai_q1_scan_last_enqueued_x = float(x)
            q.append((float(x), float(y1) if y1 is not None else None, float(y2) if y2 is not None else None, str(color) if color else None, str(title) if title else None, str(phase) if phase else None, int(pause_ms or 0), str(announce) if announce else None))
        except Exception:
            pass

    def _tick_ai_q1_scan_overlay(self):
        try:
            if not getattr(self, "_ai_q1_scan_active", False):
                return
            line = getattr(self, "_ai_q1_scan_line", None)
            if line is None or line.scene() != self.scene:
                return
            now_m = time.monotonic()
            if float(getattr(self, "_ai_q1_scan_pause_until", 0.0) or 0.0) > float(now_m):
                return

            target = getattr(self, "_ai_q1_scan_target_x", None)
            if target is None:
                q = getattr(self, "_ai_q1_scan_queue", None)
                if isinstance(q, list) and q:
                    target, y1, y2, color, title, phase, pause_ms, announce = q.pop(0)
                    self._ai_q1_scan_target_x = float(target)
                    self._ai_q1_scan_target_y1 = float(y1) if y1 is not None else None
                    self._ai_q1_scan_target_y2 = float(y2) if y2 is not None else None
                    self._ai_q1_scan_target_pause_ms = int(pause_ms or 0)
                    self._ai_q1_scan_target_announce = str(announce) if announce else None
                    try:
                        if phase:
                            self._ai_q1_scan_phase = str(phase)
                        if title and getattr(self, "_ai_q1_scan_phase_label", None) is not None:
                            self._ai_q1_scan_phase_label.setPlainText(str(title))
                        if color and getattr(self, "_ai_q1_scan_line", None) is not None:
                            pen0 = self._ai_q1_scan_line.pen()
                            pen0.setColor(QColor(str(color)))
                            self._ai_q1_scan_line.setPen(pen0)
                        if color and getattr(self, "_ai_q1_scan_phase_label", None) is not None:
                            self._ai_q1_scan_phase_label.setDefaultTextColor(QColor(str(color)))
                    except Exception:
                        pass
                else:
                    return

            now = time.perf_counter()
            dt = float(now - float(getattr(self, "_ai_q1_scan_last_time", now) or now))
            if dt < 0:
                dt = 0.0
            if dt > 0.05:
                dt = 0.05
            self._ai_q1_scan_last_time = now

            cur = float(getattr(self, "_ai_q1_scan_current_x", line.line().x1()) or line.line().x1())
            tgt = float(getattr(self, "_ai_q1_scan_target_x", cur) or cur)

            speed = float(getattr(self, "_ai_q1_scan_speed_px_per_sec", 10.0) or 10.0)
            step = speed * dt
            if abs(tgt - cur) <= step:
                cur = tgt
            else:
                cur = cur + (-step if tgt < cur else step)

            self._ai_q1_scan_current_x = float(cur)
            try:
                y1c = getattr(self, "_ai_q1_scan_current_y1", None)
                y2c = getattr(self, "_ai_q1_scan_current_y2", None)
            except Exception:
                y1c, y2c = None, None
            try:
                y1t = getattr(self, "_ai_q1_scan_target_y1", None)
                y2t = getattr(self, "_ai_q1_scan_target_y2", None)
            except Exception:
                y1t, y2t = None, None
            if y1t is not None:
                y1c = float(y1t)
                self._ai_q1_scan_current_y1 = float(y1t)
            if y2t is not None:
                y2c = float(y2t)
                self._ai_q1_scan_current_y2 = float(y2t)
            l = line.line()
            if y1c is None:
                y1c = float(l.y1())
            if y2c is None:
                y2c = float(l.y2())
            line.setLine(float(cur), float(y1c), float(cur), float(y2c))
            try:
                self._update_scanning_beam_pos(float(cur), float(y1c), 0.0, float(y2c - y1c), intensity=35, found_label=None)
            except Exception:
                pass
            try:
                if bool(getattr(self, "_trace_recording_active", False)):
                    ph0 = str(getattr(self, "_ai_q1_scan_phase", "") or "").strip()
                    last_evt = getattr(self, "_trace_last_scan_span", None)
                    key = (ph0, int(round(float(cur))), int(round(float(y1c))), int(round(float(y2c))))
                    if last_evt != key:
                        self._trace_last_scan_span = key
                        self._trace_log("scan_overlay_span", {"phase": ph0, "x": float(cur), "y1": float(y1c), "y2": float(y2c)})
            except Exception:
                pass

            if float(cur) == float(tgt):
                pause_ms = int(getattr(self, "_ai_q1_scan_target_pause_ms", 0) or 0)
                announce = getattr(self, "_ai_q1_scan_target_announce", None)
                self._ai_q1_scan_target_x = None
                self._ai_q1_scan_target_y1 = None
                self._ai_q1_scan_target_y2 = None
                self._ai_q1_scan_target_pause_ms = 0
                self._ai_q1_scan_target_announce = None
                if announce:
                    try:
                        self._announce_action_done(str(announce))
                    except Exception:
                        pass
                if pause_ms > 0:
                    self._ai_q1_scan_pause_until = float(now_m) + (float(pause_ms) / 1000.0)
        except Exception:
            pass

    def _collect_geometry_data(self) -> dict:
        """
        Collects geometry/ROI data from the current scene (Live Items)
        or saved feedback (Baseline) for analysis.
        """
        geometry = {}
        try:
            # 1. Load from saved feedback first (baseline)
            try:
                if hasattr(self, "zone_manager"):
                    fb = self.zone_manager.get_feedback(self.current_image_path)
                    if fb:
                        if "y_split" in fb: geometry["jaw_split_y"] = fb["y_split"]
                        if "x_split" in fb: geometry["midline_x"] = fb["x_split"]
                        if "upper_roi" in fb: geometry["upper_roi"] = fb["upper_roi"]
                        if "lower_roi" in fb: geometry["lower_roi"] = fb["lower_roi"]
            except Exception:
                pass

            # 2. Override with live scene items if they exist (User is currently editing)
            # Midline
            if self._is_scene_item_alive(getattr(self, "vertical_separator_line", None)):
                 geometry["midline_x"] = self.vertical_separator_line.pos().x()
            elif self._is_scene_item_alive(getattr(self, "midline_item", None)): # Legacy
                if hasattr(self.midline_item, "line"):
                    line = self.midline_item.line()
                    geometry["midline_x"] = line.x1()
                else:
                    # Assume it's a RectItem or similar with pos()
                    geometry["midline_x"] = self.midline_item.pos().x()
            
            # Jaw Separator (Zoning)
            # Prefer new zoning lines (wizard) over old ones
            if self._is_scene_item_alive(getattr(self, "zone_line_2", None)) and self.zone_line_2.isVisible():
                geometry["jaw_split_y"] = self.zone_line_2.pos().y()
            elif self._is_scene_item_alive(getattr(self, "jaw_separator_line", None)):
                geometry["jaw_split_y"] = self.jaw_separator_line.pos().y()

            # Upper/Lower ROIs (Live items)
            if hasattr(self, "upper_roi_item") and self._is_scene_item_alive(self.upper_roi_item) and self.upper_roi_item.isVisible():
                r = self.upper_roi_item.rect().normalized()
                # If item has position offset (e.g. moved), add it
                pos = self.upper_roi_item.pos()
                x = r.x() + pos.x()
                y = r.y() + pos.y()
                geometry["upper_roi"] = [int(x), int(y), int(r.width()), int(r.height())]
            
            if hasattr(self, "lower_roi_item") and self._is_scene_item_alive(self.lower_roi_item) and self.lower_roi_item.isVisible():
                r = self.lower_roi_item.rect().normalized()
                pos = self.lower_roi_item.pos()
                x = r.x() + pos.x()
                y = r.y() + pos.y()
                geometry["lower_roi"] = [int(x), int(y), int(r.width()), int(r.height())]
            
            # Crop/Calibration
            if hasattr(self, "crop_rect_item") and self._is_scene_item_alive(self.crop_rect_item):
                r = self.crop_rect_item.rect()
                geometry["crop_rect"] = [r.x(), r.y(), r.width(), r.height()]

            # Manual Scan ROI
            if hasattr(self, "_scan_roi_item") and self._is_scene_item_alive(self._scan_roi_item) and self._scan_roi_item.isVisible():
                r = self._scan_roi_item.rect().normalized()
                pos = self._scan_roi_item.pos()
                rx = r.x() + pos.x()
                ry = r.y() + pos.y()
                rw = r.width()
                rh = r.height()
                geometry["scan_roi"] = [int(rx), int(ry), int(rw), int(rh)]
                
        except Exception as e:
            print(f"Error collecting geometry: {e}")
            pass
            
        return geometry

    def analyze_image_with_ai(self, mode="full"):
        if not self.current_image_path:
            return
        try:
            if bool(getattr(self, "_manual_scan_active", False)) or bool(getattr(self, "_manual_scan_block_ai", False)):
                try:
                    self._append_comm("Σύστημα", "Ανάλυση: παραλείφθηκε (χειροκίνητη σάρωση ενεργή).")
                except Exception:
                    pass
                try:
                    self._trace_log("analysis_skipped", {"reason": "manual_scan_active"})
                except Exception:
                    pass
                return
        except Exception:
            pass
        try:
            self._analysis_abort_reason = None
        except Exception:
            pass
        try:
            self._stop_ai_q1_scan_overlay()
        except Exception:
            pass
            
        # State Management
        if mode == "full":
            # Start fresh with Teeth
            self.analysis_step = "teeth"
            mode_arg = "teeth_only"
            if hasattr(self, "continue_analysis_btn"):
                self.continue_analysis_btn.hide()
        elif mode == "conditions":
            self.analysis_step = "conditions"
            mode_arg = "conditions_only"
        else:
            # Fallback or specific manual call
            self.analysis_step = "full"
            mode_arg = "full"
        try:
            self._trace_log(
                "analysis_started",
                {
                    "mode": str(mode_arg),
                    "analysis_step": str(getattr(self, "analysis_step", "")),
                    "model_path": str(getattr(self, "model_path", "") or ""),
                    "toothdet_model_path": str(getattr(self, "toothdet_model_path", "") or ""),
                    "toothcls_model_path": str(getattr(self, "toothcls_model_path", "") or ""),
                },
            )
        except Exception:
            pass
            
        try:
            step_msg = "Ανάλυση Δοντιών" if self.analysis_step == "teeth" else "Ανάλυση Καταστάσεων"
            self._pipeline_set(
                "analysis",
                f"{step_msg} σε εξέλιξη",
                self._pipeline_hint_for_step("analysis"),
                progress=20,
                step_status_updates={"image": "OK", "analysis": "RUN", "review": "WAIT", "save": "WAIT", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
            )
        except Exception:
            pass
        try:
            self._analysis_started_at = time.perf_counter()
        except Exception:
            self._analysis_started_at = None
        try:
            self._prepare_comparative_baseline_before_analysis()
        except Exception:
            pass
        try:
            from PyQt6.QtCore import QProcess, QTimer
        except Exception:
            QProcess = None
            QTimer = None
        try:
            if getattr(self, "progress_bar", None):
                self.progress_bar.deleteLater()
        except Exception:
            pass
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        try:
            self.progress_bar.valueChanged.connect(self._on_analysis_progress_changed)
            self.progress_bar.setFormat("%p%")
        except Exception:
            pass
        self.left_layout.insertWidget(1, self.progress_bar)
        self.analyze_button.setEnabled(False)
        
        # Start Sci-Fi Animation
        self._start_scanning_animation()

        if QProcess is None or QTimer is None:
            self.handle_analysis_error("Δεν είναι διαθέσιμο το QProcess (QtCore).")
            return

        try:
            prev = getattr(self, "_analysis_proc", None)
            if prev is not None:
                try:
                    if prev.state() != QProcess.ProcessState.NotRunning:
                        prev.kill()
                except Exception:
                    pass
        except Exception:
            pass

        import tempfile, sys, json
        from pathlib import Path

        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".json") as f:
                result_path = f.name
        except Exception as e:
            self.handle_analysis_error(f"Αποτυχία temp αρχείου: {e}")
            return

        py = str(sys.executable or "").strip()
        try:
            p = Path(py)
            if p.name.lower() == "pythonw.exe":
                py_console = str(p.with_name("python.exe"))
                if os.path.exists(py_console):
                    py = py_console
        except Exception:
            pass

        script_path = ""
        try:
            script_path = str((Path(__file__).resolve().parents[1] / "ai" / "analysis_process.py").resolve())
        except Exception:
            script_path = os.path.join(os.path.dirname(__file__), "..", "ai", "analysis_process.py")
            script_path = os.path.abspath(script_path)

        self.progress_bar.setValue(15)
        try:
            mp0 = str(getattr(self, "model_path", "") or "")
            if mp0:
                self._append_comm("Σύστημα", f"Μοντέλο ανάλυσης: {os.path.basename(mp0)}")
        except Exception:
            pass

        proc = QProcess(self)
        self._analysis_proc = proc
        try:
            proc.setProcessChannelMode(QProcess.ProcessChannelMode.SeparateChannels)
        except Exception:
            pass

        try:
            mp = str(getattr(self, "model_path", "") or "")
            mp_low = mp.replace("/", "\\").lower()
            is_toothdet = ("\\models\\secure\\toothdet\\" in mp_low) or (os.path.basename(mp_low).startswith("toothdet_"))
        except Exception:
            is_toothdet = False
        if is_toothdet:
            try:
                alt = str(getattr(self, "detect_model_path", "") or "").strip()
                if not alt:
                    prefs = AppPrefs(Path(getattr(self, "project_root", str(Path(__file__).resolve().parents[2]))))
                    alt = str(prefs.get("selected_detect_model_path") or prefs.get("selected_model_path") or "").strip()
                try:
                    alt_low = alt.replace("/", "\\").lower()
                    alt_is_toothdet = ("\\models\\secure\\toothdet\\" in alt_low) or (os.path.basename(alt_low).startswith("toothdet_"))
                except Exception:
                    alt_is_toothdet = False
                if (not alt) or alt_is_toothdet:
                    try:
                        default_pt = str((Path(getattr(self, "project_root", str(Path(__file__).resolve().parents[2]))) / "models" / "stoma_default.pt").resolve())
                        if os.path.exists(default_pt):
                            alt = default_pt
                    except Exception:
                        pass
                if alt and os.path.exists(alt):
                    self.model_path = alt
                    try:
                        self._append_comm("Σύστημα", f"Χρησιμοποιείται μοντέλο ανάλυσης: {os.path.basename(alt)}")
                    except Exception:
                        pass
            except Exception:
                pass

        # Prepare Geometry JSON
        geometry_file = None
        try:
            geometry = self._collect_geometry_data()
            if geometry:
                with tempfile.NamedTemporaryFile(delete=False, suffix=".json", mode='w', encoding='utf-8') as gf:
                    json.dump(geometry, gf)
                    geometry_file = gf.name
        except Exception:
            pass

        args = [
            script_path,
            "--image", str(self.current_image_path),
            "--model", str(self.model_path),
            "--output", str(result_path),
            "--mode", str(mode_arg), # Pass the mode argument
        ]
        
        if geometry_file:
            args.extend(["--geometry", geometry_file])
        try:
            td = str(getattr(self, "toothdet_model_path", "") or "").strip()
            if td and os.path.exists(td):
                if self._toothdet_model_usable(td):
                    args.extend(["--toothdet", td])
                    try:
                        self._append_comm("Σύστημα", f"ToothDet: {os.path.basename(td)}")
                    except Exception:
                        pass
                else:
                    try:
                        mp = self._model_map50(td)
                        if mp is None:
                            self._append_comm("Σύστημα", f"ToothDet: παραλείφθηκε ({os.path.basename(td)})")
                        else:
                            self._append_comm("Σύστημα", f"ToothDet: παραλείφθηκε (mAP50 {float(mp):.3f})")
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            tc = str(getattr(self, "toothcls_model_path", "") or "").strip()
            if tc and os.path.exists(tc):
                args.extend(["--toothcls", tc])
        except Exception:
            pass
        proc.setProgram(py)
        proc.setArguments(args)

        try:
            self._analysis_stdout = ""
        except Exception:
            pass

        def _read_out():
            try:
                b = proc.readAllStandardOutput()
                if b:
                    s = bytes(b).decode("utf-8", errors="replace")
                    self._analysis_stdout = (str(getattr(self, "_analysis_stdout", "") or "") + s)[-12000:]
                    try:
                        p = getattr(self, "_trace_stdout_path", None)
                        if p and bool(getattr(self, "_trace_recording_active", False)):
                            with open(p, "a", encoding="utf-8", errors="replace") as f:
                                f.write(s)
                    except Exception:
                        pass
                    
                    # --- LIVE SCAN FEEDBACK ---
                    # Parse SCAN_FOCUS events from stdout
                    if "SCAN_PHASE:" in s:
                        try:
                            phases = re.findall(r"SCAN_PHASE:([Qq][1-4])", s)
                        except Exception:
                            phases = []
                        if phases:
                            for ph0 in phases:
                                ph = str(ph0 or "").strip().upper()
                                if ph not in ("Q1", "Q2", "Q3", "Q4"):
                                    continue
                                try:
                                    self._ai_q1_scan_phase = str(ph)
                                except Exception:
                                    pass
                                if ph == "Q1":
                                    color = "#3498db"
                                    title = "Q1 (Άνω Δεξιά)"
                                elif ph == "Q2":
                                    color = "#9b59b6"
                                    title = "Q2 (Άνω Αριστερά)"
                                elif ph == "Q3":
                                    color = "#e67e22"
                                    title = "Q3 (Κάτω Αριστερά)"
                                else:
                                    color = "#2ecc71"
                                    title = "Q4 (Κάτω Δεξιά)"
                                try:
                                    self._trace_log("scan_phase", {"phase": str(ph), "title": str(title), "color": str(color)})
                                except Exception:
                                    pass
                                try:
                                    rect0 = None
                                    try:
                                        if getattr(self, "pixmap_item", None) is not None:
                                            rect0 = self.pixmap_item.mapToScene(self.pixmap_item.boundingRect()).boundingRect()
                                    except Exception:
                                        rect0 = None
                                    if rect0 is None:
                                        rect0 = self.pixmap_item.boundingRect() if getattr(self, "pixmap_item", None) is not None else None
                                    if rect0 is not None:
                                        top0 = float(rect0.top())
                                        bottom0 = float(rect0.bottom())
                                        mx = float(getattr(self, "_ai_q1_scan_current_x", 0.0) or 0.0)
                                        if mx <= 0:
                                            try:
                                                mx = float(self._get_vertical_split_x() or 0.0)
                                            except Exception:
                                                mx = 0.0
                                        if mx <= 0:
                                            mx = float(rect0.center().x())
                                        try:
                                            lims0 = self._get_condyle_x_limits(tolerance_px=20.0)
                                        except Exception:
                                            lims0 = None
                                        if lims0 is not None:
                                            mnx, mxx = float(lims0[0]), float(lims0[1])
                                        else:
                                            mnx, mxx = float(rect0.left()), float(rect0.right())
                                        sep_y0 = None
                                        try:
                                            j = getattr(self, "jaw_separator_line", None)
                                            if j is not None and j.scene() == self.scene and hasattr(j, "get_y_at_x"):
                                                sep_y0 = float(j.get_y_at_x(float(mx)))
                                        except Exception:
                                            sep_y0 = None
                                        if sep_y0 is None:
                                            sep_y0 = float(rect0.center().y())
                                        if ph in ("Q1", "Q2"):
                                            y1p, y2p = top0, sep_y0
                                        else:
                                            y1p, y2p = sep_y0, bottom0
                                        try:
                                            q0 = getattr(self, "_ai_q1_scan_queue", None)
                                            qlen0 = int(len(q0)) if isinstance(q0, list) else 0
                                        except Exception:
                                            qlen0 = 0
                                        self._enqueue_ai_q1_scan_target(float(mx), pause_ms=0, announce=None, y1=float(y1p), y2=float(y2p), color=str(color), title=str(title), phase=str(ph))
                                        try:
                                            if qlen0 <= 2:
                                                left = float(mnx)
                                                right = float(mxx)
                                                mid_x0 = float(self._get_vertical_split_x() or 0.0)
                                                if mid_x0 <= 0:
                                                    mid_x0 = float(rect0.center().x())
                                                pad = 14.0
                                                if ph in ("Q1", "Q4"):
                                                    x_from = left + pad
                                                    x_to = mid_x0 - pad
                                                else:
                                                    x_from = mid_x0 + pad
                                                    x_to = right - pad
                                                if x_to > x_from + 10:
                                                    flip = bool(getattr(self, "_ai_q1_scan_sweep_flip", False))
                                                    self._ai_q1_scan_sweep_flip = (not flip)
                                                    n = 9
                                                    for i in range(n):
                                                        t = float(i) / float(max(1, n - 1))
                                                        xi = (x_to * t + x_from * (1.0 - t)) if flip else (x_from * t + x_to * (1.0 - t))
                                                        self._enqueue_ai_q1_scan_target(float(xi), pause_ms=0, announce=None, y1=float(y1p), y2=float(y2p), color=str(color), title=str(title), phase=str(ph))
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                                try:
                                    lb = getattr(self, "_ai_q1_scan_phase_label", None)
                                    if lb is not None and lb.scene() == self.scene:
                                        lb.setPlainText(str(title))
                                        lb.setDefaultTextColor(QColor(str(color)))
                                except Exception:
                                    pass
                                try:
                                    ln = getattr(self, "_ai_q1_scan_line", None)
                                    if ln is not None and ln.scene() == self.scene:
                                        pen0 = ln.pen()
                                        pen0.setColor(QColor(str(color)))
                                        ln.setPen(pen0)
                                except Exception:
                                    pass
                    if "SCAN_FOCUS:" in s:
                        try:
                            # Use regex to find all occurrences in this chunk
                            # Format: X,Y,W,H,INTENSITY (Optional), TYPE (Optional)
                            matches = re.findall(r"SCAN_FOCUS:(\d+),(\d+),(\d+),(\d+)(?:,(\d+))?(?:,([^,\r\n]+))?", s)
                            if matches:
                                # Iterate all matches to show movement
                                for m in matches:
                                    lx, ly, lw, lh, li, lt = m
                                    lt = str(lt or "")
                                    if lt == "GLOBAL":
                                        continue
                                    if lt == "ROI":
                                        try:
                                            rect = QRectF(float(int(lx)), float(int(ly)), float(int(lw)), float(int(lh)))
                                            if not hasattr(self, "_scan_roi_item") or self._scan_roi_item is None or not self._is_scene_item_alive(self._scan_roi_item):
                                                self._scan_roi_item = RoiRectItem(rect, color=Qt.GlobalColor.green, label="ROI Σάρωσης")
                                                self._scan_roi_item.setZValue(40)
                                                self.scene.addItem(self._scan_roi_item)
                                            else:
                                                self._scan_roi_item.setRect(rect)
                                                self._scan_roi_item.setVisible(True)
                                        except Exception:
                                            pass
                                        continue

                                    found_label = None
                                    if lt.startswith("FOUND:"):
                                        found_label = lt.split(":", 1)[1]

                                    intensity = int(li) if li else 50

                                    cx = float(int(lx)) + (float(int(lw)) / 2.0)
                                    pause_ms = 260 if found_label else 0
                                    announce = None
                                    try:
                                        if found_label and str(found_label).strip().isdigit():
                                            if bool(getattr(self, "comm_scan_tts_enabled", False)):
                                                try:
                                                    now_m = float(time.monotonic())
                                                except Exception:
                                                    now_m = 0.0
                                                try:
                                                    sup = float(getattr(self, "_suppress_scan_tts_until", 0.0) or 0.0)
                                                except Exception:
                                                    sup = 0.0
                                                if now_m >= sup:
                                                    announce = f"Δόντι {str(found_label).strip()}"
                                    except Exception:
                                        announce = None
                                    meta = {}
                                    try:
                                        meta = self._ai_scan_quadrant_meta_for_rect(int(lx), int(ly), int(lw), int(lh))
                                    except Exception:
                                        meta = {}
                                    try:
                                        y1 = meta.get("y1")
                                        y2 = meta.get("y2")
                                        color = meta.get("color")
                                        title = meta.get("title")
                                        phase = meta.get("phase")
                                    except Exception:
                                        y1, y2, color, title, phase = None, None, None, None, None
                                    try:
                                        self._trace_log(
                                            "scan_focus",
                                            {
                                                "x": int(lx),
                                                "y": int(ly),
                                                "w": int(lw),
                                                "h": int(lh),
                                                "intensity": int(intensity),
                                                "tag": str(lt or ""),
                                                "found_label": str(found_label or "") if found_label else None,
                                                "phase": str(phase or ""),
                                            },
                                        )
                                    except Exception:
                                        pass
                                    self._enqueue_ai_q1_scan_target(float(cx), pause_ms=pause_ms, announce=announce, y1=y1, y2=y2, color=color, title=title, phase=phase)

                                    self._update_scanning_beam_pos(int(lx), int(ly), int(lw), int(lh), intensity, found_label=found_label)

                                    QApplication.processEvents()
                        except Exception as e:
                            print(f"Scan Focus Parse Error: {e}")
                            
            except Exception:
                pass
            try:
                b2 = proc.readAllStandardError()
                if b2:
                    s2 = bytes(b2).decode("utf-8", errors="replace")
                    self._analysis_stdout = (str(getattr(self, "_analysis_stdout", "") or "") + s2)[-12000:]
            except Exception:
                pass

        proc.readyReadStandardOutput.connect(_read_out)
        try:
            proc.readyReadStandardError.connect(_read_out)
        except Exception:
            pass

        timeout_ms = 240000
        watchdog = QTimer(self)
        watchdog.setSingleShot(True)
        def _on_timeout():
            try:
                if proc.state() != QProcess.ProcessState.NotRunning:
                    proc.kill()
            except Exception:
                pass
            self.handle_analysis_error("Η ανάλυση καθυστέρησε υπερβολικά και τερματίστηκε.")
        watchdog.timeout.connect(_on_timeout)
        watchdog.start(int(timeout_ms))
        self._analysis_watchdog = watchdog

        prog_timer = QTimer(self)
        prog_timer.setInterval(400)
        def _tick():
            try:
                v = int(self.progress_bar.value())
                if v < 90:
                    self.progress_bar.setValue(min(90, v + 2))
            except Exception:
                pass
        prog_timer.timeout.connect(_tick)
        prog_timer.start()
        self._analysis_prog_timer = prog_timer

        def _cleanup_timers():
            try:
                w = getattr(self, "_analysis_watchdog", None)
                if w is not None:
                    w.stop()
                    w.deleteLater()
                self._analysis_watchdog = None
            except Exception:
                pass
            try:
                tmr = getattr(self, "_analysis_prog_timer", None)
                if tmr is not None:
                    tmr.stop()
                    tmr.deleteLater()
                self._analysis_prog_timer = None
            except Exception:
                pass

        def _finish(exit_code, _exit_status):
            _read_out()
            _cleanup_timers()
            try:
                self._stop_ai_q1_scan_overlay()
            except Exception:
                pass
            try:
                abort_reason = None
                try:
                    abort_reason = proc.property("stoma_abort_reason")
                except Exception:
                    abort_reason = None
                if not abort_reason:
                    abort_reason = getattr(self, "_analysis_abort_reason", None)
                if abort_reason or bool(getattr(self, "_manual_scan_active", False)) or (getattr(self, "_analysis_proc", None) is not proc):
                    try:
                        self._trace_log("analysis_aborted", {"reason": str(abort_reason or "manual_scan_or_replaced"), "exit_code": int(exit_code)})
                    except Exception:
                        pass
                    try:
                        if os.path.exists(result_path):
                            os.remove(result_path)
                    except Exception:
                        pass
                    try:
                        self._stop_scanning_animation()
                    except Exception:
                        pass
                    try:
                        pb = getattr(self, "progress_bar", None)
                        if pb is not None:
                            pb.deleteLater()
                    except Exception:
                        pass
                    try:
                        self.progress_bar = None
                    except Exception:
                        pass
                    try:
                        self.analyze_button.setEnabled(True)
                    except Exception:
                        pass
                    try:
                        if getattr(self, "abort_button", None):
                            self.abort_button.setEnabled(False)
                    except Exception:
                        pass
                    try:
                        self._analysis_abort_reason = None
                    except Exception:
                        pass
                    try:
                        if getattr(self, "_analysis_proc", None) is proc:
                            self._analysis_proc = None
                    except Exception:
                        pass
                    try:
                        proc.deleteLater()
                    except Exception:
                        pass
                    return
            except Exception:
                pass
            try:
                if getattr(self, "_analysis_proc", None) is proc:
                    self._analysis_proc = None
                proc.deleteLater()
            except Exception:
                pass
            try:
                self.progress_bar.setValue(100)
            except Exception:
                pass
            try:
                try:
                    out0 = str(getattr(self, "_analysis_stdout", "") or "")
                    self._trace_log("analysis_process_finished", {"exit_code": int(exit_code), "stdout_tail": out0[-1600:] if out0 else ""})
                except Exception:
                    pass
                if int(exit_code) != 0:
                    out = str(getattr(self, "_analysis_stdout", "") or "").strip()
                    try:
                        hx = hex(int(exit_code) & 0xFFFFFFFF)
                    except Exception:
                        hx = "?"

                    # Special handling for 62097 (0xF291) - likely OOM or Interruption
                    if int(exit_code) == 62097 or str(hx).lower().endswith("f291"):
                        self.handle_analysis_error("Η ανάλυση διακόπηκε απροσδόκητα (Code 0xF291). Πιθανό πρόβλημα μνήμης ή διακοπή διεργασίας. Παρακαλώ δοκιμάστε ξανά.")
                        return

                    if out:
                        # Filter out SCAN_FOCUS lines to show relevant errors
                        try:
                            lines = out.splitlines()
                            relevant_lines = [l for l in lines if "SCAN_FOCUS" not in l and l.strip()]
                            tail = "\n".join(relevant_lines[-20:])
                            if not tail:
                                tail = out[-800:]
                        except Exception:
                            tail = out[-800:]
                        self.handle_analysis_error(f"Αποτυχία ανάλυσης (exit {exit_code}, hex {hx}): {tail}")
                    else:
                        self.handle_analysis_error(f"Αποτυχία ανάλυσης (exit {exit_code}, hex {hx}).")
                    return
                if not os.path.exists(result_path):
                    out = str(getattr(self, "_analysis_stdout", "") or "").strip()
                    self.handle_analysis_error("Η ανάλυση δεν παρήγαγε αρχείο αποτελεσμάτων." + (f" {out}" if out else ""))
                    return
                with open(result_path, "r", encoding="utf-8") as f:
                    data = json.load(f) or {}
                try:
                    os.remove(result_path)
                except Exception:
                    pass
                if not bool(data.get("success", False)):
                    self.handle_analysis_error(str(data.get("error") or "Άγνωστο σφάλμα ανάλυσης."))
                    return
                processed_results = {
                    "boxes": data.get("boxes", []),
                    "labels": data.get("labels", []),
                    "scores": data.get("scores", []),
                    "device": data.get("device", "unknown"),
                    "debug": data.get("debug"),
                }
                self.handle_analysis_finished(processed_results)
            except Exception as e:
                self.handle_analysis_error(f"Σφάλμα ανάγνωσης αποτελεσμάτων: {e}")

        proc.finished.connect(_finish)

        try:
            proc.start()
            self.progress_bar.setValue(25)
        except Exception as e:
            _cleanup_timers()
            try:
                os.remove(result_path)
            except Exception:
                pass
            self.handle_analysis_error(f"Αποτυχία εκκίνησης ανάλυσης: {e}")

    def handle_analysis_finished(self, results):
        self._stop_scanning_animation()
        
        # Ensure Calibration remains VISIBLE (User Request)
        if getattr(self, 'calib_line_x', None): self.calib_line_x.setVisible(True)
        if getattr(self, 'calib_line_y', None): self.calib_line_y.setVisible(True)
        try: 
            if hasattr(self, "calibration_button"):
                self.calibration_button.setChecked(False)
                self.is_calibrating = False
        except: pass

        try:
            pb = getattr(self, "progress_bar", None)
            if pb is not None:
                pb.deleteLater()
        except Exception:
            pass
        try:
            self.progress_bar = None
        except Exception:
            pass
        try:
            self.analyze_button.setEnabled(True)
        except Exception:
            pass
        try:
            if getattr(self, "abort_button", None):
                self.abort_button.setEnabled(False)
        except Exception:
            pass
        try:
            self._analysis_proc = None
        except Exception:
            pass
        if results:
            if getattr(self, "analysis_step", "full") == "teeth":
                # Step 1: Teeth Found
                self.raw_analysis_results = copy.deepcopy(results)
                self.analysis_results = self.assign_fdi_numbers(copy.deepcopy(results))
                self.display_analysis_results(self.analysis_results)
                try:
                    if not isinstance(getattr(self, "_pipeline_baseline_data", None), dict) or not bool(getattr(self, "_pipeline_baseline_data", {})):
                        self._pipeline_baseline_data = copy.deepcopy(self.analysis_results) if isinstance(self.analysis_results, dict) else {}
                except Exception:
                    pass
                try:
                    if isinstance(self.analysis_results, dict):
                        self._last_ai_results_before_corrections = copy.deepcopy(self.analysis_results)
                except Exception:
                    pass
                
                # Show Continue Button
                if hasattr(self, "continue_analysis_btn") and self.continue_analysis_btn:
                    self.continue_analysis_btn.show()
                    # Center button
                    try:
                        v_rect = self.graphics_view.viewport().rect()
                        self.continue_analysis_btn.move(
                            v_rect.center().x() - self.continue_analysis_btn.width() // 2,
                            v_rect.height() - self.continue_analysis_btn.height() - 20
                        )
                    except:
                        pass
                
                self._pipeline_set("review", "Επιβεβαίωση Δοντιών", "Διόρθωσε τα δόντια και πάτα 'Συνέχεια Ανάλυσης'.")
                self._announce_action_done("Σάρωση Ζωνών: ενεργό")
                try:
                    self.export_button.setEnabled(True)
                except Exception:
                    pass
                try:
                    if hasattr(self, "analysis_text_button") and self.analysis_text_button:
                        self.analysis_text_button.setEnabled(True)
                except Exception:
                    pass
                try:
                    self.save_analysis_button.setEnabled(True)
                except Exception:
                    pass
                try:
                    self.clear_analysis_button.setEnabled(True)
                except Exception:
                    pass
                try:
                    boxes = (self.analysis_results or {}).get("boxes", []) if isinstance(self.analysis_results, dict) else []
                    statuses = (self.analysis_results or {}).get("statuses", []) if isinstance(self.analysis_results, dict) else []
                    teeth_cnt = int(len(boxes) if isinstance(boxes, list) else 0)
                    issues_cnt = 0
                    if isinstance(statuses, list):
                        for st in statuses:
                            if isinstance(st, list) and any(str(x or "").strip() for x in st):
                                issues_cnt += 1
                    msg = f"Η ανάλυση ολοκληρώθηκε. Ανιχνεύθηκαν {teeth_cnt} δόντια."
                    if issues_cnt > 0:
                        msg += f" Σε {issues_cnt} δόντια υπάρχουν σημειώσεις/ευρήματα."
                    try:
                        if bool(getattr(self, "post_analysis_popup_enabled", True)):
                            self._post_analysis_popup_message = msg + "\n\nΕίναι πλήρης/σωστή η ανάλυση;"
                        else:
                            self._post_analysis_popup_message = ""
                            msg += " Είναι πλήρης/σωστή η ανάλυση; (ναι/όχι)"
                    except Exception:
                        msg += " Είναι πλήρης/σωστή η ανάλυση; (ναι/όχι)"
                    self._append_comm("AI", msg)
                    try:
                        self._maybe_speak_comm("AI", msg)
                    except Exception:
                        pass
                    try:
                        self._start_post_analysis_flow()
                    except Exception:
                        pass
                except Exception:
                    pass
                return # STOP HERE

            elif getattr(self, "analysis_step", "full") == "conditions":
                # Step 2: Conditions Found - MERGE with existing
                
                new_boxes = results.get("boxes", [])
                new_labels = results.get("labels", [])
                new_scores = results.get("scores", [])
                
                current = self.analysis_results
                c_boxes = current.get("boxes", [])
                c_labels = current.get("labels", [])
                c_scores = current.get("scores", [])
                c_statuses = current.get("statuses", [])
                
                # Append new with Deduplication (IoU check)
                def _calc_iou_local(b1, b2):
                    xx1 = max(b1[0], b2[0])
                    yy1 = max(b1[1], b2[1])
                    xx2 = min(b1[2], b2[2])
                    yy2 = min(b1[3], b2[3])
                    w = max(0, xx2 - xx1)
                    h = max(0, yy2 - yy1)
                    inter = w * h
                    area1 = (b1[2] - b1[0]) * (b1[3] - b1[1])
                    area2 = (b2[2] - b2[0]) * (b2[3] - b2[1])
                    union = area1 + area2 - inter
                    return inter / union if union > 0 else 0

                extra_statuses = results.get("statuses", [])
                if not extra_statuses:
                    extra_statuses = [[] for _ in range(len(new_boxes))]
                
                # Iterate over new boxes and only add if no significant overlap with EXISTING boxes
                # We iterate a copy or index to avoid issues if we appended to c_boxes immediately (though we append safely)
                for i, nb in enumerate(new_boxes):
                    is_duplicate = False
                    for eb in c_boxes:
                        if _calc_iou_local(nb, eb) > 0.45: # Threshold ~45% to be safe against slight shifts
                            is_duplicate = True
                            break
                    
                    if not is_duplicate:
                        c_boxes.append(nb)
                        c_labels.append(new_labels[i])
                        c_scores.append(new_scores[i])
                        c_statuses.append(extra_statuses[i] if i < len(extra_statuses) else [])
                
                current["boxes"] = c_boxes
                current["labels"] = c_labels
                current["scores"] = c_scores
                current["statuses"] = c_statuses
                
                # Redisplay
                self.display_analysis_results(current)
                self._pipeline_set("review", "Ολοκληρώθηκε: Ζώνες Αποθηκεύτηκαν! Το μοντέλο θα μάθει", "Επιβεβαίωση Καταστάσεων.")
                
            else:
                # Full mode (legacy)
                self.raw_analysis_results = copy.deepcopy(results)
                self.analysis_results = self.assign_fdi_numbers(copy.deepcopy(results))
                self.display_analysis_results(self.analysis_results)

            try:
                if not bool(getattr(self, "manual_pan_enabled", False)):
                    QTimer.singleShot(0, self.view.fit_scene_in_view)
            except Exception:
                try:
                    if self.view and (not bool(getattr(self, "manual_pan_enabled", False))):
                        self.view.fit_scene_in_view()
                except Exception:
                    pass
            try:
                if not isinstance(getattr(self, "_pipeline_baseline_data", None), dict) or not bool(getattr(self, "_pipeline_baseline_data", {})):
                    self._pipeline_baseline_data = copy.deepcopy(self.analysis_results) if isinstance(self.analysis_results, dict) else {}
            except Exception:
                pass
            try:
                if isinstance(self.analysis_results, dict):
                    self._last_ai_results_before_corrections = copy.deepcopy(self.analysis_results)
            except Exception:
                pass
            try:
                self._pipeline_set(
                    "review",
                    "Ανάλυση ολοκληρώθηκε — αναμονή διόρθωσης",
                    self._pipeline_hint_for_step("review"),
                    progress=45,
                    step_status_updates={"analysis": "OK", "review": "TODO", "save": "TODO", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
                )
            except Exception:
                pass
            try:
                self._append_comparative_report_after_analysis()
            except Exception:
                pass
            self.export_button.setEnabled(True)
            try:
                if hasattr(self, "analysis_text_button") and self.analysis_text_button:
                    self.analysis_text_button.setEnabled(True)
            except Exception:
                pass
            self.save_analysis_button.setEnabled(True)
            self.clear_analysis_button.setEnabled(True)
            try:
                try:
                    started_at = getattr(self, "_analysis_started_at", None)
                    elapsed = (time.perf_counter() - float(started_at)) * 1000.0 if started_at else None
                except Exception:
                    elapsed = None
                try:
                    self._announce_action_done("Ανάλυση AI", elapsed_ms=elapsed)
                except Exception:
                    pass
                boxes = (self.analysis_results or {}).get("boxes", []) if isinstance(self.analysis_results, dict) else []
                statuses = (self.analysis_results or {}).get("statuses", []) if isinstance(self.analysis_results, dict) else []
                teeth_cnt = int(len(boxes) if isinstance(boxes, list) else 0)
                issues_cnt = 0
                if isinstance(statuses, list):
                    for st in statuses:
                        if isinstance(st, list) and any(str(x or "").strip() for x in st):
                            issues_cnt += 1
                msg = f"Η ανάλυση ολοκληρώθηκε. Ανιχνεύθηκαν {teeth_cnt} δόντια."
                if issues_cnt > 0:
                    msg += f" Σε {issues_cnt} δόντια υπάρχουν σημειώσεις/ευρήματα."
                try:
                    if bool(getattr(self, "post_analysis_popup_enabled", True)):
                        self._post_analysis_popup_message = msg + "\n\nΕίναι πλήρης/σωστή η ανάλυση;"
                    else:
                        self._post_analysis_popup_message = ""
                        msg += " Είναι πλήρης/σωστή η ανάλυση; (ναι/όχι)"
                except Exception:
                    msg += " Είναι πλήρης/σωστή η ανάλυση; (ναι/όχι)"
                self._append_comm("AI", msg)
                try:
                    self._maybe_speak_comm("AI", msg)
                except Exception:
                    pass
                try:
                    self._start_post_analysis_flow()
                except Exception:
                    pass
            except Exception:
                pass

    def continue_analysis_conditions(self):
        if hasattr(self, "continue_analysis_btn") and self.continue_analysis_btn:
            self.continue_analysis_btn.hide()
        
        # SKIP CONDITIONS ANALYSIS (User Request)
        # Only Teeth and Missing Teeth (calculated in Step 1) are preserved.
        self.results_text_edit.append("\n✅ Η ανάλυση ολοκληρώθηκε (μόνο δόντια).")
        self._announce_action_done("Ανάλυση Ολοκληρώθηκε")
        self._pipeline_set("review", "Ανάλυση Ολοκληρώθηκε", "Ελέγξτε τα αποτελέσματα.")
        
        # self.analyze_image_with_ai(mode="conditions") # DISABLED

    def handle_analysis_error(self, message):
        self._stop_scanning_animation()
        try:
            try:
                from PyQt6.QtCore import QProcess
            except Exception:
                QProcess = None
            p = getattr(self, "_analysis_proc", None)
            if p is not None and QProcess is not None:
                try:
                    if p.state() != QProcess.ProcessState.NotRunning:
                        p.kill()
                        p.waitForFinished(800)
                except Exception:
                    pass
                try:
                    p.deleteLater()
                except Exception:
                    pass
            self._analysis_proc = None
        except Exception:
            pass
        try:
            vw = getattr(self, "verify_worker", None)
            if vw is not None and hasattr(vw, "isRunning") and vw.isRunning():
                try:
                    vw.requestInterruption()
                except Exception:
                    pass
                try:
                    vw.wait(800)
                except Exception:
                    pass
                try:
                    if vw.isRunning():
                        vw.terminate()
                        vw.wait(500)
                except Exception:
                    pass
            self.verify_worker = None
        except Exception:
            pass
        try:
            w = getattr(self, "_analysis_watchdog", None)
            if w is not None:
                w.stop()
                w.deleteLater()
            self._analysis_watchdog = None
        except Exception:
            pass
        try:
            tmr = getattr(self, "_analysis_prog_timer", None)
            if tmr is not None:
                tmr.stop()
                tmr.deleteLater()
            self._analysis_prog_timer = None
        except Exception:
            pass
        try:
            pb = getattr(self, "progress_bar", None)
            if pb is not None:
                pb.deleteLater()
            self.progress_bar = None
        except Exception:
            pass
        try:
            self.analyze_button.setEnabled(True)
        except Exception:
            pass
        try:
            if getattr(self, "abort_button", None):
                self.abort_button.setEnabled(False)
        except Exception:
            pass
        try:
            self._announce_action_failed(f"Ανάλυση AI: {message}")
        except Exception:
            pass
        try:
            self._pipeline_set(
                "analysis",
                f"Σφάλμα ανάλυσης: {message}",
                "Δοκίμασε ξανά Ανάλυση ή έλεγξε το μοντέλο/εξαρτήσεις.",
                progress=0,
                step_status_updates={"analysis": "ERR"},
            )
        except Exception:
            pass
        try:
            self.results_text_edit.append("")
            self.results_text_edit.append("❌ Σφάλμα Ανάλυσης:")
            self.results_text_edit.append(str(message or ""))
        except Exception:
            pass
        try:
            QMessageBox.critical(self, "Σφάλμα Ανάλυσης", message)
        except Exception:
            pass

    def _abort_running_analysis(self, reason: str = "manual"):
        try:
            self._analysis_abort_reason = str(reason or "").strip() or "manual"
        except Exception:
            pass
        try:
            self._stop_scanning_animation()
        except Exception:
            pass
        try:
            try:
                from PyQt6.QtCore import QProcess
            except Exception:
                QProcess = None
            p = getattr(self, "_analysis_proc", None)
            if p is not None and QProcess is not None:
                try:
                    p.setProperty("stoma_abort_reason", str(reason or "manual"))
                except Exception:
                    pass
                try:
                    if p.state() != QProcess.ProcessState.NotRunning:
                        try:
                            p.terminate()
                        except Exception:
                            pass
                        try:
                            p.waitForFinished(900)
                        except Exception:
                            pass
                        try:
                            if p.state() != QProcess.ProcessState.NotRunning:
                                p.kill()
                                p.waitForFinished(600)
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    p.deleteLater()
                except Exception:
                    pass
            self._analysis_proc = None
        except Exception:
            pass
        try:
            w = getattr(self, "_analysis_watchdog", None)
            if w is not None:
                w.stop()
                w.deleteLater()
            self._analysis_watchdog = None
        except Exception:
            pass
        try:
            tmr = getattr(self, "_analysis_prog_timer", None)
            if tmr is not None:
                tmr.stop()
                tmr.deleteLater()
            self._analysis_prog_timer = None
        except Exception:
            pass
        try:
            pb = getattr(self, "progress_bar", None)
            if pb is not None:
                pb.deleteLater()
            self.progress_bar = None
        except Exception:
            pass
        try:
            if getattr(self, "analyze_button", None) is not None and (not bool(getattr(self, "_manual_scan_active", False))) and (not bool(getattr(self, "_manual_scan_block_ai", False))):
                self.analyze_button.setEnabled(True)
        except Exception:
            pass
        try:
            if getattr(self, "abort_button", None):
                self.abort_button.setEnabled(False)
        except Exception:
            pass
        try:
            self._pipeline_set(
                "analysis",
                "Ανάλυση: σταμάτησε",
                "Η ανάλυση διακόπηκε λόγω χειροκίνητης διόρθωσης.",
                progress=0,
                step_status_updates={"analysis": "WAIT"},
            )
        except Exception:
            pass

    def _on_abort_clicked(self):
        try:
            if getattr(self, "_analysis_proc", None) is None:
                return
        except Exception:
            return
        try:
            reply = QMessageBox.question(
                self,
                "Διακοπή Ανάλυσης",
                "Είστε σίγουροι ότι θέλετε να σταματήσετε τη διαδικασία;",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
        except Exception:
            reply = QMessageBox.StandardButton.Yes
        if reply != QMessageBox.StandardButton.Yes:
            return
        try:
            pb = getattr(self, "progress_bar", None)
            if pb is not None:
                try:
                    v = int(max(0, min(100, int(pb.value()))))
                except Exception:
                    v = 0
                try:
                    eta_secs = float(getattr(self, "_analysis_last_eta_secs", 0.0) or 0.0)
                except Exception:
                    eta_secs = 0.0
                try:
                    self._analysis_last_eta_progress = float(v)
                except Exception:
                    pass
                try:
                    mins = int(max(0.0, eta_secs) // 60.0)
                    secs = int(max(0.0, eta_secs) % 60.0)
                    self._append_comm(
                        "Σύστημα",
                        f"Διακοπή ανάλυσης στο {v}% (~{mins:02d}:{secs:02d} απομένουν).",
                    )
                except Exception:
                    pass
                try:
                    self._trace_log(
                        "analysis_user_abort_eta",
                        {
                            "progress": int(v),
                            "eta_secs": float(eta_secs),
                        },
                    )
                except Exception:
                    pass
                try:
                    pb.setStyleSheet("QProgressBar::chunk { background-color: red; }")
                except Exception:
                    pass
                try:
                    pb.setValue(0)
                except Exception:
                    pass
        except Exception:
            pass
        try:
            if getattr(self, "abort_button", None):
                self.abort_button.setEnabled(False)
        except Exception:
            pass
        self._abort_running_analysis("user_button")

    def _on_analysis_progress_changed(self, value: int):
        try:
            pb = getattr(self, "progress_bar", None)
            if pb is None:
                return
            start = getattr(self, "_analysis_started_at", None)
            if not start:
                pb.setFormat("%p%")
                return
            elapsed = time.perf_counter() - float(start)
            try:
                v = float(value)
            except Exception:
                v = 0.0
            if v <= 0.0:
                total_est = float(getattr(self, "_analysis_expected_secs", 0.0) or 0.0)
                if total_est <= 0.0:
                    pb.setFormat("%p%")
                    return
            else:
                total_raw = elapsed * 100.0 / max(1.0, v)
                exp = float(getattr(self, "_analysis_expected_secs", 0.0) or 0.0)
                if exp > 0.0:
                    alpha = 0.2
                    total_est = alpha * total_raw + (1.0 - alpha) * exp
                else:
                    total_est = total_raw
                self._analysis_expected_secs = total_est
            remaining = max(0.0, total_est - elapsed)
            self._analysis_last_eta_secs = float(remaining)
            self._analysis_last_eta_progress = float(max(0.0, min(100.0, v)))
            mins = int(remaining // 60.0)
            secs = int(remaining % 60.0)
            pb.setFormat(f"%p% — ~{mins:02d}:{secs:02d} απομένουν")
        except Exception:
            try:
                if getattr(self, "progress_bar", None):
                    self.progress_bar.setFormat("%p%")
            except Exception:
                pass

    def verify_reanalysis(self):
        if not self.current_image_path:
            return
        try:
            if bool(getattr(self, "_manual_scan_active", False)) or bool(getattr(self, "_manual_scan_block_ai", False)):
                try:
                    self._append_comm("Σύστημα", "Επαλήθευση: παραλείφθηκε (χειροκίνητη σάρωση ενεργή).")
                except Exception:
                    pass
                return
        except Exception:
            pass
        try:
            self._verify_started_at = time.perf_counter()
        except Exception:
            self._verify_started_at = None
        base = os.path.splitext(self.current_image_path)[0]
        json_path = base + "_analysis.json"
        if not os.path.exists(json_path):
            QMessageBox.warning(self, "Επαλήθευση", "Δεν βρέθηκε αποθηκευμένη ανάλυση για σύγκριση.")
            return
        try:
            with open(json_path, "r", encoding="utf-8") as f:
                saved = json.load(f) or {}
        except Exception:
            QMessageBox.warning(self, "Επαλήθευση", "Αποτυχία φόρτωσης αποθηκευμένης ανάλυσης.")
            return

        valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
        boxes = saved.get("boxes", []) or []
        fdis = saved.get("fdi", []) or []
        statuses = saved.get("statuses", []) or []
        baseline_by_fdi = {}
        baseline_missing = set()
        for i, box in enumerate(boxes):
            fdi = str(fdis[i]).strip() if i < len(fdis) else ""
            if fdi not in valid_fdi_set:
                continue
            st = statuses[i] if i < len(statuses) else []
            st0 = st if isinstance(st, list) else []
            if any("ελλείπ" in str(x).lower() for x in st0 if str(x).strip()):
                baseline_missing.add(fdi)
                continue
            baseline_by_fdi[fdi] = {"box": box, "statuses": st, "score": 1.0}

        if not baseline_by_fdi:
            QMessageBox.warning(self, "Επαλήθευση", "Η αποθηκευμένη ανάλυση δεν έχει έγκυρα FDI για σύγκριση.")
            return

        self._verify_baseline_by_fdi = baseline_by_fdi
        self._verify_baseline_path = json_path
        self._verify_expected_missing_fdis = sorted(baseline_missing, key=lambda x: int(x)) if baseline_missing else []

        self.verify_progress_bar = QProgressBar()
        self.verify_progress_bar.setRange(0, 100)
        self.verify_progress_bar.setValue(0)
        self.left_layout.insertWidget(1, self.verify_progress_bar)
        try:
            self.verify_button.setEnabled(False)
        except Exception:
            pass

        geometry = self._collect_geometry_data()
        self.verify_worker = AnalysisWorker(self.current_image_path, self.model_path, geometry=geometry)
        self.verify_worker.progress.connect(self.verify_progress_bar.setValue)
        self.verify_worker.finished.connect(self.verify_worker.deleteLater)
        self.verify_worker.results.connect(self.handle_verify_finished)
        self.verify_worker.error.connect(self.handle_verify_error)
        self.verify_worker.start()

    def _load_latest_analysis_from_history(self, exclude_image_path: str | None = None):
        if getattr(self, "origin_patient_id", None) is None:
            return None
        try:
            db = QSqlDatabase.database("patients_connection")
        except Exception:
            db = None
        if db is None or not db.isOpen():
            return None
        ex = str(exclude_image_path or "").strip()
        try:
            q = QSqlQuery(db)
            q.prepare(
                "SELECT timestamp, analysis_data, image_path FROM radiograph_history "
                "WHERE patient_id=? AND analysis_data IS NOT NULL AND analysis_data<>'' "
                "ORDER BY timestamp DESC"
            )
            q.addBindValue(self.origin_patient_id)
            if q.exec():
                while q.next():
                    ts = str(q.value(0) or "").strip()
                    img_path = str(q.value(2) or "").strip()
                    if ex and img_path and os.path.abspath(img_path) == os.path.abspath(ex):
                        continue
                    raw = q.value(1)
                    raw_s = str(raw) if raw is not None else ""
                    if not raw_s.strip():
                        continue
                    try:
                        data = json.loads(raw_s)
                    except Exception:
                        continue
                    if isinstance(data, dict) and data:
                        return {"timestamp": ts, "image_path": img_path, "data": data}
        except Exception:
            return None
        return None

    def _analysis_to_fdi_map(self, data: dict):
        valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
        boxes = (data or {}).get("boxes", []) or []
        fdis = (data or {}).get("fdi", []) or []
        statuses = (data or {}).get("statuses", []) or []
        scores = (data or {}).get("scores", []) or []
        out = {}
        for i, box in enumerate(boxes):
            fdi = str(fdis[i]).strip() if i < len(fdis) else ""
            if fdi not in valid_fdi_set:
                continue
            st = statuses[i] if i < len(statuses) else []
            st0 = st if isinstance(st, list) else []
            if any("ελλείπ" in str(x).lower() for x in st0 if str(x).strip()):
                continue
            sc = scores[i] if i < len(scores) else 1.0
            try:
                sc = float(sc)
            except Exception:
                sc = 1.0
            prev = out.get(fdi)
            if prev is None or float(prev.get("score") or 0.0) < sc:
                out[fdi] = {"box": box, "statuses": st0, "score": sc}
        return out

    def _compute_image_quality_stats(self, path: str):
        p = str(path or "").strip()
        if not p or not os.path.exists(p):
            return None
        try:
            arr = None
            if p.lower().endswith(".dcm"):
                try:
                    ds = pydicom.dcmread(p)
                    arr = ds.pixel_array
                    if hasattr(ds, "PhotometricInterpretation") and str(ds.PhotometricInterpretation) == "MONOCHROME1":
                        arr = np.amax(arr) - arr
                except Exception:
                    arr = None
            else:
                try:
                    img = cv2.imdecode(np.fromfile(p, dtype=np.uint8), cv2.IMREAD_GRAYSCALE)
                    arr = img
                except Exception:
                    arr = None
            if arr is None:
                return None
            a = np.asarray(arr)
            if a.size == 0:
                return None
            a = a.astype(np.float32)
            mean = float(np.mean(a))
            std = float(np.std(a))
            try:
                lap = cv2.Laplacian(a, cv2.CV_32F)
                sharp = float(np.var(lap))
            except Exception:
                sharp = None
            return {"mean": mean, "std": std, "sharpness": sharp}
        except Exception:
            return None

    def _prepare_comparative_baseline_before_analysis(self):
        self._compare_baseline = None
        self._compare_quality = None
        if getattr(self, "origin_patient_id", None) is None:
            return
        cur = str(getattr(self, "current_image_path", "") or "").strip()
        prev = self._load_latest_analysis_from_history(exclude_image_path=cur)
        if not prev:
            return
        self._compare_baseline = prev
        try:
            prev_img_path = str(prev.get("image_path") or "").strip()
            prev_layout_path = os.path.splitext(prev_img_path)[0] + "_layout.json" if prev_img_path else ""
            have_layout = bool(getattr(self, "_loaded_layout_from_analysis", False)) or bool(getattr(self, "_loaded_layout_from_sidecar", False))
            if prev_layout_path and os.path.exists(prev_layout_path) and not have_layout and self.pixmap_item and self.scene:
                try:
                    with open(prev_layout_path, "r", encoding="utf-8") as f:
                        lay = json.load(f) or {}
                except Exception:
                    lay = {}
                if isinstance(lay, dict):
                    rect = self.pixmap_item.boundingRect()
                    cur_w = float(rect.width() or 1.0)
                    cur_h = float(rect.height() or 1.0)
                    grid = lay.get("grid")
                    if isinstance(grid, dict) and bool(grid.get("active")) and not bool(getattr(self, "grid_active", False)):
                        try:
                            self._restore_grid_from_data(grid)
                            self.grid_active = True
                            self.grid_visible = bool(grid.get("visible", True))
                            try:
                                if hasattr(self, "grid_button") and self.grid_button is not None:
                                    self.grid_button.blockSignals(True)
                                    self.grid_button.setChecked(bool(self.grid_visible))
                                    self.grid_button.blockSignals(False)
                            except Exception:
                                pass
                        except Exception:
                            pass
                    jaw = lay.get("jaw_lines")
                    if isinstance(jaw, dict) and not self._is_scene_item_alive(getattr(self, "jaw_separator_line", None)):
                        yv = jaw.get("y_split", None)
                        xv = jaw.get("x_split", None)
                        curve_h = float(jaw.get("curve_h") or 0)
                        try:
                            prev_w = float(lay.get("image_w") or 0.0)
                            prev_h = float(lay.get("image_h") or 0.0)
                        except Exception:
                            prev_w = 0.0
                            prev_h = 0.0
                        try:
                            sx = (cur_w / float(prev_w)) if prev_w else 1.0
                            sy = (cur_h / float(prev_h)) if prev_h else 1.0
                        except Exception:
                            sx = 1.0
                            sy = 1.0
                        try:
                            if yv is not None:
                                if isinstance(jaw.get("y_split_norm"), (int, float)):
                                    y_split = float(jaw.get("y_split_norm")) * float(cur_h)
                                else:
                                    y_split = float(yv) * float(sy)
                                self.jaw_separator_line = ZoneSeparatorLine(cur_w, y_split, label="Jaw Separator", color=Qt.GlobalColor.cyan, on_change_callback=self._on_jaw_lines_changed)
                                # curve_h logic removed

                                self.scene.addItem(self.jaw_separator_line)
                            if xv is not None:
                                if isinstance(jaw.get("x_split_norm"), (int, float)):
                                    x_split = float(jaw.get("x_split_norm")) * float(cur_w)
                                else:
                                    x_split = float(xv) * float(sx)
                                self.vertical_separator_line = VerticalSeparatorLine(cur_h, x_split, on_change_callback=self._on_jaw_lines_changed)
                                self.scene.addItem(self.vertical_separator_line)
                            try:
                                vis = bool(jaw.get("visible", True))
                                if self._is_scene_item_alive(getattr(self, "jaw_separator_line", None)):
                                    self.jaw_separator_line.setVisible(vis)
                                if self._is_scene_item_alive(getattr(self, "vertical_separator_line", None)):
                                    self.vertical_separator_line.setVisible(vis)
                            except Exception:
                                pass
                            self.apply_layout_lock()
                        except Exception:
                            pass
                    try:
                        self._schedule_layout_save(0)
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            ts = str(prev.get("timestamp") or "").strip()
            img_name = os.path.basename(str(prev.get("image_path") or "")) or "προηγούμενη"
            if ts:
                self._append_comm("Σύστημα", f"Βρέθηκε προηγούμενη ανάλυση ({ts}) για σύγκριση: {img_name}")
            else:
                self._append_comm("Σύστημα", f"Βρέθηκε προηγούμενη ανάλυση για σύγκριση: {img_name}")
        except Exception:
            pass

    def _append_comparative_report_after_analysis(self):
        base = getattr(self, "_compare_baseline", None)
        if not isinstance(base, dict):
            return
        base_data = base.get("data")
        if not isinstance(base_data, dict) or not isinstance(getattr(self, "analysis_results", None), dict):
            return
        baseline_by_fdi = self._analysis_to_fdi_map(base_data)
        pred_by_fdi = self._analysis_to_fdi_map(self.analysis_results or {})
        if not baseline_by_fdi or not pred_by_fdi:
            return
        report = build_report(baseline_by_fdi, pred_by_fdi, iou_threshold=0.5)
        s = report.get("summary", {}) if isinstance(report, dict) else {}
        ts = str(base.get("timestamp") or "").strip()
        prev_img = os.path.basename(str(base.get("image_path") or "")) or "?"
        cur_img = os.path.basename(str(getattr(self, "current_image_path", "") or "")) or "?"
        self.results_text_edit.append("")
        self.results_text_edit.append(f"🧭 Σύγκριση με προηγούμενη εξέταση ({ts or 'χωρίς ημερομηνία'})")
        self.results_text_edit.append(f"- προηγούμενη: {prev_img}")
        self.results_text_edit.append(f"- νέα: {cur_img}")
        try:
            self.results_text_edit.append(
                f"- matched: {s.get('matched')} | missing: {s.get('missing')} | extra: {s.get('extra')} | moved: {s.get('moved_iou_below_threshold')} | status_changed: {s.get('status_changed')}"
            )
        except Exception:
            pass
        try:
            per = report.get("per_fdi", []) if isinstance(report, dict) else []
            if isinstance(per, list) and per:
                self.results_text_edit.append("Αλλαγές ανά δόντι:")
                out_lines = []
                for row in per:
                    if not isinstance(row, dict):
                        continue
                    fdi = str(row.get("fdi", "")).strip()
                    if not fdi:
                        continue
                    if row.get("missing"):
                        out_lines.append(f"- {fdi}: λείπει στη νέα ανάλυση")
                        continue
                    if row.get("extra"):
                        out_lines.append(f"- {fdi}: νέο στη νέα ανάλυση")
                        continue
                    add_st = row.get("status_added", []) if isinstance(row.get("status_added"), list) else []
                    rem_st = row.get("status_removed", []) if isinstance(row.get("status_removed"), list) else []
                    parts = []
                    if add_st:
                        parts.append("νέα: " + ", ".join(str(x) for x in add_st))
                    if rem_st:
                        parts.append("αφαιρέθηκαν: " + ", ".join(str(x) for x in rem_st))
                    iou = row.get("iou")
                    if isinstance(iou, (int, float)) and float(iou) < 0.5:
                        parts.append(f"μετατόπιση (IoU {float(iou):.2f})")
                    if parts:
                        out_lines.append(f"- {fdi}: " + " | ".join(parts))
                if out_lines:
                    shown = out_lines[:24]
                    for ln in shown:
                        self.results_text_edit.append(ln)
                    if len(out_lines) > len(shown):
                        self.results_text_edit.append(f"- …(+{len(out_lines) - len(shown)})")
        except Exception:
            pass
        q = getattr(self, "_compare_quality", None)
        if isinstance(q, dict):
            try:
                prev_q = q.get("prev") or {}
                cur_q = q.get("cur") or {}
                if prev_q and cur_q:
                    dm = float(cur_q.get("mean")) - float(prev_q.get("mean"))
                    ds = float(cur_q.get("std")) - float(prev_q.get("std"))
                    self.results_text_edit.append(f"- ποιότητα (Δmean/Δstd): {dm:+.1f} / {ds:+.1f}")
            except Exception:
                pass
        try:
            self._append_comm("Σύστημα", f"Έτοιμη σύγκριση με προηγούμενη εξέταση ({ts or '—'}).")
        except Exception:
            pass

    def handle_verify_finished(self, results):
        try:
            if getattr(self, "verify_progress_bar", None):
                self.verify_progress_bar.deleteLater()
        except Exception:
            pass
        try:
            self.verify_button.setEnabled(True)
        except Exception:
            pass

        baseline_by_fdi = getattr(self, "_verify_baseline_by_fdi", None)
        if not isinstance(baseline_by_fdi, dict) or not results:
            return

        pred = {
            "boxes": results.get("boxes", []) or [],
            "labels": results.get("labels", []) or [],
            "scores": results.get("scores", []) or [],
            "statuses": results.get("statuses", []) or [],
            "notes": [""] * len(results.get("boxes", []) or []),
            "last_updated": [None] * len(results.get("boxes", []) or []),
            "bypass_grid": [False] * len(results.get("boxes", []) or []),
        }
        pred = self.assign_fdi_numbers(pred)

        valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
        pred_by_fdi = {}
        boxes = pred.get("boxes", []) or []
        fdis = pred.get("fdi", []) or []
        statuses = pred.get("statuses", []) or []
        scores = pred.get("scores", []) or []
        for i, box in enumerate(boxes):
            fdi = str(fdis[i]).strip() if i < len(fdis) else ""
            if fdi not in valid_fdi_set:
                continue
            score = float(scores[i]) if i < len(scores) else 0.0
            st = statuses[i] if i < len(statuses) else []
            prev = pred_by_fdi.get(fdi)
            if (prev is None) or (score > float(prev.get("score") or 0.0)):
                pred_by_fdi[fdi] = {"box": box, "statuses": st, "score": score}

        report = build_report(baseline_by_fdi, pred_by_fdi, iou_threshold=0.5)
        report_path = write_report(self.project_root, self.current_image_path, report)
        try:
            started_at = getattr(self, "_verify_started_at", None)
            elapsed = (time.perf_counter() - float(started_at)) * 1000.0 if started_at else None
        except Exception:
            elapsed = None
        try:
            self._announce_action_done("Επαλήθευση επανάλυσης", elapsed_ms=elapsed)
        except Exception:
            pass

        try:
            s = report.get("summary", {}) if isinstance(report, dict) else {}
            self.results_text_edit.append("")
            self.results_text_edit.append("🔍 Επαλήθευση Επανάλυσης")
            self.results_text_edit.append(f"- matched: {s.get('matched')} | missing: {s.get('missing')} | extra: {s.get('extra')} | moved: {s.get('moved_iou_below_threshold')} | status_changed: {s.get('status_changed')}")
            try:
                exp_miss = getattr(self, "_verify_expected_missing_fdis", None)
                if isinstance(exp_miss, list) and exp_miss:
                    self.results_text_edit.append(f"- ελλείποντα (καταγραφή): {', '.join([str(x) for x in exp_miss if str(x).strip()])}")
            except Exception:
                pass
            if report_path:
                self.results_text_edit.append(f"- report: {report_path}")
        except Exception:
            pass

        try:
            self._show_reanalysis_differences_dialog(report, report_path)
        except Exception:
            pass

    def handle_verify_error(self, message):
        try:
            if getattr(self, "verify_progress_bar", None):
                self.verify_progress_bar.deleteLater()
        except Exception:
            pass
        try:
            self.verify_button.setEnabled(True)
        except Exception:
            pass
        try:
            self._announce_action_failed(f"Επαλήθευση: {message}")
        except Exception:
            pass
        QMessageBox.warning(self, "Επαλήθευση", str(message))

    def _show_reanalysis_differences_dialog(self, report: dict, report_path: str | None):
        if not isinstance(report, dict):
            return
        per = report.get("per_fdi", [])
        if not isinstance(per, list) or not per:
            return

        lines = []
        for row in per:
            if not isinstance(row, dict):
                continue
            fdi = str(row.get("fdi", "")).strip()
            if not fdi:
                continue

            if row.get("missing"):
                lines.append(f"Δόντι {fdi}: Λείπει στην επανάλυση")
                continue
            if row.get("extra"):
                sc = row.get("pred", {}).get("score") if isinstance(row.get("pred"), dict) else None
                sc_part = f" (score {float(sc):.2f})" if isinstance(sc, (int, float)) else ""
                lines.append(f"Δόντι {fdi}: Επιπλέον στην επανάλυση{sc_part}")
                continue

            iou = row.get("iou")
            add_st = row.get("status_added", []) if isinstance(row.get("status_added"), list) else []
            rem_st = row.get("status_removed", []) if isinstance(row.get("status_removed"), list) else []
            parts = []
            if isinstance(iou, (int, float)) and float(iou) < 0.5:
                parts.append(f"μετατόπιση (IoU {float(iou):.2f})")
            if add_st:
                parts.append("+" + ", ".join([str(x) for x in add_st if str(x).strip()]))
            if rem_st:
                parts.append("-" + ", ".join([str(x) for x in rem_st if str(x).strip()]))
            if parts:
                lines.append(f"Δόντι {fdi}: " + " | ".join(parts))

        if not lines:
            lines.append("Δεν βρέθηκαν ουσιαστικές διαφορές ανά δόντι.")

        dlg = QDialog(self)
        dlg.setWindowTitle("Διαφορές Επανάλυσης (ανά δόντι)")
        layout = QVBoxLayout(dlg)

        header = QLabel("Διαφορές μεταξύ αποθηκευμένης διόρθωσης και νέας ανάλυσης:")
        layout.addWidget(header)

        txt = QTextEdit()
        txt.setReadOnly(True)
        content = "\n".join(lines)
        if report_path:
            content = content + "\n\n" + f"Report: {report_path}"
        txt.setPlainText(content)
        layout.addWidget(txt)

        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        btns.rejected.connect(dlg.reject)
        btns.accepted.connect(dlg.accept)
        layout.addWidget(btns)

        try:
            dlg.resize(700, 500)
        except Exception:
            pass
        dlg.exec()

    def _clear_analysis_items(self):
        """
        Removes only analysis-related items (boxes, labels, text) from the scene,
        preserving the image, calibration lines, and anatomical lines.
        """
        if not self.scene: return
        
        # Collect items to remove
        items_to_remove = []
        
        # 1. From analysis_items list
        if hasattr(self, "analysis_items") and self.analysis_items:
            items_to_remove.extend(self.analysis_items)
        self.analysis_items = []
        
        # 2. Scan scene for types and ghosts
        for item in self.scene.items():
            t = type(item).__name__
            # Primary analysis items
            if t in ("EditableRectItem", "EditableTextItem", "ZoneSeparatorLine", "VerticalSeparatorLine"):
                items_to_remove.append(item)
                
                # Check for attached ghost items
                if hasattr(item, "ghost_item") and item.ghost_item:
                    items_to_remove.append(item.ghost_item)
                
                # Check for attached text items (if Rect)
                if hasattr(item, "text_item") and item.text_item:
                    items_to_remove.append(item.text_item)
            
            # Explicit check for ghosts that might be orphaned
            if isinstance(item, QGraphicsTextItem):
                # Ghosts have opacity 0.6 and are high Z
                if item.opacity() < 0.8 and item.zValue() > 50:
                    items_to_remove.append(item)

        # 3. Remove duplicates and execute
        for item in list(set(items_to_remove)):
            try:
                if item.scene() == self.scene:
                    self.scene.removeItem(item)
            except Exception:
                pass


    def on_image_loaded(self, qimg, np_img, file_path):
        try:
            if file_path != self.current_image_path:
                return
                
            if qimg is None or qimg.isNull():
                self.results_text_edit.append(f"Αποτυχία φόρτωσης: {os.path.basename(file_path)}")
                return

            self.pixmap_item = QGraphicsPixmapItem(QPixmap.fromImage(qimg))
            try:
                self.pixmap_item.setZValue(-10)
            except Exception:
                pass
            self.original_image_np = np_img
            
            self.scene.addItem(self.pixmap_item)
            try:
                if bool(getattr(self, "manual_pan_enabled", False)):
                    self._update_scene_rect_for_pan()
                else:
                    self.scene.setSceneRect(self.pixmap_item.boundingRect())
            except Exception:
                try:
                    if bool(getattr(self, "manual_pan_enabled", False)):
                        self._update_scene_rect_for_pan()
                    else:
                        self.scene.setSceneRect(self.scene.itemsBoundingRect())
                except Exception:
                    pass
            self.view.fit_scene_in_view()

            try:
                base = os.path.splitext(str(self.current_image_path or ""))[0]
                json_path = base + "_analysis.json"
                self.results_text_edit.clear()
                self.results_text_edit.append(f"Εικόνα: {os.path.basename(str(self.current_image_path or ''))}")
                if os.path.exists(json_path):
                    self.results_text_edit.append("Βρέθηκε αποθηκευμένη ανάλυση. Φόρτωση…")
                else:
                    self.results_text_edit.append("Δεν υπάρχει αποθηκευμένη ανάλυση. Πάτησε «Ανάλυση».")
            except Exception:
                pass

            try:
                self._loaded_layout_from_sidecar = False
                self._loaded_layout_from_analysis = False
                self._load_layout_sidecar()
            except Exception:
                self._loaded_layout_from_sidecar = False

            self.load_analysis_results()
            try:
                if not bool(getattr(self, "_loaded_layout_from_analysis", False)) and not bool(getattr(self, "_loaded_layout_from_sidecar", False)):
                    self._apply_layout_snapshot_from_prefs()
            except Exception:
                pass
            try:
                calib_ok = self._pipeline_is_calibrated()
            except Exception:
                calib_ok = False
            try:
                lines_ok = self._pipeline_has_lines()
            except Exception:
                lines_ok = False
            try:
                grid_ok = self._pipeline_has_grid()
            except Exception:
                grid_ok = False
            try:
                self._pipeline_set(
                    "image",
                    "Εικόνα φορτώθηκε",
                    self._pipeline_hint_for_step("dups"),
                    progress=2,
                    step_status_updates={
                        "image": "OK",
                        "dups": "WAIT",
                        "crop": "WAIT",
                        "calib": "OK" if calib_ok else "TODO",
                        "lines": "OK" if lines_ok else "TODO",
                        "grid": "OK" if grid_ok else "TODO",
                        "analysis": "WAIT",
                        "review": "WAIT",
                        "save": "WAIT",
                        "sync": "WAIT",
                        "train": "WAIT",
                        "eval": "WAIT",
                    },
                )
            except Exception:
                pass
            try:
                base = os.path.splitext(self.current_image_path)[0]
                json_path = base + "_analysis.json"
                if os.path.exists(json_path):
                    self.verify_button.setEnabled(True)
            except Exception:
                pass
            try:
                base = os.path.splitext(self.current_image_path)[0]
                json_path = base + "_analysis.json"
                has_current = bool(os.path.exists(json_path))
            except Exception:
                has_current = False
            try:
                prev_json = self._find_latest_analysis_json(exclude_current=True)
                can_transfer = bool((not has_current) and prev_json and os.path.exists(prev_json))
            except Exception:
                can_transfer = False
            try:
                if hasattr(self, "transfer_prev_button") and self.transfer_prev_button is not None:
                    self.transfer_prev_button.setEnabled(bool(can_transfer))
            except Exception:
                pass
            try:
                if hasattr(self, "transfer_prev_quick_button") and self.transfer_prev_quick_button is not None:
                    self.transfer_prev_quick_button.setEnabled(bool(can_transfer))
            except Exception:
                pass
            try:
                if hasattr(self, "change_overlay_button") and self.change_overlay_button is not None:
                    self.change_overlay_button.setEnabled(bool(can_transfer))
            except Exception:
                pass
            try:
                if hasattr(self, "change_overlay_quick_button") and self.change_overlay_quick_button is not None:
                    self.change_overlay_quick_button.setEnabled(bool(can_transfer))
            except Exception:
                pass
            try:
                if bool(can_transfer) and bool(getattr(self, "change_overlay_enabled", True)) and hasattr(self, "change_overlay_button") and self.change_overlay_button is not None:
                    self.change_overlay_button.blockSignals(True)
                    self.change_overlay_button.setChecked(True)
                    self.change_overlay_button.blockSignals(False)
                    self.toggle_change_overlay(True)
            except Exception:
                pass
            try:
                if bool(can_transfer) and bool(getattr(self, "change_overlay_enabled", True)) and hasattr(self, "change_overlay_quick_button") and self.change_overlay_quick_button is not None:
                    self.change_overlay_quick_button.blockSignals(True)
                    self.change_overlay_quick_button.setChecked(True)
                    self.change_overlay_quick_button.blockSignals(False)
            except Exception:
                pass
            try:
                self._maybe_auto_analyze_current_image()
            except Exception:
                pass
                
            # --- AUTO-ENABLE ANATOMICAL LINES ---
            try:
                if hasattr(self, "toggle_midline_btn") and self.toggle_midline_btn:
                    if not self.toggle_midline_btn.isChecked():
                        self.toggle_midline_btn.setChecked(True)
                        self.toggle_midline_visibility(True)
            except Exception as e:
                print(f"Auto-Line Error: {e}")

            try:
                base = os.path.splitext(str(self.current_image_path or ""))[0]
                has_saved = bool(base and os.path.exists(base + "_analysis.json"))
            except Exception:
                has_saved = False
            try:
                if has_saved:
                    self._pipeline_set(
                        "review",
                        "Φορτώθηκε αποθηκευμένη ανάλυση",
                        self._pipeline_hint_for_step("review"),
                        progress=50,
                        step_status_updates={"image": "OK", "analysis": "OK", "review": "TODO", "save": "WAIT", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
                    )
                else:
                    self._pipeline_set(
                        "image",
                        "Έτοιμο για ανάλυση",
                        self._pipeline_hint_for_step("image"),
                        progress=5,
                        step_status_updates={"image": "OK", "analysis": "TODO", "review": "WAIT", "save": "WAIT", "sync": "WAIT", "train": "WAIT", "eval": "WAIT"},
                    )
            except Exception:
                pass
        except Exception as e:
            print(f"Error in on_image_loaded: {e}")

    def display_selected_image(self, item):
        file_path = item.data(Qt.ItemDataRole.UserRole)
        self.current_image_path = file_path
        try:
            self._suppress_scan_tts_until = float(time.monotonic()) + 6.0
        except Exception:
            self._suppress_scan_tts_until = 0.0
        try:
            self._pipeline_waiting_confirm = False
            self._pipeline_pending_after_save_data = None
        except Exception:
            pass
        try:
            self._pipeline_last_change_summary = ""
            self._pipeline_last_change_details = []
            self._pipeline_last_change_report = None
        except Exception:
            pass
        try:
            self._fdi_item_cache = {}
            self._fdi_item_cache_image_path = None
        except Exception:
            pass
        try:
            self._pipeline_prompted_crop = False
            self._pipeline_dups_checked_path = None
            self._pipeline_dups_cached = None
        except Exception:
            pass
        try:
            self._pipeline_waiting_hide_grid_before_analysis = False
        except Exception:
            pass
        try:
            self._session_log("image_selected", {"path": str(file_path or "")})
        except Exception:
            pass
        try:
            if hasattr(self, "delete_image_button") and self.delete_image_button is not None:
                self.delete_image_button.setEnabled(True)
        except Exception:
            pass
        self.analyze_button.setEnabled(True)
        try:
            self.verify_button.setEnabled(False)
        except Exception:
            pass
        self.export_button.setEnabled(False)
        self.save_analysis_button.setEnabled(False)
        self.clear_analysis_button.setEnabled(False)
        try:
            if hasattr(self, "change_overlay_button") and self.change_overlay_button is not None:
                self.change_overlay_button.blockSignals(True)
                self.change_overlay_button.setChecked(False)
                self.change_overlay_button.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "change_overlay_quick_button") and self.change_overlay_quick_button is not None:
                self.change_overlay_quick_button.blockSignals(True)
                self.change_overlay_quick_button.setChecked(False)
                self.change_overlay_quick_button.blockSignals(False)
        except Exception:
            pass
        try:
            self._clear_change_overlay()
        except Exception:
            pass
        self.scene.clear()
        try:
            self.scene.setSceneRect(QRectF())
        except Exception:
            pass
        
        # Reset Analysis State
        self.analysis_results = None
        self.raw_analysis_results = None
        self.analysis_items = []  # Clear tracked items list
        
        # Reset calibration state
        self.pixel_to_mm_scale = None
        self.pixel_to_mm_scale_x = None
        self.pixel_to_mm_scale_y = None
        self.calib_line_x = None
        self.calib_line_y = None
        self.calibration_line = None
        self.calibration_button.setChecked(False)
        
        # Async loading
        if self.image_loader and self.image_loader.isRunning():
            self.image_loader.terminate()
            self.image_loader.wait(500)
        
        self.image_loader = ImageLoaderThread(file_path)
        self.image_loader.finished_signal.connect(self.on_image_loaded)
        self.image_loader.start()
        
        self.results_text_edit.clear()
        self.results_text_edit.append(f"Φόρτωση: {os.path.basename(file_path)}...")

    def load_analysis_results(self):
        if not self.current_image_path: return
        base = os.path.splitext(self.current_image_path)[0]
        json_path = base + "_analysis.json"
        
        # Clear existing analysis items from scene before loading
        # This prevents "ghost" items if we are reloading or if file was deleted but items remained
        self._clear_analysis_items()
        self.analysis_results = None
        self.raw_analysis_results = None
        
        self._loaded_layout_from_analysis = False
        tmp_path = json_path + ".tmp"
        if os.path.exists(tmp_path) and not os.path.exists(json_path):
            try:
                os.replace(tmp_path, json_path)
            except Exception:
                pass
        
        if not os.path.exists(json_path):
            try:
                self.results_text_edit.clear()
                self.results_text_edit.append(f"Εικόνα: {os.path.basename(str(self.current_image_path or ''))}")
                self.results_text_edit.append("Δεν υπάρχει αποθηκευμένη ανάλυση. Εκκίνηση Αυτόματης Προετοιμασίας...")
                
                # Reset UI state
                self.export_button.setEnabled(False)
                self.save_analysis_button.setEnabled(False)
                self.clear_analysis_button.setEnabled(False)
                if hasattr(self, "train_button"):
                    self.train_button.setEnabled(False)
                    
                # TRIGGER AUTO-WORKFLOW
                if bool(getattr(self, "auto_analyze_on_open", True)):
                    QTimer.singleShot(200, self._start_automated_workflow)
                else:
                    self.results_text_edit.append("\nℹ️ Η αυτόματη ανάλυση είναι απενεργοποιημένη.")
                    self.results_text_edit.append("Πάτησε «Ανάλυση» για να ξεκινήσεις.")
            except Exception:
                pass
            return
            
        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if data.get("deleted") is True:
                self.results_text_edit.clear()
                self.results_text_edit.append(f"Εικόνα: {os.path.basename(str(self.current_image_path or ''))}")
                self.results_text_edit.append("Η ανάλυση έχει διαγραφεί από τον χρήστη.")
                self.results_text_edit.append("Πάτησε «Ανάλυση» για νέα διάγνωση.")
                
                self.export_button.setEnabled(False)
                self.save_analysis_button.setEnabled(False)
                self.clear_analysis_button.setEnabled(False)
                if hasattr(self, "train_button"):
                    self.train_button.setEnabled(False)
                return

            if data.get("bad_quality") is True:
                try:
                    self.results_text_edit.append("\n⚠️ Η πανοραμική έχει σημανθεί ως κακής ποιότητας – ΠΡΟΣ ΕΠΑΝ-ΛΗΨΗ.")
                except Exception:
                    pass

            if not data or (not data.get("calibration") and not data.get("jaw_lines") and not data.get("boxes")):
                 raise ValueError("Empty or uninitialized analysis file")

            try:
                self._pipeline_baseline_data = copy.deepcopy(data) if isinstance(data, dict) else {}
                self._pipeline_waiting_confirm = False
                self._pipeline_pending_after_save_data = None
            except Exception:
                pass
            
            # 1. Restore Calibration
            calib = data.get('calibration', {})
            self.pixel_to_mm_scale_x = calib.get('scale_x')
            self.pixel_to_mm_scale_y = calib.get('scale_y')
            self.pixel_to_mm_scale = calib.get('scale')
            try:
                if self.pixel_to_mm_scale is None:
                    if (self.pixel_to_mm_scale_x is not None) and (self.pixel_to_mm_scale_y is not None):
                        self.pixel_to_mm_scale = (float(self.pixel_to_mm_scale_x) + float(self.pixel_to_mm_scale_y)) / 2.0
                    elif self.pixel_to_mm_scale_x is not None:
                        self.pixel_to_mm_scale = float(self.pixel_to_mm_scale_x)
                    elif self.pixel_to_mm_scale_y is not None:
                        self.pixel_to_mm_scale = float(self.pixel_to_mm_scale_y)
            except Exception:
                pass
            try:
                if "visible" in calib:
                    calib_visible = bool(calib.get("visible"))
                else:
                    calib_visible = bool((calib.get("line_x") or calib.get("line_y")) and self.pixel_to_mm_scale)
            except Exception:
                calib_visible = False
            
            # Restore Calibration Lines
            if 'line_x' in calib:
                lx_data = calib['line_x']
                if isinstance(lx_data, list):
                    coords = lx_data
                    mm = None
                else:
                    coords = lx_data.get('coords')
                    mm = lx_data.get('mm_length')
                
                if coords:
                    try:
                        self._safe_remove_scene_item(getattr(self, "calib_line_x", None))
                    except Exception:
                        pass
                    try:
                        coords = self._clamp_calibration_coords(coords, "x")
                    except Exception:
                        pass
                    self.calib_line_x = CalibrationLine(*coords, on_calibrated=self.apply_calibration, axis_type='x', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                    self.calib_line_x.mm_length = mm
                    self.scene.addItem(self.calib_line_x)
            
            if 'line_y' in calib:
                ly_data = calib['line_y']
                if isinstance(ly_data, list):
                    coords = ly_data
                    mm = None
                else:
                    coords = ly_data.get('coords')
                    mm = ly_data.get('mm_length')
                
                if coords:
                    try:
                        self._safe_remove_scene_item(getattr(self, "calib_line_y", None))
                    except Exception:
                        pass
                    try:
                        coords = self._clamp_calibration_coords(coords, "y")
                    except Exception:
                        pass
                    self.calib_line_y = CalibrationLine(*coords, on_calibrated=self.apply_calibration, axis_type='y', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                    self.calib_line_y.mm_length = mm
                    self.scene.addItem(self.calib_line_y)

            try:
                if self.calib_line_x:
                    self.calib_line_x.setVisible(bool(calib_visible))
                if self.calib_line_y:
                    self.calib_line_y.setVisible(bool(calib_visible))
            except Exception:
                pass
            try:
                self.calibration_button.blockSignals(True)
                self.calibration_button.setChecked(bool(calib_visible))
                self.calibration_button.blockSignals(False)
            except Exception:
                pass
            self.is_calibrating = bool(calib_visible)
            
            # 2. Restore Jaw Lines
            jaw_lines = data.get('jaw_lines', {})
            if isinstance(jaw_lines, dict) and self.pixmap_item and ('y_split' in jaw_lines or 'x_split' in jaw_lines):
                y_split = jaw_lines.get('y_split', None)
                x_split = jaw_lines.get('x_split', None)
                curve_h = jaw_lines.get("curve_h", 0)
                jaw_visible = True
                try:
                    if "visible" in jaw_lines:
                        jaw_visible = bool(jaw_lines.get("visible"))
                except Exception:
                    jaw_visible = True
                
                rect = self.pixmap_item.boundingRect()
                width = rect.width()
                height = rect.height()
                
                if y_split is not None:
                    try:
                        self._safe_remove_scene_item(getattr(self, "jaw_separator_line", None))
                    except Exception:
                        pass
                    self.jaw_separator_line = None
                    self.jaw_separator_line = ZoneSeparatorLine(width, float(y_split), label="Jaw Separator", color=Qt.GlobalColor.cyan, on_change_callback=None)

                    self.scene.addItem(self.jaw_separator_line)
                    self.jaw_separator_line.on_change_callback = self.recalculate_fdi
                    try:
                        self.jaw_separator_line.setVisible(bool(jaw_visible))
                    except Exception:
                        pass
                
                if x_split is not None:
                    try:
                        self._safe_remove_scene_item(getattr(self, "vertical_separator_line", None))
                    except Exception:
                        pass
                    self.vertical_separator_line = None
                    self.vertical_separator_line = VerticalSeparatorLine(height, float(x_split), on_change_callback=None)
                    self.scene.addItem(self.vertical_separator_line)
                    self.vertical_separator_line.on_change_callback = self.recalculate_fdi
                    try:
                        self.vertical_separator_line.setVisible(bool(jaw_visible))
                    except Exception:
                        pass
                
                # [FIX] Force Automated Workflow if Critical Lines are Missing
                # This handles cases where analysis exists but is empty/uninitialized
                try:
                    has_red_line = False
                    if getattr(self, 'calib_line_x', None):
                        try:
                            if self.calib_line_x.scene() == self.scene:
                                has_red_line = True
                        except: pass
                    
                    if not has_red_line:
                         self.results_text_edit.append("\n⚠️ Η ανάλυση δεν περιέχει γραμμές αναφοράς.")
                         self.results_text_edit.append("🤖 Εκκίνηση Αυτόματης Προετοιμασίας...")
                         QTimer.singleShot(800, self._start_automated_workflow)
                except Exception:
                    pass

                self.apply_layout_lock()
                self._loaded_layout_from_analysis = True

            grid_data = data.get("grid")
            if isinstance(grid_data, dict) and bool(grid_data.get("active")):
                self._restore_grid_from_data(grid_data)
                self._loaded_layout_from_analysis = True

            # 3. Restore Boxes
            boxes = data.get('boxes', [])
            fdi = data.get('fdi', [])
            statuses = data.get('statuses', [])
            bypass_grid = data.get('bypass_grid', [])
            label_offsets = data.get('label_offsets', [])
            label_offsets_user = data.get('label_offsets_user', [])
            notes = data.get('notes', [])
            last_updated = data.get('last_updated', [])
            implants = data.get('implants', [])
            last_updated_by = data.get('last_updated_by', [])
            
            if not boxes:
                try:
                    self.results_text_edit.clear()
                    self.results_text_edit.append("📂 Φόρτωση αποθηκευμένης ανάλυσης")
                    self.results_text_edit.append("-" * 30)
                    self.results_text_edit.append("Δεν υπάρχουν ανιχνεύσεις (0 boxes).")
                    dbg = data.get("debug")
                    if isinstance(dbg, dict):
                        try:
                            self.results_text_edit.append("")
                            self.results_text_edit.append("Διαγνωστικά:")
                            self.results_text_edit.append(str(dbg)[:1800])
                        except Exception:
                            pass
                except Exception:
                    pass
                return
            if boxes:
                # Handle legacy files and ensure all lists match boxes length
                n = len(boxes)
                if len(statuses) < n: statuses.extend([[]] * (n - len(statuses)))
                if len(bypass_grid) < n: bypass_grid.extend([False] * (n - len(bypass_grid)))
                if len(notes) < n: notes.extend([""] * (n - len(notes)))
                if len(last_updated) < n: last_updated.extend([None] * (n - len(last_updated)))
                if not isinstance(implants, list):
                    implants = []
                if len(implants) < n: implants.extend([{}] * (n - len(implants)))
                if not isinstance(last_updated_by, list):
                    last_updated_by = []
                if len(last_updated_by) < n: last_updated_by.extend([None] * (n - len(last_updated_by)))
                if not isinstance(label_offsets, list):
                    label_offsets = []
                if len(label_offsets) < n:
                    label_offsets.extend([[0.0, -20.0]] * (n - len(label_offsets)))
                if not isinstance(label_offsets_user, list):
                    label_offsets_user = []
                if len(label_offsets_user) < n:
                    label_offsets_user.extend([False] * (n - len(label_offsets_user)))

                # Reconstruct analysis results state from loaded data
                # to ensure grid interactions (recalculate_fdi) respect the edited data
                # Note: We don't have original scores, so we assign 1.0
                reconstructed_results = {
                    'boxes': boxes,
                    'labels': fdi,
                    'statuses': statuses,
                    'scores': [1.0] * len(boxes),
                    'bypass_grid': bypass_grid,
                    'notes': notes,
                    'last_updated': last_updated,
                    'implants': implants,
                    'last_updated_by': last_updated_by,
                }
                if isinstance(data.get("tooth_summary"), list):
                    reconstructed_results["tooth_summary"] = data.get("tooth_summary")
                if isinstance(data.get("radiograph_summary"), dict):
                    reconstructed_results["radiograph_summary"] = data.get("radiograph_summary")
                self.analysis_results = copy.deepcopy(reconstructed_results)
                self.raw_analysis_results = copy.deepcopy(reconstructed_results)
                try:
                    self._update_odontogram_from_results(self.analysis_results)
                except Exception:
                    pass
            
                for i in range(n):
                    box = boxes[i]
                    label = fdi[i]
                    status_list = statuses[i]
                    
                    x1, y1, x2, y2 = box
                    w = x2 - x1
                    h = y2 - y1
                    
                    label_str = ""
                    try:
                        s_fdi = str(label or "").strip()
                        if re.match(r"^\d+$", s_fdi):
                            label_str = s_fdi
                    except Exception:
                        label_str = ""
                    
                    # --- NEW VISUAL FEEDBACK: Colored Boxes ---
                    
                    # Determine Border Color based on Status
                    border_color = QColor(0, 255, 0, 180) # Default Green
                    
                    # Status Colors
                    st_colors = {
                        "Παθολογία": QColor(255, 0, 0, 200),
                        "Θεραπεία": QColor(0, 255, 255, 200),
                        "Αποκατάσταση": QColor(0, 0, 255, 200),
                        "Αμφίβολο": QColor(255, 165, 0, 200),
                    }
                    
                    # Flatten status list
                    s_flat = []
                    if isinstance(status_list, list):
                        s_flat = [str(s) for s in status_list]
                    else:
                        s_flat = [str(status_list)]
                    
                    # Simple heuristics for color
                    has_patho = any(x in ["Απόστημα", "Κύστη", "Καριές", "Περιοδοντίτιδα", "Κάταγμα", "Ριζικό υπόλειμμα", "Αιμορραγία", "Θύλακας", "Υποχώρηση ούλων", "Κινητικότητα"] for x in s_flat)
                    has_resto = any(x in ["Στεφάνη", "Γέφυρα", "Εμφύτευμα"] for x in s_flat)
                    has_treat = any(x in ["Ενδοδοντική", "Έμφραξη", "Ορθοδοντικό", "Εξαγωγή"] for x in s_flat)
                    
                    if has_patho:
                        border_color = st_colors["Παθολογία"]
                    elif has_resto:
                        border_color = st_colors["Αποκατάσταση"]
                    elif has_treat:
                        border_color = st_colors["Θεραπεία"]
                    
                    rect = EditableRectItem(x=x1, y=y1, w=w, h=h)
                    
                    # Set custom border color based on status
                    pen = QPen(border_color)
                    pen.setWidth(2)
                    rect.setPen(pen)
                    # We need to make sure EditableRectItem doesn't override this on paint.
                    # It likely uses 'status' property to determine color.
                    # So we should rely on set_statuses to do the right thing, 
                    # OR update EditableRectItem logic if needed.
                    
                    # Restore extended properties
                    rect.set_notes(notes[i])
                    rect.set_last_updated(last_updated[i])
                    try:
                        rect.set_last_updated_by(last_updated_by[i] if i < len(last_updated_by) else None)
                    except Exception:
                        pass
                    try:
                        rect.set_implant(implants[i] if i < len(implants) else None)
                    except Exception:
                        pass
                    
                    # Set statuses using the method to ensure consistency (tooltip, visual, etc)
                    # notify=False to avoid triggering updates during loading
                    rect.set_statuses(status_list, notify=False)
                        
                    self.scene.addItem(rect)
                    self.analysis_items.append(rect)
                    
                    text = EditableTextItem(label_str, rect_item=rect)
                    
                    # Set text color to match the box status color
                    text.setDefaultTextColor(border_color)
                    
                    dx, dy = 0.0, -20.0
                    use_off = False
                    try:
                        use_off = bool(label_offsets_user[i]) if i < len(label_offsets_user) else False
                    except Exception:
                        use_off = False
                    if use_off:
                        try:
                            off = label_offsets[i] if i < len(label_offsets) else [0.0, -20.0]
                            dx = float(off[0]) if isinstance(off, (list, tuple)) and len(off) >= 2 else 0.0
                            dy = float(off[1]) if isinstance(off, (list, tuple)) and len(off) >= 2 else -20.0
                        except Exception:
                            dx, dy = 0.0, -20.0
                        try:
                            rect.label_offset = QPointF(float(dx), float(dy))
                            rect.label_offset_user = True
                        except Exception:
                            pass
                        text.setPos(float(x1) + float(dx), float(y1) + float(dy))
                    self.scene.addItem(text)
                    self.analysis_items.append(text)
                    self._apply_overlay_visibility(rect, text)
                    try:
                        if not bool(getattr(rect, "label_offset_user", False)):
                            self._position_label_for_rect(rect)
                    except Exception:
                        pass
                    
                    # Attach callbacks
                    rect.on_change_callback = self.debounced_recalculate_fdi
                    text.on_change_callback = self.debounced_recalculate_fdi
                
                self.export_button.setEnabled(True)
                self.save_analysis_button.setEnabled(True)
                self.clear_analysis_button.setEnabled(True)
                
                # Enable Training Button since we have results
                try:
                    self.train_button.setEnabled(True)
                except Exception:
                    pass
                
                # Update Text Summary
                self.results_text_edit.clear()
                self.results_text_edit.append("📂 Φόρτωση αποθηκευμένης ανάλυσης")
                self.results_text_edit.append("-" * 30)
                
                found_items = sorted([str(f) for f in fdi if str(f) != '?'])
                if found_items:
                    self.results_text_edit.append(f"Ευρήματα ({len(found_items)}):")
                    self.results_text_edit.append(", ".join(found_items))

                tooth_summary = reconstructed_results.get("tooth_summary")
                if isinstance(tooth_summary, list) and tooth_summary:
                    self.results_text_edit.append("\nΔιάγνωση ανά δόντι:")
                    for i, fdi in enumerate(fdi):
                        if str(fdi) == "?":
                            continue
                        if i >= len(tooth_summary):
                            continue
                        sm = tooth_summary[i]
                        if not isinstance(sm, dict):
                            continue
                        tx = sm.get("text")
                        sev = sm.get("severity")
                        if tx:
                            sev_part = f" | Σοβαρότητα: {sev}" if sev else ""
                            self.results_text_edit.append(f"Δόντι {fdi}: {tx}{sev_part}")
                
                if self.pixel_to_mm_scale_x or self.pixel_to_mm_scale_y:
                    self.results_text_edit.append("\n📏 Βαθμονόμηση:")
                    if self.pixel_to_mm_scale_x:
                        self.results_text_edit.append(f"X Scale: {self.pixel_to_mm_scale_x:.4f} px/mm")
                    if self.pixel_to_mm_scale_y:
                        self.results_text_edit.append(f"Y Scale: {self.pixel_to_mm_scale_y:.4f} px/mm")
                elif self.pixel_to_mm_scale:
                    self.results_text_edit.append(f"\n📏 Βαθμονόμηση: {self.pixel_to_mm_scale:.4f} px/mm")
                 
        except Exception as e:
            print(f"Error loading analysis: {e}")
            try:
                self.results_text_edit.append(f"⚠️ Σφάλμα φόρτωσης ανάλυσης: {e}")
                self.results_text_edit.append("🤖 Εκκίνηση Αυτόματης Προετοιμασίας...")
                QTimer.singleShot(800, self._start_automated_workflow)
            except Exception:
                pass

    def _start_automated_workflow(self):
        """
        [AXIOM - FROZEN WORKFLOW]
        Initiates the automated diagnosis workflow strictly per user requirements.
        This sequence is an AXIOM and MUST NOT BE MODIFIED.
        
        Sequence:
        1. Predict Zones (Green)
        2. Create Condyle Line (Red) -> Define Midline
        3. Detect Jaw Bottom at Midline (Top-Down Scan)
        4. Create Vertical Calibration Line (Magenta) from Top Zone to Jaw Bottom
        5. Detect Spee Curve (Anchored to Red Line)
        6. Confirmation Dialog
        """
        try:
            try:
                self._trace_log("automated_workflow_start")
            except Exception:
                pass

            if not self.pixmap_item:
                print("Start Auto Workflow aborted: pixmap_item is None")
                try:
                    self._trace_log("automated_workflow_aborted", {"reason": "pixmap_item is None"})
                except Exception:
                    pass
                return
            
            self.results_text_edit.append("\n🤖 Αυτόματη Προετοιμασία...")
            QApplication.processEvents() # Ensure UI updates
            
            rect = self.pixmap_item.boundingRect()
            h = rect.height()
            w = rect.width()
            
            # --- STEP 1: ZONES (Green Lines) ---
            # Predict Y positions
            try:
                y1, y2 = self.zone_manager.predict_zones((h, w))
            except Exception as e:
                print(f"Zone pred error: {e}")
                y1, y2 = h*0.33, h*0.66
            
            # Create Zone 1 (Upper - Sinus Limit)
            if not self._is_scene_item_alive(self.zone_line_1):
                self.zone_line_1 = ZoneSeparatorLine(w, 0, label="Όριο Ιγμορείων / Άνω Γνάθου", color=Qt.GlobalColor.green)
                self.scene.addItem(self.zone_line_1)
            self.zone_line_1.setPos(0, y1)
            self.zone_line_1.setVisible(True)
            
            if not self._is_scene_item_alive(self.zone_line_2):
                self.zone_line_2 = ZoneSeparatorLine(w, 0, label="Διαχωρισμός Άνω/Κάτω Γνάθου", color=Qt.GlobalColor.green)
                self.scene.addItem(self.zone_line_2)
            self.zone_line_2.setPos(0, y2)
            self.zone_line_2.setVisible(True)
            
            # --- STEP 2: HORIZONTAL CONDYLE LINE (Red Line) ---
            # We create this EARLY to define the Midline.
            if not getattr(self, 'calib_line_x', None):
                 # Default: Top 25%, Width 85%
                 cx = w / 2
                 cy_condyle = h * 0.25
                 width_condyle = w * 0.85
                 self.calib_line_x = CalibrationLine(cx - width_condyle/2, cy_condyle, 
                                                     cx + width_condyle/2, cy_condyle, 
                                                     axis='x', label="Εύρος Κάτω Γνάθου (Κόνδυλοι)", 
                                                     color=Qt.GlobalColor.red)
                 self.scene.addItem(self.calib_line_x)
            self.calib_line_x.setVisible(True)
            
            # Calculate Midline X from the Red Line
            # Use handles to be precise
            try:
                p1_red = self.calib_line_x.mapToScene(self.calib_line_x.h1.pos())
                p2_red = self.calib_line_x.mapToScene(self.calib_line_x.h2.pos())
                mid_x = (p1_red.x() + p2_red.x()) / 2.0
            except:
                mid_x = w / 2.0
            
            # --- STEP 3: DETECT JAW BOTTOM (At Midline) ---
            try:
                bottom_y = self._detect_jaw_bottom(mid_x)
            except: bottom_y = None
            
            if bottom_y is None: bottom_y = rect.bottom() - (rect.height() * 0.1)
            
            # --- STEP 4: VERTICAL CALIBRATION LINE (Magenta) ---
            # Starts at Zone 1 (y1) intersection
            # Ends at Jaw Bottom (bottom_y)
            # Located at mid_x
            
            if not getattr(self, 'calib_line_y', None):
                 self.calib_line_y = CalibrationLine(mid_x, y1, mid_x, bottom_y, 
                                                     self.apply_calibration, axis_type='y', 
                                                     viewer_widget=self)
                 self.scene.addItem(self.calib_line_y)
            else:
                 self.scene.removeItem(self.calib_line_y)
                 self.calib_line_y = CalibrationLine(mid_x, y1, mid_x, bottom_y, 
                                                     self.apply_calibration, axis_type='y', 
                                                     viewer_widget=self)
                 self.scene.addItem(self.calib_line_y)
            self.calib_line_y.setVisible(True)

            # --- STEP 5: SPEE CURVE REMOVED ---
            # Logic completely removed as per user request.
            
            
            # --- STEP 6: CONFIRMATION ---
            QTimer.singleShot(100, lambda: self._prompt_auto_confirmation())
            
        except Exception as e:
            print(f"Auto workflow error: {e}")
            self.results_text_edit.append(f"❌ Σφάλμα Αυτοματισμού: {e}")

    def _prompt_auto_confirmation(self):
        reply = QMessageBox.question(self, "Αυτόματη Προετοιμασία", 
                                     "Η αυτόματη οριοθέτηση ολοκληρώθηκε.\nΕίναι σωστή η τοποθέτηση των γραμμών;",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        
        if reply == QMessageBox.StandardButton.Yes:
            self.analyze_image_with_ai()
        else:
            self.results_text_edit.append("✍️ Παρακαλώ διορθώστε τις γραμμές και πατήστε 'Ολοκλήρωση & Αποθήκευση'.")
            self.toggle_zoning_mode(True)

    def toggle_midline_visibility(self, checked):
        if checked:
            try:
                # Check if object exists but is deleted (C++ wrapped object deleted)
                is_deleted = False
                if getattr(self, "midline_item", None):
                    try:
                        _ = self.midline_item.scene()
                    except RuntimeError:
                        is_deleted = True
                
                if not getattr(self, "midline_item", None) or is_deleted or self.midline_item.scene() != self.scene:
                    # Re-create if missing or removed from scene
                    h = 1000
                    x = 500
                    if self.pixmap_item:
                        try:
                            rect = self.pixmap_item.boundingRect()
                            h = rect.height()
                            w = rect.width()
                            x = w / 2
                        except: pass
                    
                    # Fix label argument error by explicitly handling it
                    try:
                        self.midline_item = VerticalSeparatorLine(h, x, label="Midline")
                    except TypeError:
                        # Fallback for older definition without label
                        self.midline_item = VerticalSeparatorLine(h, x)
                        if hasattr(self.midline_item, "label"):
                            self.midline_item.label = "Midline"
                            
                    self.scene.addItem(self.midline_item)
                    self.midline_item.setZValue(50) 
            
                if self.midline_item:
                    self.midline_item.setVisible(True)
                    self.midline_item.setZValue(50) # Force on top
            except Exception as e:
                print(f"Error creating midline: {e}")
        else:
            try:
                if getattr(self, "midline_item", None):
                    self.midline_item.setVisible(False)
            except RuntimeError:
                self.midline_item = None
            except Exception:
                pass

    # toggle_spee_visibility removed as per user request


    def update_image_display(self):
        if not self.pixmap_item:
            return
        if self.original_image_np is None:
            return
        try:
            b = 0
            c = 100
            try:
                b = int(self.brightness_slider.value())
            except Exception:
                b = 0
            try:
                c = int(self.contrast_slider.value())
            except Exception:
                c = 100

            contrast = max(0.0, float(c) / 100.0)
            src = self.original_image_np
            img = src.astype(np.float32, copy=False)
            out = (img - 127.5) * contrast + 127.5 + float(b)
            out = np.clip(out, 0, 255).astype(np.uint8)

            if out.ndim == 2:
                h, w = out.shape
                qimg = QImage(out.data, w, h, w, QImage.Format.Format_Grayscale8).copy()
            else:
                h, w, ch = out.shape
                if ch == 3:
                    qimg = QImage(out.data, w, h, w * 3, QImage.Format.Format_RGB888).copy()
                elif ch == 4:
                    qimg = QImage(out.data, w, h, w * 4, QImage.Format.Format_RGBA8888).copy()
                else:
                    return

            self.pixmap_item.setPixmap(QPixmap.fromImage(qimg))
            try:
                br = None
                try:
                    br = self.pixmap_item.boundingRect()
                except Exception:
                    br = None
                if br is not None:
                    if bool(getattr(self, "manual_pan_enabled", False)):
                        try:
                            self._update_scene_rect_for_pan()
                        except Exception:
                            self.scene.setSceneRect(br)
                    else:
                        self.scene.setSceneRect(br)
                else:
                    self.scene.setSceneRect(self.scene.itemsBoundingRect())
            except Exception:
                pass
        except Exception:
            pass

    def _on_ai_slider_changed(self, *args):
        try:
            t = getattr(self, "_ai_timer", None)
            if t is None:
                return
            t.start(600)
        except Exception:
            pass

    def _on_ai_slider_timeout(self):
        try:
            if not getattr(self, "current_image_path", None):
                return
            self.analyze_image_with_ai(mode="full")
        except Exception:
            pass

    def assign_fdi_numbers(self, results):
        """
        Assigns FDI tooth numbers to detected bounding boxes based on their position.
        
        Optimized with NumPy for better performance and precision.
        
        Args:
            results (dict): Dictionary containing 'boxes', 'labels', and 'scores'.
            
        Returns:
            dict: Updated results with 'fdi' keys assigned to each detection.
        """
        boxes = results.get('boxes', [])
        labels = results.get('labels', [])
        scores = results.get('scores', [])
        statuses = results.get('statuses', [])
        bypass_grid_list = results.get('bypass_grid', [False] * len(boxes))
        notes = results.get('notes', [""] * len(boxes))
        last_updated = results.get('last_updated', [None] * len(boxes))

        try:
            print(f"[FDI-DEBUG] assign_fdi_numbers: incoming boxes={len(boxes)} labels={len(labels)} scores={len(scores)}")
        except Exception:
            pass
        
        # Validation: Check if boxes is empty or None
        if not boxes or len(boxes) == 0:
            try:
                print("[FDI-DEBUG] Early exit: no boxes")
            except Exception:
                pass
            return results

        try:
            n = int(len(boxes))
        except Exception:
            n = 0
        if n <= 0:
            try:
                print("[FDI-DEBUG] Early exit: n<=0 after len(boxes) cast")
            except Exception:
                pass
            return results

        if not isinstance(labels, list):
            labels = list(labels) if labels is not None else []
        if not isinstance(scores, list):
            scores = list(scores) if scores is not None else []
        if not isinstance(statuses, list):
            statuses = list(statuses) if statuses is not None else []
        if not isinstance(bypass_grid_list, list):
            bypass_grid_list = list(bypass_grid_list) if bypass_grid_list is not None else []
        if not isinstance(notes, list):
            notes = list(notes) if notes is not None else []
        if not isinstance(last_updated, list):
            last_updated = list(last_updated) if last_updated is not None else []

        if len(labels) < n:
            labels = list(labels) + ["Tooth"] * (n - len(labels))
        elif len(labels) > n:
            labels = list(labels)[:n]

        if len(scores) < n:
            scores = list(scores) + [0.0] * (n - len(scores))
        elif len(scores) > n:
            scores = list(scores)[:n]

        if len(statuses) < n:
            statuses = list(statuses) + ([[]] * (n - len(statuses)))
        elif len(statuses) > n:
            statuses = list(statuses)[:n]

        if len(bypass_grid_list) < n:
            bypass_grid_list = list(bypass_grid_list) + ([False] * (n - len(bypass_grid_list)))
        elif len(bypass_grid_list) > n:
            bypass_grid_list = list(bypass_grid_list)[:n]

        if len(notes) < n:
            notes = list(notes) + ([""] * (n - len(notes)))
        elif len(notes) > n:
            notes = list(notes)[:n]

        if len(last_updated) < n:
            last_updated = list(last_updated) + ([None] * (n - len(last_updated)))
        elif len(last_updated) > n:
            last_updated = list(last_updated)[:n]

        try:
            print(f"[FDI-DEBUG] After list normalization: boxes={len(boxes)} labels={len(labels)} scores={len(scores)} statuses={len(statuses)} bypass={len(bypass_grid_list)}")
        except Exception:
            pass

        # --- SCORE FILTERING ---
        # Βασικό φίλτρο για να αποφύγουμε "48 δόντια" από χαμηλά scores.
        # Δυναμικό όριο: ξεκινά από 0.35 αλλά χαμηλώνει σε 0.25 αν κρατάμε λίγα.
        primary_thr = 0.35
        fallback_thr = 0.25
        valid_indices = [i for i, s in enumerate(scores) if s >= primary_thr]
        try:
            print(f"[FDI-DEBUG] Score filter: threshold={primary_thr} keep={len(valid_indices)}/{len(scores)}")
        except Exception:
            pass
        if len(valid_indices) < min(24, len(scores)):
            valid_indices_fb = [i for i, s in enumerate(scores) if s >= fallback_thr]
            if len(valid_indices_fb) > len(valid_indices):
                valid_indices = valid_indices_fb
                try:
                    print(f"[FDI-DEBUG] Score filter fallback: threshold={fallback_thr} keep={len(valid_indices)}/{len(scores)}")
                except Exception:
                    pass
        if len(valid_indices) < len(boxes):
            boxes = [boxes[i] for i in valid_indices]
            labels = [labels[i] for i in valid_indices]
            scores = [scores[i] for i in valid_indices]
            statuses = [statuses[i] for i in valid_indices]
            bypass_grid_list = [bypass_grid_list[i] for i in valid_indices]
            notes = [notes[i] for i in valid_indices]
            last_updated = [last_updated[i] for i in valid_indices]
            try:
                print(f"[FDI-DEBUG] After score filter: boxes={len(boxes)}")
            except Exception:
                pass

        results['boxes'] = boxes
        results['labels'] = labels
        results['scores'] = scores
        results['statuses'] = statuses
        results['bypass_grid'] = bypass_grid_list
        results['notes'] = notes
        results['last_updated'] = last_updated
            
        # --- DEDUPLICATION ---
        # Robust NMS (Non-Maximum Suppression) to remove overlapping detections
        # We prefer:
        # 1. Higher confidence score
        # 2. More specific label (e.g. "Caries" > "Tooth") - handled by score usually
        
        def calculate_iou(box1, box2):
            x1 = max(box1[0], box2[0])
            y1 = max(box1[1], box2[1])
            x2 = min(box1[2], box2[2])
            y2 = min(box1[3], box2[3])
            
            inter_area = max(0, x2 - x1) * max(0, y2 - y1)
            box1_area = (box1[2] - box1[0]) * (box1[3] - box1[1])
            box2_area = (box2[2] - box2[0]) * (box2[3] - box2[1])
            
            union_area = box1_area + box2_area - inter_area
            if union_area == 0: return 0
            return inter_area / union_area

        def box_contains(outer, inner, threshold=0.85):
            x1 = max(outer[0], inner[0])
            y1 = max(outer[1], inner[1])
            x2 = min(outer[2], inner[2])
            y2 = min(outer[3], inner[3])
            
            inter_area = max(0, x2 - x1) * max(0, y2 - y1)
            inner_area = (inner[2] - inner[0]) * (inner[3] - inner[1])
            
            if inner_area == 0: return False
            return (inter_area / inner_area) > threshold

        # Sort indices by score descending
        sorted_indices = sorted(range(len(boxes)), key=lambda k: scores[k], reverse=True)
        keep_indices = []
        
        while sorted_indices:
            current = sorted_indices.pop(0)
            keep_indices.append(current)
            
            # Filter remaining
            next_indices = []
            for other in sorted_indices:
                iou = calculate_iou(boxes[current], boxes[other])
                is_contained = box_contains(boxes[current], boxes[other]) or box_contains(boxes[other], boxes[current])
                
                # If high overlap or containment, suppress the lower score one
                if iou > 0.45 or is_contained: # 0.45 is a safe threshold for teeth
                    # Merge logic: if suppress, maybe transfer status?
                    # For now, just suppress to avoid double counting.
                    # We could merge statuses here if needed.
                    continue
                next_indices.append(other)
            sorted_indices = next_indices
            
        # Re-sort by index to maintain relative order if that mattered, or just use filtered list
        keep_indices.sort()
        
        if len(keep_indices) < len(boxes):
            boxes = [boxes[i] for i in keep_indices]
            labels = [labels[i] for i in keep_indices]
            scores = [scores[i] for i in keep_indices]
            statuses = [statuses[i] for i in keep_indices]
            bypass_grid_list = [bypass_grid_list[i] for i in keep_indices]
            notes = [notes[i] for i in keep_indices]
            last_updated = [last_updated[i] for i in keep_indices]
            
            results['boxes'] = boxes
            results['labels'] = labels
            results['scores'] = scores
            results['statuses'] = statuses
            results['bypass_grid'] = bypass_grid_list
            results['notes'] = notes
            results['last_updated'] = last_updated

        # Ensure statuses exist
        if not statuses:
            statuses = [[] for _ in range(len(boxes))]
            try:
                print(f"[FDI-DEBUG] After NMS: keep_indices={len(keep_indices)}")
            except Exception:
                pass
            
        # Convert to numpy array for vectorized operations if not already
        boxes_np = np.array(boxes, dtype=np.float64)
        scores_np = np.array(scores, dtype=np.float64)
        
        # --- SIZE FILTERING ---
        img_width = 0
        img_height = 0
        if self.pixmap_item:
            rect = self.pixmap_item.boundingRect()
            img_width = rect.width()
            img_height = rect.height()
        
        if img_width > 0 and img_height > 0:
            aspect_ratio = img_width / img_height
            
            # Adaptive thresholds
            if aspect_ratio > 1.5: 
                max_w_ratio = 0.10
                max_h_ratio = 0.50
            else:
                max_w_ratio = 0.95 
                max_h_ratio = 0.95

            # Vectorized filtering
            widths = boxes_np[:, 2] - boxes_np[:, 0]
            heights = boxes_np[:, 3] - boxes_np[:, 1]
            
            # Validate coordinates (x2 > x1, y2 > y1)
            valid_coords = (widths > 0) & (heights > 0)
            
            # Filter by size and score
            size_mask = (widths <= (img_width * max_w_ratio)) & (heights <= (img_height * max_h_ratio))
            score_mask = scores_np >= 0.25 # Filter out low confidence noise
            
            final_mask = valid_coords & size_mask & score_mask

            # Protect bypassed items from size filtering
            bypass_mask = np.array(bypass_grid_list, dtype=bool)
            if len(bypass_mask) == len(final_mask):
                final_mask = final_mask | bypass_mask
            
            # Apply mask
            boxes_np = boxes_np[final_mask]
            # Convert back to list for consistency with other parts of app if needed, 
            # or keep managing indices. Here we filter the input lists.
            valid_indices = np.where(final_mask)[0]
            try:
                print(f"[FDI-DEBUG] Size/score mask: keep={len(valid_indices)}/{len(final_mask)}")
            except Exception:
                pass
            
            # Update lists
            boxes = [boxes[i] for i in valid_indices]
            labels = [labels[i] for i in valid_indices]
            scores = [scores[i] for i in valid_indices]
            statuses = [statuses[i] for i in valid_indices]
            bypass_grid_list = [bypass_grid_list[i] for i in valid_indices]
            notes = [notes[i] for i in valid_indices]
            last_updated = [last_updated[i] for i in valid_indices]
            
            # Update results
            results['boxes'] = boxes
            results['labels'] = labels
            results['scores'] = scores
            results['statuses'] = statuses
            results['bypass_grid'] = bypass_grid_list
            results['notes'] = notes
            results['last_updated'] = last_updated
            
            # Update numpy array for next steps
            boxes_np = boxes_np # Already filtered

        if len(boxes) == 0:
            try:
                print("[FDI-DEBUG] Early exit: no boxes after size/score filtering")
            except Exception:
                pass
            return results
            
        # --- CALCULATE CENTROIDS (Vectorized) ---
        # cx = (x1 + x2) / 2
        # cy = (y1 + y2) / 2
        centroids_x = (boxes_np[:, 0] + boxes_np[:, 2]) / 2.0
        centroids_y = (boxes_np[:, 1] + boxes_np[:, 3]) / 2.0
        
        _item_refs = results.get('_item_refs', [])
        
        # Create items structure efficiently
        items = []
        for i in range(len(boxes)):
            items.append({
                'box': boxes[i],
                'label': labels[i] if i < len(labels) else 'Tooth',
                'score': scores[i] if i < len(scores) else 0.0,
                'statuses': statuses[i] if i < len(statuses) else [],
                'cx': float(centroids_x[i]),
                'cy': float(centroids_y[i]),
                'index': i,
                'fdi': labels[i] if (i < len(bypass_grid_list) and bypass_grid_list[i] and i < len(labels) and str(labels[i]).isdigit() and len(str(labels[i])) == 2) else None,
                'bypass_grid': bypass_grid_list[i] if i < len(bypass_grid_list) else False,
                'notes': notes[i] if i < len(notes) else "",
                'last_updated': last_updated[i] if i < len(last_updated) else None,
                'item_ref': _item_refs[i] if i < len(_item_refs) else None
            })

        try:
            num_bypass = len([it for it in items if it.get('bypass_grid')])
            num_prefdi = len([it for it in items if isinstance(it.get('fdi'), str) and it.get('fdi').isdigit()])
            print(f"[FDI-DEBUG] Items built: total={len(items)} bypass={num_bypass} pre_fdi={num_prefdi}")
        except Exception:
            pass

        # --- GRID-BASED ASSIGNMENT (STRICT) ---
        # DISABLED BY DEFAULT TO ENFORCE ANATOMICAL RULES (USER REQUEST)
        # if self.grid_active:
        #      if self.assign_fdi_from_grid_cells(items):
        #          results['boxes'] = [item['box'] for item in items]
        #          results['labels'] = [item['label'] for item in items]
        #          results['scores'] = [item['score'] for item in items]
        #          results['fdi'] = [item['fdi'] for item in items]
        #          results['statuses'] = [item.get('statuses', []) for item in items]
        #          results['notes'] = [item.get('notes', "") for item in items]
        #          results['last_updated'] = [item.get('last_updated', None) for item in items]
        #          results['bypass_grid'] = [item.get('bypass_grid', False) for item in items]
        #          results['_item_refs'] = [item.get('item_ref', None) for item in items]
        #          
        #          return results

        # --- FDI NUMBERING ---
        
        # 1. Determine Reference Lines and Intersection Point (Center of Symmetry)
        mid_x = img_width / 2.0 if img_width > 0 else 0.0
        
        # --- SYNC MIDLINE WITH CALIBRATION (Step 4) ---
        # As requested: The Blue/Vertical line must coincide with the Magenta Calibration Line.
        # If the Magenta line exists, it overrides everything for X-center.
        calib_y_line = getattr(self, "calib_line_y", None)
        if self._is_scene_item_alive(calib_y_line) and calib_y_line.isVisible():
             # The vertical calibration line defines the absolute center axis
             try:
                 # Manual Addition Logic (Safer)
                 base_pos = calib_y_line.pos()
                 h1_pos = calib_y_line.h1.pos()
                 mid_x = (base_pos + h1_pos).x()
             except:
                 try:
                     p1 = calib_y_line.mapToScene(calib_y_line.h1.pos())
                     mid_x = p1.x()
                 except: pass
        
        mid_y = img_height / 2.0 if img_height > 0 else 0.0
        
        # Resolve Active Curve Item (PRIORITIZE MANUAL TOOL)
        # The user manually adjusts 'jaw_separator_line'. This MUST take precedence.
        manual_curve = getattr(self, "jaw_separator_line", None)
        active_curve = None
        
        if self._is_scene_item_alive(manual_curve) and manual_curve.isVisible():
            active_curve = manual_curve
            # print("Using Manual Jaw Separator")
        else:
            active_curve = manual_curve # Fallback (Spee removed)

            
        has_jaw_line = self._is_scene_item_alive(active_curve)
        
        # Resolve Active Vertical Line (PRIORITIZE MANUAL TOOL)
        manual_vert = getattr(self, "midline_item", None)
        active_vert = None
        
        if self._is_scene_item_alive(manual_vert) and manual_vert.isVisible():
            active_vert = manual_vert
        else:
             legacy_vert = getattr(self, "vertical_separator_line", None)
             if self._is_scene_item_alive(legacy_vert) and legacy_vert.isVisible():
                 active_vert = legacy_vert
             else:
                 active_vert = manual_vert
             
        has_vert_line = self._is_scene_item_alive(active_vert)
        
        # --- ZONING LOGIC INTEGRATION (Zones A, B, C) ---
        z1_limit = 0.0 # Bottom of Zone A (Sinuses)
        z2_split = None # Split between Zone B (Upper Jaw) and C (Lower Jaw)
        
        try:
            zl1 = getattr(self, "zone_line_1", None)
            if self._is_scene_item_alive(zl1):
                z1_limit = float(zl1.y())
                
            zl2 = getattr(self, "zone_line_2", None)
            if self._is_scene_item_alive(zl2):
                z2_split = float(zl2.y())
        except: pass

        # Calculate Intersection Point precisely
        if has_vert_line or self._get_vertical_split_x() != 0:
            mid_x = self._get_vertical_split_x()
            
        if has_jaw_line:
            # If we have a curve, the "center Y" is the Y of the curve at mid_x
            try:
                mid_y = active_curve.get_y_at_x(mid_x)
            except:
                pass # Keep default mid_y
        elif z2_split is not None:
             # Fallback to Zone Line 2 (Manual Straight Split)
             mid_y = z2_split
        elif len(items) > 0:
             # Fallback to centroid Y if no line
             # Use K-Means (K=2) to robustly separate Upper vs Lower jaws
             # This handles imbalanced counts (e.g. 14 lower vs 2 upper) much better than simple Mean.
             try:
                 ys = sorted([it['cy'] for it in items])
                 if len(ys) >= 2:
                     # Simple 1D K-Means with 2 clusters
                     # Initialize centroids at min (Upper) and max (Lower)
                     c1 = ys[0]
                     c2 = ys[-1]
                     
                     for _ in range(5): # 5 iterations is plenty for 1D
                         cluster1 = [y for y in ys if abs(y - c1) <= abs(y - c2)]
                         cluster2 = [y for y in ys if abs(y - c1) > abs(y - c2)]
                         
                         if not cluster1 or not cluster2: break
                         
                         c1 = sum(cluster1) / len(cluster1)
                         c2 = sum(cluster2) / len(cluster2)
                     
                     # Split point is midpoint between final centroids
                     mid_y = (c1 + c2) / 2.0
                     # print(f"Robust Y-Split: {mid_y:.1f} (Upper: {c1:.1f}, Lower: {c2:.1f})")
                 else:
                     mid_y = np.mean(centroids_y)
             except Exception:
                 mid_y = np.mean(centroids_y)

        # Fallback for X if no line but items exist
        if not has_vert_line and len(items) > 0:
             try:
                 # Use Median X to be robust against outliers/imbalance
                 mid_x = float(np.median(centroids_x))
                 # Sanity Check: If Median is too far off center (>15%), force Image Center
                 # This prevents "Left Side Only" scans from shifting the midline too much.
                 img_center_x = img_width / 2.0
                 if abs(mid_x - img_center_x) > (img_width * 0.15):
                     mid_x = img_center_x
             except Exception:
                 mid_x = np.mean(centroids_x)
        # REMOVED "Smart Override" that forced mid_x to centroid median if out of bounds.
        # If the user sets a manual line, it MUST be respected even if it seems "wrong" (e.g. edentulous side).


        # 2. Split into Quadrants using the Intersection Point
        # Log critical decision boundaries
        
        # --- ROBUST CURVE DETECTION (LOCAL GAP) ---
        # If no manual line exists, we compute a dynamic separation curve.
        # This handles the "Smile Curve" where incisors are higher than molars.
        dynamic_curve_points = []
        if not has_jaw_line and z2_split is None and len(items) > 4:
            try:
                # 1. Sort items by X
                sorted_by_x = sorted(items, key=lambda i: i['cx'])
                min_x = sorted_by_x[0]['cx']
                max_x = sorted_by_x[-1]['cx']
                
                # 2. Divide into vertical strips (bins)
                # 10 bins is usually enough for a panoramic
                num_bins = 12
                bin_width = (max_x - min_x) / num_bins
                
                for b in range(num_bins):
                    bx_start = min_x + b * bin_width
                    bx_end = bx_start + bin_width
                    bx_center = (bx_start + bx_end) / 2.0
                    
                    # Get items in this bin
                    bin_items = [it for it in items if bx_start <= it['cx'] < bx_end]
                    
                    # We need at least 2 items to find a gap (Upper vs Lower)
                    if len(bin_items) >= 2:
                        # Sort by Y
                        ys = sorted([it['cy'] for it in bin_items])
                        
                        # Find largest gap
                        max_gap = 0
                        gap_y = -1
                        
                        # Heuristic: The gap between Upper and Lower is usually the largest vertical space.
                        for i in range(len(ys) - 1):
                            diff = ys[i+1] - ys[i]
                            if diff > max_gap:
                                max_gap = diff
                                gap_y = (ys[i] + ys[i+1]) / 2.0
                        
                        # Heuristic: The gap must be "significant" (> 30px)
                        # And roughly near the global mid_y (within reasonable bounds)
                        if max_gap > 30 and abs(gap_y - mid_y) < (img_height * 0.35): # Relaxed from 0.25 to 0.35
                            dynamic_curve_points.append((bx_center, gap_y))
            except Exception:
                pass
        
        # --- SMOOTHING DYNAMIC CURVE ---
        # The raw points might be jagged. We apply a simple moving average.
        if len(dynamic_curve_points) > 3:
            try:
                # Sort by X
                dynamic_curve_points.sort(key=lambda p: p[0])
                
                smoothed_points = []
                window_size = 3
                for i in range(len(dynamic_curve_points)):
                    # Get neighbors
                    start_idx = max(0, i - window_size // 2)
                    end_idx = min(len(dynamic_curve_points), i + window_size // 2 + 1)
                    neighbors = dynamic_curve_points[start_idx:end_idx]
                    
                    # Average Y (X stays same)
                    avg_y = sum(p[1] for p in neighbors) / len(neighbors)
                    smoothed_points.append((dynamic_curve_points[i][0], avg_y))
                
                dynamic_curve_points = smoothed_points
            except Exception:
                pass # Fallback to raw points
        
        try:
            if hasattr(self, "_trace_log"):
                self._trace_log("fdi_boundaries", {
                    "mid_x": float(mid_x),
                    "mid_y": float(mid_y),
                    "z2_split": float(z2_split) if z2_split is not None else None,
                    "has_jaw_line": bool(has_jaw_line),
                    "has_vert_line": bool(has_vert_line),
                    "dynamic_curve_pts": len(dynamic_curve_points)
                })
        except: pass

        q1_items = [] # Image Upper Left
        q2_items = [] # Image Upper Right
        q3_items = [] # Image Lower Right
        q4_items = [] # Image Lower Left
        spee_poly = None
        if has_jaw_line:
            try:
                spee_poly = self._spee_lower_polygon()
            except Exception:
                spee_poly = None
        
        # --- ROBUST QUADRANT SPLITTING (Respect Vertical Separator Strictly) ---
        # The Vertical Separator (mid_x) is the absolute truth for left/right.
        # The Jaw Separator (curve or mid_y) is the absolute truth for up/down.
        
        # 0. Get Mandible Width Constraints (Red Line) - STRICT LIMITS
        # User sets this line from condyle to condyle. Anything outside is noise.
        min_valid_x = -float('inf')
        max_valid_x = float('inf')
        
        c_line = getattr(self, "calib_line_x", None)
        if self._is_scene_item_alive(c_line) and c_line.isVisible():
             try:
                 # Use manual addition assuming no rotation/scale
                 base_pos = c_line.pos()
                 h1_pos = c_line.h1.pos()
                 h2_pos = c_line.h2.pos()
                 p1 = base_pos + h1_pos
                 p2 = base_pos + h2_pos
                 
                 min_valid_x = min(p1.x(), p2.x())
                 max_valid_x = max(p1.x(), p2.x())
                 # Tolerance - Increased to avoid accidental clipping of molars
                 min_valid_x -= 150 
                 max_valid_x += 150
             except: 
                 try:
                     p1 = c_line.mapToScene(c_line.h1.pos())
                     p2 = c_line.mapToScene(c_line.h2.pos())
                     min_valid_x = min(p1.x(), p2.x())
                     max_valid_x = max(p1.x(), p2.x())
                     min_valid_x -= 20
                     max_valid_x += 20
                 except: pass
        
        # Zone Filtering: Calculate a "Distance from Curve" for each item.
        # If an item is excessively far from the curve (e.g., > 1/3 image height), treat it as noise.
        # We also enforce strict boundaries: Upper items MUST be above the curve, Lower items below.
        
        # Configuration Constants (Local Copy)
        POS_INCISOR_LIMIT = 0.30
        POS_MOLAR_START = 0.60
        
        # Fix for "max_dist_from_curve not defined" error
        max_dist_from_curve = img_height * 0.35 if img_height > 0 else 350.0
        
        # Determine Scale for Dimensions
        sx = getattr(self, 'pixel_to_mm_scale_x', 1.0)
        if sx is None or sx <= 0: sx = 1.0
        sy = getattr(self, 'pixel_to_mm_scale_y', 1.0)
        if sy is None or sy <= 0: sy = 1.0

        # Global safety limits for Upper/Lower zones (used in per-item logic and debug viz)
        SAFE_UPPER_LIMIT = img_height * 0.48
        SAFE_LOWER_LIMIT = img_height * 0.52

        filtered_items = []
        rejected_items = []

        for item in items:
            cx = item['cx']
            cy = item['cy']
            
            # Bypass Check
            is_manual = bool(item.get("bypass_grid", False))

            # Determine "Ideal Y" for this X based on the curve
            curve_y_at_x = mid_y
            if has_jaw_line:
                try:
                    curve_y_at_x = active_curve.get_y_at_x(cx)
                except:
                    pass

            # --- DIMENSION & SIZE ENFORCEMENT ---
            if not is_manual:
                # As requested: "Dimensions of teeth are not calculated"
                # We must reject noise (tiny items) and non-tooth shapes.
                w_px = item['box'][2] - item['box'][0]
                h_px = item['box'][3] - item['box'][1]
                w_mm = w_px * sx
                h_mm = h_px * sy
                
                # 1. Minimum Size Check (unless it's a root remnant or specific small class)
                # Standard tooth is > 5mm wide, > 8mm high.
                # We use conservative limits: 1.5mm width, 3.0mm height (Relaxed for small teeth/roots).
                if sx != 1.0 and (w_mm < 1.5 or h_mm < 3.0):
                    try:
                        self.results_text_edit.append(f"⚠️ Απορρίφθηκε θόρυβος (Μικρό μέγεθος): {w_mm:.1f}x{h_mm:.1f}mm")
                    except: pass
                    # rejected_items.append(item) # DISABLED STRICT SIZE REJECTION
                    # continue 
                    pass

                # 2. Aspect Ratio Check
                # Teeth are generally vertical rectangles (ratio < 1.0) or squares.
                # Very flat items (ratio > 2.0) are usually bone or noise.
                # Very thin items (ratio < 0.2) are artifacts.
                ratio = w_px / h_px if h_px > 0 else 0
                if ratio > 3.0 or ratio < 0.15: # Relaxed from 2.5/0.2
                     try:
                        self.results_text_edit.append(f"⚠️ Απορρίφθηκε θόρυβος (Λάθος αναλογίες): Ratio {ratio:.2f}")
                     except: pass
                     # rejected_items.append(item) # DISABLED STRICT RATIO REJECTION
                     # continue
                     pass

                # --- MANDIBLE WIDTH CHECK (Red Line) ---
                if cx < (min_valid_x - 100) or cx > (max_valid_x + 100):
                     try:
                        self.results_text_edit.append(f"⚠️ Απορρίφθηκε ανίχνευση εκτός εύρους γνάθου (X={cx:.1f})")
                     except: pass
                     rejected_items.append(item)
                
                # Calculate distance from the curve (vertical distance)
                dist_y = abs(cy - curve_y_at_x)
                
                # --- ZONE A CHECK (Sinuses) ---
                # Strict Sinus Protection: Check if tooth TOP (y_min) is above the limit with buffer
                y_min = item['box'][1]
                if z1_limit > 0 and y_min < (z1_limit - 150.0): # Relaxed from +5.0 to -150.0 (Allow overlap)
                     # Strictly above Sinus Line -> Reject
                     try:
                        self.results_text_edit.append(f"⚠️ Απορρίφθηκε ανίχνευση στη Ζώνη Α (Ιγμόρεια) Y={y_min:.1f} < {z1_limit:.1f}")
                     except: pass
                     # rejected_items.append(item) # DISABLED STRICT SINUS REJECTION
                     # continue
                     pass
                
                # Check if it's "too far" (out of zone)
                # Relaxed from 0.35 to 0.50 (Half image height)
                relaxed_max_dist = max(max_dist_from_curve, img_height * 0.50)
                if dist_y > relaxed_max_dist:
                    try:
                        self.results_text_edit.append(f"⚠️ Απορρίφθηκε ανίχνευση εκτός ζώνης (Y-Dist: {dist_y:.1f}px > {relaxed_max_dist:.1f})")
                    except: pass
                    rejected_items.append(item)
            
            # --- Y-OUTLIER DETECTION (Vertical Stability) ---
            # Reject teeth that are significantly vertically displaced compared to their quadrant neighbors.
            # This helps filter out roots or bone artifacts that are detected as teeth.
            # We delay this check until we form the quadrants, or we do a simple pre-check here.
            # Since we don't have quadrant info yet, we'll do it inside the simple assignment function.
            
            # Determine Upper/Lower Priority:
            # 1. Zone Line 2 (USER MANUAL INPUT) - Absolute Authority if present
            # 2. Strict Geometric Safety Zones - Absolute Authority for clear cases
            # 3. Dynamic Curve (Yellow Dots) - High Priority for Automated Separation
            # 4. Old Manual/Automated Curve (Red Line) - Fallback
            
            is_upper = True
            
            if z2_split is not None:
                 try:
                     y1_box = float(item["box"][1])
                     y2_box = float(item["box"][3])
                 except Exception:
                     y1_box = cy
                     y2_box = cy
                 h_box = max(1.0, float(y2_box - y1_box))
                 try:
                     upper_len = 0.0
                     lower_len = 0.0
                     if y1_box < float(z2_split):
                         upper_len = max(0.0, min(float(z2_split), y2_box) - y1_box)
                     if y2_box > float(z2_split):
                         lower_len = max(0.0, y2_box - max(float(z2_split), y1_box))
                     upper_frac = upper_len / h_box
                     lower_frac = lower_len / h_box
                 except Exception:
                     upper_frac = 0.0
                     lower_frac = 0.0
                 
                 if lower_frac > upper_frac:
                     is_upper = False
                 elif upper_frac > lower_frac:
                     is_upper = True
                 else:
                     is_upper = cy < z2_split
            elif cy < SAFE_UPPER_LIMIT:
                 # Strictly in Upper Zone
                 is_upper = True
            elif cy > SAFE_LOWER_LIMIT:
                 # Strictly in Lower Zone
                 is_upper = False
            elif len(dynamic_curve_points) > 0:
                 # PRIORITY: Use Dynamic Curve from Local Gap Detection
                 # Only use this if we are in the ambiguous middle zone
                 split_y = mid_y # Fallback
                 
                 # Sort points by X just in case
                 pts = sorted(dynamic_curve_points, key=lambda p: p[0])
                 
                 if cx <= pts[0][0]:
                     split_y = pts[0][1]
                 elif cx >= pts[-1][0]:
                     split_y = pts[-1][1]
                 else:
                     # Interpolate
                     for i in range(len(pts) - 1):
                         p1 = pts[i]
                         p2 = pts[i+1]
                         if p1[0] <= cx <= p2[0]:
                             t = (cx - p1[0]) / (p2[0] - p1[0])
                             split_y = p1[1] + t * (p2[1] - p1[1])
                             break
                 
                 # Additional Safety: Split Y must be reasonable (35-65%)
                 if split_y < (img_height * 0.35): split_y = img_height * 0.35
                 if split_y > (img_height * 0.65): split_y = img_height * 0.65
                 
                 is_upper = cy < split_y
            elif has_jaw_line:
                 # Fallback to Old Curve Logic (Red Line)
                 try:
                     if spee_poly is not None:
                         is_upper = not spee_poly.containsPoint(QPointF(float(cx), float(cy)), Qt.FillRule.OddEvenFill)
                     else:
                         is_upper = cy < curve_y_at_x
                 except:
                     is_upper = cy < mid_y
            else:
                 is_upper = cy < mid_y
                
            # Determine Left/Right (Patient's Perspective) STRICTLY
            is_image_left = cx < mid_x
            
            # Distance calculations
            # Use calibration scale if available, otherwise 1.0 (pixels)
            sx = getattr(self, 'pixel_to_mm_scale_x', 1.0)
            if sx is None or sx <= 0: sx = 1.0
            
            sy = getattr(self, 'pixel_to_mm_scale_y', 1.0)
            if sy is None or sy <= 0: sy = 1.0
            
            # Distance from midline (X) and curve (Y)
            # IMPORTANT: We use 'curve_y_at_x' as the reference Y (occlusal plane level at this X)
            # If no curve, we use mid_y (image center Y)
            ref_y = curve_y_at_x if has_jaw_line else mid_y
            
            dx = cx - mid_x
            dy = cy - ref_y
            
            item['dist_center'] = np.sqrt((dx*sx)**2 + (dy*sy)**2)
            item['dist_x_center'] = abs(dx * sx) # Mesial-Distal distance from midline
            item['dist_y_occlusal'] = abs(dy * sy) # Vertical distance from occlusal plane
            
            # STRICT ASSIGNMENT
            if is_upper:
                if is_image_left: q1_items.append(item) # Q1 (11-18)
                else: q2_items.append(item) # Q2 (21-28)
            else:
                if is_image_left: q4_items.append(item) # Q4 (41-48)
                else: q3_items.append(item) # Q3 (31-38)
            
            filtered_items.append(item)

        # Log filtering results if any dropped
        if rejected_items:
             print(f"Filtered {len(rejected_items)} items out of zone.")

        # --- DEBUG VISUALIZATION (User Request: "Show Cells/Logic") ---
        # Draw Safety Zones and Decision Lines to explain why teeth are assigned Upper/Lower.
        try:
            # 1. Safety Zones (Cyan Dashed Lines)
            # Explain: "Anything above Top Line is Upper, anything below Bottom Line is Lower"
            pen_safe = QPen(QColor(0, 255, 255))
            pen_safe.setStyle(Qt.PenStyle.DashLine)
            pen_safe.setWidth(2)
            
            # Upper Limit
            line_u = QGraphicsLineItem(0, SAFE_UPPER_LIMIT, img_width, SAFE_UPPER_LIMIT)
            line_u.setPen(pen_safe)
            line_u.setZValue(999) # On Top
            self.scene.addItem(line_u) # Uncomment to show line
            
            # Lower Limit
            line_l = QGraphicsLineItem(0, SAFE_LOWER_LIMIT, img_width, SAFE_LOWER_LIMIT)
            line_l.setPen(pen_safe)
            line_l.setZValue(999)
            self.scene.addItem(line_l) # Uncomment to show line
            
            # 2. Dynamic Curve (Yellow Points)
            # Explain: "This is the curve the AI found to separate jaws"
            if len(dynamic_curve_points) > 0:
                pen_curve = QPen(QColor(255, 255, 0))
                brush_curve = QBrush(QColor(255, 255, 0))
                for (px, py) in dynamic_curve_points:
                    ell = QGraphicsEllipseItem(px-5, py-5, 10, 10)
                    ell.setPen(pen_curve)
                    ell.setBrush(brush_curve)
                    ell.setZValue(1000)
                    self.scene.addItem(ell) # Uncomment to show points

            # 3. Raw Boxes (Gray Rectangles for Rejected/Filtered)
            # This shows what the model "saw" before we filtered it.
            # Helps identify "Ghost" detections or "Noise".
            pen_raw = QPen(QColor(128, 128, 128))
            pen_raw.setStyle(Qt.PenStyle.DotLine)
            for r_item in rejected_items:
                bx = r_item['box']
                rect = QGraphicsRectItem(bx[0], bx[1], bx[2]-bx[0], bx[3]-bx[1])
                rect.setPen(pen_raw)
                rect.setZValue(900)
                # self.scene.addItem(rect) # Uncomment to show rejected items
                
        except Exception as e:
            print(f"Debug Viz Error: {e}")

        # 3. Anatomical Vector Progression (Q1 Specific Implementation)
        # As requested: 
        # - Start from Intersection of Midline and Zone Line 2 (Green Dashed).
        # - Move 2-3mm Left and 5mm Up to find center of 11.
        # - Progress distally based on anatomical widths.
        # - Generate missing teeth if gaps exist.

        generated_items = []

        def assign_quadrant_template_matching(q_items, quadrant_prefix, reverse_sort: bool, direction_right: bool):
            try:
                q_num = int(str(quadrant_prefix or "1").strip())
            except Exception:
                q_num = 1
            q_key = f"q{q_num}"

            try:
                valid_items = [it for it in (q_items or []) if not bool(it.get("bypass_grid"))]
                bypassed_items = [it for it in (q_items or []) if bool(it.get("bypass_grid"))]
            except Exception:
                valid_items = list(q_items or [])
                bypassed_items = []
            try:
                valid_items.sort(key=lambda x: float(x.get("cx", 0.0) or 0.0), reverse=bool(reverse_sort))
            except Exception:
                pass

            processed_items = []

            tpl = None
            try:
                tpl = getattr(self, "_q1_spacing_template", None) if q_key == "q1" else None
            except Exception:
                tpl = None
            if tpl is None:
                try:
                    ts = getattr(self, "_tooth_spacing", None)
                    if isinstance(ts, dict):
                        tpl = ts.get(q_key)
                except Exception:
                    tpl = None

            deltas = None
            start_offset = None
            cxs_tpl = None
            ys_tpl = None
            try:
                if isinstance(tpl, dict) and isinstance(tpl.get("deltas_px"), list) and len(tpl.get("deltas_px")) == 7:
                    deltas = [float(x) for x in tpl.get("deltas_px")]
                    start_offset = float(tpl.get("start_offset_px") or 0.0)
                    cxs_raw = tpl.get("cxs_px")
                    if isinstance(cxs_raw, list) and len(cxs_raw) == 8:
                        cxs_tpl = [float(x) for x in cxs_raw]
                    ys_raw = tpl.get("ys_px")
                    if isinstance(ys_raw, list) and len(ys_raw) == 8:
                        ys_tpl = [float(y) for y in ys_raw]
            except Exception:
                deltas = None
                start_offset = None
                cxs_tpl = None
                ys_tpl = None

            if not deltas:
                if len(valid_items) >= 2:
                    diffs = []
                    for a, b in zip(valid_items[:-1], valid_items[1:]):
                        try:
                            dx = float(b["cx"] - a["cx"]) if bool(direction_right) else float(a["cx"] - b["cx"])
                        except Exception:
                            dx = 0.0
                        if dx > 0:
                            diffs.append(dx)
                    base = float(np.median(np.array(diffs, dtype=np.float64))) if diffs else 60.0
                else:
                    base = 60.0
                deltas = [float(base)] * 7
                start_offset = None

            # GRID ANCHORING FIX:
            # Problem: The original code anchored the grid to the FIRST detected tooth.
            # If the central incisor (#1) was missing/undetected, the grid shifted, 
            # causing the Lateral Incisor (#2) to be labeled as #1.
            # Solution: Anchor strictly to the Midline.
            # The first tooth center is typically at ~0.5 * width_of_tooth from midline.
            # Avg Central Incisor width ~9mm. Center ~4.5mm.
            
            if not (start_offset and start_offset > 0):
                # Calculate default offset based on anatomy (Midline Anchor)
                sx_local = getattr(self, 'pixel_to_mm_scale_x', 1.0) or 1.0
                if sx_local > 0.001 and sx_local != 1.0:
                    # 4.5mm from midline
                    start_offset = 4.5 / sx_local
                else:
                    # Fallback pixels (approx 4% of image width or fixed)
                    # Assuming typical 2000px image, 4.5mm is ~40-50px?
                    # Better to use the 'base' delta calculated earlier
                    if deltas and len(deltas) > 0:
                        start_offset = deltas[0] * 0.5
                    else:
                        start_offset = 35.0 # Conservative default

            # OLD BROKEN LOGIC (Commented out)
            # if not (start_offset and start_offset > 0):
            #    if valid_items:
            #        ... anchor to valid_items[0] ...


            expected = None
            if isinstance(cxs_tpl, list) and len(cxs_tpl) == 8:
                expected = [float(x) for x in cxs_tpl]
            else:
                expected = []
                cx0 = float(mid_x) + float(start_offset) if bool(direction_right) else float(mid_x) - float(start_offset)
                for i in range(8):
                    expected.append(float(cx0))
                    if i < 7:
                        cx0 = (float(cx0) + float(deltas[i])) if bool(direction_right) else (float(cx0) - float(deltas[i]))

            ref_y = float(np.median(np.array([it["cy"] for it in valid_items], dtype=np.float64))) if valid_items else float(mid_y)
            widths = [float(it["box"][2] - it["box"][0]) for it in valid_items] if valid_items else []
            heights = [float(it["box"][3] - it["box"][1]) for it in valid_items] if valid_items else []
            w_med = float(np.median(np.array(widths, dtype=np.float64))) if widths else 40.0
            h_med = float(np.median(np.array(heights, dtype=np.float64))) if heights else 90.0

            use_tpl = bool(isinstance(cxs_tpl, list) and len(cxs_tpl) == 8 and isinstance(ys_tpl, list) and len(ys_tpl) == 8)
            can_generate = bool(use_tpl)

            for i in range(8):
                fdi = str(int(q_num * 10 + (i + 1)))
                exp_cx = expected[i]
                exp_cy = float(ys_tpl[i]) if isinstance(ys_tpl, list) and len(ys_tpl) == 8 else float(ref_y)
                base_dx = float(deltas[i - 1] if i > 0 else deltas[0])
                tol = float(max(40.0, min(220.0, base_dx * 0.75)))

                best = None
                best_dist = 1e18
                for it in valid_items:
                    if it.get("assigned"):
                        continue
                    dx = abs(float(it["cx"]) - float(exp_cx))
                    if dx > tol:
                        continue
                    dy = abs(float(it["cy"]) - float(exp_cy))
                    # Strict Anti-ZigZag (Vertical Tolerance)
                    # Memory says 45px. We use max(45, h_med * 0.6) to be safe but stricter than 2.5x
                    max_v_tol = max(45.0, float(h_med) * 0.6)
                    if dy > max_v_tol:
                        continue
                    if dx < best_dist:
                        best = it
                        best_dist = dx

                if best is not None:
                    best["fdi"] = fdi
                    best["assigned"] = True
                    if False and use_tpl:
                        try:
                            dx = float(exp_cx) - float(best.get("cx"))
                            dy = float(exp_cy) - float(best.get("cy"))
                            bx1, by1, bx2, by2 = best.get("box")
                            best["box"] = [float(bx1) + dx, float(by1) + dy, float(bx2) + dx, float(by2) + dy]
                            best["cx"] = float(exp_cx)
                            best["cy"] = float(exp_cy)
                        except Exception:
                            pass
                elif can_generate and False:
                    x1 = float(exp_cx) - (w_med / 2.0)
                    x2 = float(exp_cx) + (w_med / 2.0)
                    y1 = float(exp_cy) - (h_med / 2.0)
                    y2 = float(exp_cy) + (h_med / 2.0)
                    new_item = {
                        "box": [x1, y1, x2, y2],
                        "label": "Tooth",
                        "score": 0.0,
                        "fdi": fdi,
                        "statuses": ["Missing"],
                        "notes": "Spacing Gap",
                        "generated": True,
                        "cx": float(exp_cx),
                        "cy": float(exp_cy),
                        "assigned": True,
                    }
                    generated_items.append(new_item)

            try:
                assigned_count = sum(1 for it in valid_items if bool(it.get("assigned")))
            except Exception:
                assigned_count = 0
            total_valid = len(valid_items)
            try:
                coverage = float(assigned_count) / float(total_valid) if total_valid > 0 else 1.0
            except Exception:
                coverage = 1.0

            try:
                ordered = list(valid_items)
            except Exception:
                ordered = valid_items

            for idx, it in enumerate(ordered):
                if bool(it.get("assigned")):
                    processed_items.append(it)
                    continue
                if coverage < 0.3 and idx < 8:
                    try:
                        it["fdi"] = f"{q_num}{idx+1}"
                    except Exception:
                        it["fdi"] = f"{q_num}1"
                    it["assigned"] = True
                    processed_items.append(it)
                else:
                    if not it.get("fdi"):
                        it["fdi"] = "?"
                    processed_items.append(it)

            if bypassed_items:
                processed_items.extend(bypassed_items)

            return processed_items or []

        # CLEANUP: Remove assign_quadrant_simple as it's no longer used for Q1 and others are disabled.
        # But we keep it in case we re-enable others later?
        # User said "clean code from old calculations".
        # So let's comment it out or remove it to avoid confusion.
        
        # def assign_quadrant_simple... REMOVED

        # Grid assignment logic removed
        did_grid_assign = False
        if False:
             pass
        
        if not did_grid_assign:
            q1_items[:] = assign_quadrant_template_matching(q1_items, "1", reverse_sort=True, direction_right=False) or []
            q2_items[:] = assign_quadrant_template_matching(q2_items, "2", reverse_sort=False, direction_right=True) or []
            q3_items[:] = assign_quadrant_template_matching(q3_items, "3", reverse_sort=False, direction_right=True) or []
            q4_items[:] = assign_quadrant_template_matching(q4_items, "4", reverse_sort=True, direction_right=False) or []
            
            # Merge generated items
            if generated_items:
                max_idx = max([it.get('index', -1) for it in items]) if items else -1
                for i, item in enumerate(generated_items):
                    item['index'] = max_idx + 1 + i
                    item['item_ref'] = None
                items.extend(generated_items)
            
        # Fallback: Use label if FDI is unknown but label is a valid number
        valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
        
        # 4. Strict Reassembly (FILTERING OUT NON-ASSIGNED ITEMS)
        # To avoid "Garbage" from other quadrants leaking through, we strictly rebuild the list.
        # We only keep items that were explicitly assigned an FDI in the quadrant steps.
        
        final_items = []
        
        # Helper to collect from list
        def collect_valid(source_list):
            for item in source_list:
                # STRICT FILTER: Only keep items with valid FDI numbers or generated missing teeth.
                # This fixes the issue of "46 detected teeth" by removing noise/unassigned items.
                fdi = str(item.get('fdi') or "")
                
                # PRESERVE BYPASSED ITEMS (Manual Corrections)
                if item.get("bypass_grid"):
                    final_items.append(item)
                    continue

                if fdi and fdi != "?" and fdi.isdigit() and len(fdi) == 2:
                    final_items.append(item)
                elif item.get('generated'):
                    final_items.append(item)
        
        collect_valid(q1_items)
        collect_valid(q2_items)
        collect_valid(q3_items)
        collect_valid(q4_items)
        
        # Also include generated items if they weren't in the lists (they should be)
        # Check for duplicates?
        # My previous code extended `items` with `generated_items` at the end.
        # But `generated_items` were already appended to `q1_items` inside the function!
        # So we don't need to merge them again.
        
        items = final_items

        # Fallback: REMOVED (Strict Mode)
        # valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
        # for item in items: ...
        
        # Reconstruct results - FULL RECONSTRUCTION
        items.sort(key=lambda x: x.get('index', 9999))
        
        # 5. Type Correction (Incisor vs Molar based on Zone AND FDI)
        for item in items:
            lbl = str(item.get('label') or "Tooth")
            fdi = str(item.get('fdi') or "?")
            
            # Ensure 'Missing' label is reflected in statuses for visual feedback
            if "missing" in lbl.lower() or "edentulous" in lbl.lower() or "ελλείπ" in lbl.lower():
                st = item.get('statuses', [])
                if not any("ελλείπ" in str(s).lower() or "missing" in str(s).lower() for s in st):
                    if isinstance(st, list):
                        st.append("Ελλείπον")
                    else:
                        item['statuses'] = ["Ελλείπον"]
            
            # Use calculated distance from midline
            dist_x = item.get('dist_x_center', 0.0)
            
            # Heuristic Zones (if scale is valid)
            sx = getattr(self, 'pixel_to_mm_scale_x', 1.0)
            has_scale = (sx is not None and sx != 1.0)
            
            is_molar_zone = False
            is_incisor_zone = False
            
            if has_scale:
                 # Strict mm-based zones
                 # Incisors (8.5+6.5=15) + Canine (7.5) ~ 22.5mm
                 if dist_x < 22.0: is_incisor_zone = True 
                 elif dist_x > 28.0: is_molar_zone = True
            
            if fdi.isdigit() and len(fdi) == 2:
                q = int(fdi[0])
                n = int(fdi[1])
                is_molar_fdi = n in [4, 5, 6, 7, 8]
                is_incisor_fdi = n in [1, 2, 3]
                
                # Check current label vs FDI position
                is_molar_lbl = "molar" in lbl.lower()
                is_incisor_lbl = "incisor" in lbl.lower() or "canine" in lbl.lower()
                
                new_label = None
                reason = ""
                
                # PRIORITY 1: Spatial Zone (Physical Reality)
                if is_molar_zone and is_incisor_lbl:
                     new_label = "Molar"
                     reason = "Zone->Molar"
                elif is_incisor_zone and is_molar_lbl:
                     new_label = "Incisor"
                     reason = "Zone->Incisor"
                
                # PRIORITY 2: FDI Assignment (if Zone is ambiguous)
                if not new_label:
                    if is_molar_fdi and is_incisor_lbl:
                        new_label = "Molar"
                        reason = "FDI->Molar"
                    elif is_incisor_fdi and is_molar_lbl:
                        new_label = "Incisor"
                        reason = "FDI->Incisor"
                
                if new_label:
                    item['label'] = new_label
                    try:
                        if reason not in item.get('notes', ""):
                             item['notes'] = (item.get('notes', "") + f" ({reason})").strip()
                    except: pass

        results['boxes'] = [item['box'] for item in items]
        results['labels'] = [item['label'] for item in items]
        results['scores'] = [item['score'] for item in items]
        results['fdi'] = [item.get('fdi') for item in items]
        results['statuses'] = [item.get('statuses', []) for item in items]
        results['notes'] = [item.get('notes', "") for item in items]
        results['last_updated'] = [item.get('last_updated', None) for item in items]
        results['_item_refs'] = [item.get('item_ref', None) for item in items]
        results['generated'] = [item.get('generated', False) for item in items]
        
        return results

    def _odontogram_fdi_matrix(self):
        return [
            ["18", "17", "16", "15", "14", "13", "12", "11"],
            ["21", "22", "23", "24", "25", "26", "27", "28"],
            ["38", "37", "36", "35", "34", "33", "32", "31"],
            ["41", "42", "43", "44", "45", "46", "47", "48"],
        ]

    def _init_odontogram_cells(self):
        table = getattr(self, "odontogram_table", None)
        if table is None:
            return
        pos = {}
        mat = self._odontogram_fdi_matrix()
        for r in range(4):
            for c in range(8):
                fdi = str(mat[r][c])
                it = QTableWidgetItem(f"{fdi}\n—")
                it.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                try:
                    it.setToolTip(fdi)
                except Exception:
                    pass
                table.setItem(r, c, it)
                pos[fdi] = (r, c)
        self._odontogram_pos_by_fdi = pos

    def _update_odontogram_from_results(self, results):
        table = getattr(self, "odontogram_table", None)
        if table is None:
            return
        if not isinstance(results, dict):
            return
        pos = getattr(self, "_odontogram_pos_by_fdi", None)
        if not isinstance(pos, dict) or not pos:
            self._init_odontogram_cells()
            pos = getattr(self, "_odontogram_pos_by_fdi", None)
            if not isinstance(pos, dict):
                return
        fdi_list = results.get("fdi", []) or []
        statuses_list = results.get("statuses", []) or []
        by_fdi = {}
        for i, fdi in enumerate(fdi_list):
            f = str(fdi or "").strip()
            if not re.match(r"^\d{2}$", f):
                continue
            st = statuses_list[i] if i < len(statuses_list) else []
            st0 = st if isinstance(st, list) else []
            by_fdi[f] = [str(x).strip() for x in st0 if str(x).strip()]
        prev_by_fdi = {}
        try:
            base = getattr(self, "_compare_baseline", None)
            base_data = (base or {}).get("data") if isinstance(base, dict) else None
            if isinstance(base_data, dict):
                bf = base_data.get("fdi", []) or []
                bs = base_data.get("statuses", []) or []
                for i, fdi in enumerate(bf):
                    f = str(fdi or "").strip()
                    if not re.match(r"^\d{2}$", f):
                        continue
                    st = bs[i] if i < len(bs) else []
                    st0 = st if isinstance(st, list) else []
                    prev_by_fdi[f] = [str(x).strip() for x in st0 if str(x).strip()]
        except Exception:
            prev_by_fdi = {}
        for fdi, (r, c) in pos.items():
            it = table.item(r, c)
            if it is None:
                it = QTableWidgetItem()
                it.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                table.setItem(r, c, it)
            st = by_fdi.get(fdi, [])
            low = [s.lower() for s in st]
            is_missing = any("ελλείπ" in s for s in low)
            is_healthy = (not st) or (len(st) == 1 and ("υγι" in low[0] or low[0] == "healthy"))
            if is_missing:
                mark = "X"
                bg = QColor("#5c1e1e")
                fg = QColor("#ffd6d6")
            elif is_healthy:
                mark = "✓"
                bg = QColor("#1e5c2a")
                fg = QColor("#d6ffdf")
            else:
                mark = "!"
                bg = QColor("#5a4a1a")
                fg = QColor("#fff0c2")
            it.setText(f"{fdi}\n{mark}")
            try:
                prev_st = prev_by_fdi.get(fdi, [])
                tip = f"{fdi}\nΝέα: " + (", ".join(st) if st else "—")
                if prev_st:
                    tip += "\nΠροηγούμενη: " + ", ".join(prev_st)
                it.setToolTip(tip)
            except Exception:
                pass
            try:
                it.setBackground(bg)
                it.setForeground(fg)
            except Exception:
                pass

    def draw_segmentation_masks(self, masks, results):
        """
        Draws segmentation masks for the new "Texture Scanning" philosophy.
        Replaces bounding boxes with precise polygon overlays.
        """
        if masks is None: return

        # Define colors for classes (matching TextureScanner)
        # 1: Bone (White/Yellow), 3: Enamel (White), 6: Metal (Blue/Cyan)
        colors = {
            1: QColor(240, 230, 140, 100), # Khaki (Bone)
            2: QColor(255, 255, 255, 120), # White (Cortical)
            3: QColor(200, 200, 255, 100), # Enamel
            6: QColor(0, 255, 255, 150),   # Cyan (Metal)
            9: QColor(255, 50, 50, 150)    # Red (Caries)
        }

        # Handle different mask formats (YOLOv8 Masks object or raw list of polygons)
        # If it's YOLOv8 Masks object
        if hasattr(masks, 'xy'): # YOLOv8 Masks object has .xy attribute which is list of segments
            segments = masks.xy
            # We also need class labels to color correctly
            labels = results.get('labels', [])
            class_ids = results.get('class_ids', []) # Assuming we pass class_ids
            
            for i, seg in enumerate(segments):
                if len(seg) < 3: continue
                
                # Create QPolygonF
                poly = QPolygonF()
                for point in seg:
                    poly.append(QPointF(point[0], point[1]))
                
                # Determine color
                cid = int(class_ids[i]) if i < len(class_ids) else 0
                color = colors.get(cid, QColor(0, 255, 0, 100)) # Default Green
                
                # Create Item
                poly_item = QGraphicsPolygonItem(poly)
                poly_item.setBrush(QBrush(color))
                poly_item.setPen(QPen(color.darker(), 1))
                
                self.scene.addItem(poly_item)
                self.analysis_items.append(poly_item)

    def trigger_active_learning(self):
        """
        Collects all user-validated data from the scene and triggers a training session.
        """
        try:
            from app.ai.feedback_manager import FeedbackManager
            # Ensure FeedbackManager is initialized
            if not hasattr(self, "feedback_manager"):
                self.feedback_manager = FeedbackManager(str(Path(__file__).resolve().parents[2]))
            
            # 1. Capture the current state of the scene (User Corrections)
            # We need the original image and the current validated boxes/labels
            if not self.current_image_path or not self.pixmap_item:
                QMessageBox.warning(self, "Προσοχή", "Δεν υπάρχει ενεργή εικόνα για εκπαίδευση.")
                return

            # Get current items from scene
            current_boxes = []
            current_labels = [] # FDI
            current_statuses = []
            current_implants = []
            current_updated_by = []
            
            # Iterate editable rects
            for item in self.analysis_items:
                if isinstance(item, EditableRectItem) and item.isVisible():
                    rect = item.rect()
                    pos = item.scenePos()
                    x1 = pos.x() + rect.x()
                    y1 = pos.y() + rect.y()
                    x2 = x1 + rect.width()
                    y2 = y1 + rect.height()
                    
                    # Get FDI from text item
                    fdi = "?"
                    if hasattr(item, "text_item") and item.text_item:
                        txt = item.text_item.toPlainText()
                        # Extract just the number part (e.g. "36\nΣτεφάνη")
                        parts = txt.split('\n')
                        if parts:
                             fdi_cand = parts[0].strip()
                             if fdi_cand.isdigit():
                                 fdi = fdi_cand
                    
                    # Get Statuses
                    statuses = item.get_statuses()
                    
                    # Get Implant Info
                    implant = item.get_implant() if hasattr(item, "get_implant") else {}
                    
                    # Get User Info
                    updated_by = item.get_last_updated_by() if hasattr(item, "get_last_updated_by") else ""
                    
                    current_boxes.append([x1, y1, x2, y2])
                    current_labels.append(fdi)
                    current_statuses.append(statuses)
                    current_implants.append(implant)
                    current_updated_by.append(updated_by)
            
            if not current_boxes:
                QMessageBox.information(self, "Πληροφορία", "Δεν υπάρχουν ευρήματα για εκπαίδευση.")
                return

            # Construct 'results' dict compatible with feedback manager
            mock_results = {
                "boxes": current_boxes,
                "labels": current_labels, 
                "statuses": current_statuses,
                "implants": current_implants,
                "last_updated_by": current_updated_by,
                "scores": [1.0] * len(current_boxes) # High confidence for user feedback
            }
            
            # Call save_feedback
            # We must pass the image path string, NOT the numpy array
            count = self.feedback_manager.save_feedback(
                str(self.current_image_path), 
                mock_results, 
                patient_id=str(getattr(self, "origin_patient_id", "") or "Dr_User")
            )
            
            self._trace_log("training_examples_saved", {"count": count, "patient_id": str(getattr(self, "origin_patient_id", "") or "Dr_User")})
            
            QMessageBox.information(self, "Επιτυχία", f"Ο Τόλης έμαθε! (Αποθηκεύτηκαν {count} παραδείγματα)\nΗ επανεκπαίδευση θα ξεκινήσει αυτόματα στο παρασκήνιο.")
            
        except Exception as e:
            print(f"Training Error: {e}")
            self._trace_log("training_error", {"error": str(e)})
            QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία εκπαίδευσης: {e}")

    def display_analysis_results(self, results):
        if not results: return
        
        # Enable Training Button since we have results
        try:
             self.train_button.setEnabled(True)
        except Exception:
             pass
        
        # --- NEW PHILOSOPHY: SEGMENTATION ---
        # If we have segmentation masks, use them and SKIP box drawing
        masks = results.get('masks', None)
        if masks is not None:
            self.draw_segmentation_masks(masks, results)
            # If we are in "Texture Scan" mode, we might stop here or draw limited info.
            # The user asked to "remove what is not necessary", so we skip the box loop.
            
            # Still update text results
            self.results_text_edit.clear()
            self.results_text_edit.append("<b>Λειτουργία Σάρωσης Υφής (Segmentation)</b>")
            self.results_text_edit.append("--------------------------------")
            # ... (Add logic to summarize segmentation results if needed)
            return

        prev_auto = bool(getattr(self, "auto_fdi_enabled", True))
        try:
            self.results_text_edit.clear()
        except Exception:
            pass
        try:
            device = str((results or {}).get("device") or "unknown")
            device_str = "GPU (CUDA)" if "cuda" in device.lower() else f"CPU ({device})"
            self.results_text_edit.append(f"<b>Συσκευή Ανάλυσης: {device_str}</b>")
            self.results_text_edit.append("--------------------------------")
        except Exception:
            pass
        try:
            boxes0 = (results or {}).get("boxes", []) or []
            if not boxes0:
                self.results_text_edit.append("Δεν ανιχνεύθηκαν αντικείμενα (0 boxes).")
                dbg = (results or {}).get("debug")
                if isinstance(dbg, dict):
                    try:
                        self.results_text_edit.append("")
                        self.results_text_edit.append("Διαγνωστικά:")
                        raw = dbg.get("raw_detections")
                        post = dbg.get("post_filter")
                        post_teeth = dbg.get("post_filter_teeth")
                        tm = dbg.get("tooth_mode")
                        parts = []
                        if raw is not None:
                            parts.append(f"raw={raw}")
                        if post is not None:
                            parts.append(f"kept={post}")
                        if post_teeth is not None:
                            parts.append(f"teeth={post_teeth}")
                        if tm:
                            parts.append(f"tooth_mode={tm}")
                        if parts:
                            self.results_text_edit.append("- " + " | ".join([str(x) for x in parts]))
                    except Exception:
                        pass
                return
        except Exception:
            pass
        try:
            self._bulk_scene_update = True
        except Exception:
            pass
        try:
            if hasattr(self, "recalc_timer") and self.recalc_timer is not None:
                self.recalc_timer.stop()
        except Exception:
            pass
        try:
            self.auto_fdi_enabled = False
        except Exception:
            pass
        try:
            from PyQt6.QtCore import QTimer
        except Exception:
            QTimer = None
        if QTimer is not None:
            def _restore_after_display():
                try:
                    self.auto_fdi_enabled = prev_auto
                except Exception:
                    pass
                try:
                    self._bulk_scene_update = False
                except Exception:
                    pass
                try:
                    if prev_auto:
                        self.debounced_recalculate_fdi()
                except Exception:
                    pass
            try:
                QTimer.singleShot(0, _restore_after_display)
            except Exception:
                pass

        # --- AUTO-INITIALIZE SEPARATOR LINES ---
        # If lines don't exist, create them using smart heuristics
        lines_created = False
        try:
            if self.jaw_separator_line and not self._is_scene_item_alive(self.jaw_separator_line):
                self.jaw_separator_line = None
        except Exception:
            self.jaw_separator_line = None
        if not self.jaw_separator_line:
            boxes = results.get('boxes', [])
            if boxes:
                # 1. Smart Jaw Separation using K-Means Clustering
                try:
                    from app.ai.jaw_separation import separate_jaws_kmeans, fit_jaw_curve
                    img_h = 0
                    if self.pixmap_item:
                         img_h = self.pixmap_item.boundingRect().height()
                    split_y, upper_idxs, lower_idxs = separate_jaws_kmeans(boxes, img_h)
                    
                    # Try to fit a curve if enough points
                    coeffs = fit_jaw_curve(boxes, upper_idxs + lower_idxs)
                except Exception as e:
                    print(f"Jaw Separation Error: {e}")
                    # Fallback to legacy logic
                    ys = []
                    for box in boxes:
                        _, y1, _, y2 = box
                        ys.append((y1 + y2) / 2)
                    ys.sort()
                    max_gap = 0
                    split_y = sum(ys) / len(ys) if ys else 0
                    if len(ys) > 2:
                        start_idx = len(ys) // 4
                        end_idx = 3 * len(ys) // 4
                        for i in range(start_idx, end_idx):
                            gap = ys[i+1] - ys[i]
                            if gap > max_gap:
                                max_gap = gap
                                split_y = (ys[i] + ys[i+1]) / 2
                    if max_gap < 10:
                        split_y = sum(ys) / len(ys)
                    coeffs = None
                    
                # 2. Calculate Smart Vertical Split (X)
                xs = []
                for box in boxes:
                    x1, _, x2, _ = box
                    xs.append((x1 + x2) / 2)
                split_x = sum(xs) / len(xs) if xs else 0
                
                # Create Lines
                rect = self.pixmap_item.boundingRect() if self.pixmap_item else self.scene.sceneRect()
                width = rect.width()
                height = rect.height()
                
                self.jaw_separator_line = ZoneSeparatorLine(width, split_y, label="Jaw Separator", color=Qt.GlobalColor.cyan, on_change_callback=self._on_jaw_lines_changed)
                # Curve coefficients logic removed


                self.scene.addItem(self.jaw_separator_line)
                
                self.vertical_separator_line = VerticalSeparatorLine(height, split_x, on_change_callback=self._on_jaw_lines_changed)
                self.scene.addItem(self.vertical_separator_line)
                self.apply_layout_lock()
                
                lines_created = True

                # --- SMART GRID PLACEMENT & AUTO-CROP ---
                try:
                    from app.ai.geometry_utils import DentalGeometry
                    
                    # 1. Estimate Midline
                    est_mid_x = DentalGeometry.find_dental_midline(boxes)
                    if est_mid_x is not None:
                         # Move VerticalSeparatorLine to the estimated midline
                         self.vertical_separator_line.setPos(est_mid_x, 0)
                    
                    # 2. Estimate Occlusal Plane (already done by split_y, but maybe refine)
                    
                    # 3. Auto-Crop (Optional, user can trigger)
                    # We can store the ROI suggestion in debug or apply if preferences say so
                    crop_x, crop_y, crop_w, crop_h = DentalGeometry.calculate_auto_crop_roi(boxes, width, height)
                    # If this is a raw import, we might want to suggest crop. 
                    # For now, let's just log it or draw a suggestion rect if in debug mode.
                    
                    # 4. Smart Grid Cell Sizing
                    # If grid mode is active, adjust cell sizes
                    if self.grid_active:
                         gw, gh = DentalGeometry.estimate_grid_parameters(boxes, est_mid_x, split_y)
                         # We need a way to update the grid parameters. 
                         # Currently grid is drawn based on self.grid_lines_v/h which are proportional.
                         # This is complex to back-propagate to the proportional lines without a full refactor.
                         # But we can at least ensure the grid centers on the midline.
                         pass
                         
                except Exception as e:
                    print(f"Smart Placement Error: {e}")
                # ----------------------------------------

        # If we just created lines, RE-RUN assignment to use them
        if lines_created:
            try:
                results = self.assign_fdi_numbers(results)
                self.analysis_results = results # Update stored results
            except Exception as e:
                print(f"Error assigning FDI numbers: {e}")

        try:
            self.results_text_edit.clear()
            
            # Display Device Info
            device = results.get('device', 'unknown')
            device_str = "GPU (CUDA)" if "cuda" in device.lower() else f"CPU ({device})"
            self.results_text_edit.append(f"<b>Συσκευή Ανάλυσης: {device_str}</b>")
            self.results_text_edit.append("--------------------------------")
            
            self.results_text_edit.append("Αποτελέσματα Ανάλυσης:")
            
            boxes = results.get('boxes', [])
            labels = results.get('labels', [])
            scores = results.get('scores', [])
            fdis = results.get('fdi', [None]*len(boxes))
            statuses_list = results.get('statuses', [[] for _ in range(len(boxes))])
            tooth_summary_list = results.get('tooth_summary', [None for _ in range(len(boxes))])
            notes_list = results.get('notes', ["" for _ in range(len(boxes))])
            last_updated_list = results.get('last_updated', ["" for _ in range(len(boxes))])
            bypass_grid_list = results.get('bypass_grid', [False for _ in range(len(boxes))])
            img_w = 0.0
            img_h = 0.0
            try:
                rect_img = self.pixmap_item.boundingRect() if self.pixmap_item else self.scene.sceneRect()
                img_w = float(rect_img.width())
                img_h = float(rect_img.height())
            except Exception:
                img_w = 0.0
                img_h = 0.0
        except Exception as e:
            self.results_text_edit.append(f"Σφάλμα κατά την εμφάνιση αποτελεσμάτων: {e}")
            return
        try:
            valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
            valid = [str(x).strip() for x in (fdis or []) if str(x).strip() in valid_fdi_set]
            unique_valid = sorted(set(valid), key=lambda s: int(s))
            dup_n = max(0, int(len(valid)) - int(len(unique_valid)))
            msg = f"FDI: {len(unique_valid)}/32"
            if dup_n:
                msg += f" | διπλότυπα: {dup_n}"
            self.results_text_edit.append(msg)
        except Exception:
            pass
        try:
            dbg = results.get("debug")
            if isinstance(dbg, dict):
                sel = ""
                try:
                    sel = str((dbg.get("filters") or {}).get("selected") or "").strip()
                except Exception:
                    sel = ""
                roi = dbg.get("roi") if isinstance(dbg.get("roi"), dict) else {}
                raw = dbg.get("raw_detections")
                post = dbg.get("post_filter")
                post_teeth = dbg.get("post_filter_teeth")
                parts = []
                if isinstance(raw, int):
                    parts.append(f"raw={raw}")
                if isinstance(post, int):
                    parts.append(f"kept={post}")
                if isinstance(post_teeth, int):
                    parts.append(f"teeth={post_teeth}")
                if sel:
                    parts.append(f"filters={sel}")
                if isinstance(roi, dict) and roi:
                    try:
                        parts.append(f"roi={int(roi.get('w',0))}x{int(roi.get('h',0))}@({int(roi.get('x0',0))},{int(roi.get('y0',0))})")
                    except Exception:
                        pass
                if parts:
                    self.results_text_edit.append("")
                    self.results_text_edit.append("Διαγνωστικά:")
                    self.results_text_edit.append("- " + " | ".join(parts))
                try:
                    tm = str(dbg.get("tooth_mode") or "").strip()
                    if tm:
                        self.results_text_edit.append(f"- tooth_mode={tm}")
                except Exception:
                    pass
                try:
                    rid = dbg.get("resolved_ids")
                    if isinstance(rid, dict):
                        tid = rid.get("tooth", None)
                        self.results_text_edit.append(f"- tooth_id={tid}")
                except Exception:
                    pass
                try:
                    hist = dbg.get("class_hist_top")
                    if isinstance(hist, list) and hist:
                        chunks = []
                        for it in hist[:8]:
                            if not isinstance(it, dict):
                                continue
                            cid = it.get("id")
                            nm = str(it.get("name") or "").strip()
                            cnt = it.get("count")
                            if cid is None or cnt is None:
                                continue
                            nm_part = f":{nm}" if nm else ""
                            chunks.append(f"{cid}{nm_part}({int(cnt)})")
                        if chunks:
                            self.results_text_edit.append("- classes=" + " | ".join(chunks))
                except Exception:
                    pass
        except Exception:
            pass
        try:
            self._update_odontogram_from_results(results)
        except Exception:
            pass

        missing_fdis = []
        try:
            for i, st in enumerate(statuses_list):
                st = st if isinstance(st, list) else []
                if any("ελλείπ" in str(x).lower() for x in st if str(x).strip()):
                    f = str(fdis[i] if i < len(fdis) else "").strip()
                    if re.match(r"^\d{2}$", f):
                        missing_fdis.append(f)
        except Exception:
            missing_fdis = []
        try:
            missing_fdis = sorted(set(missing_fdis), key=lambda x: int(x))
        except Exception:
            try:
                missing_fdis = sorted(set(missing_fdis))
            except Exception:
                pass
        try:
            if missing_fdis:
                results["missing_teeth_fdi"] = list(missing_fdis)
        except Exception:
            pass

        merged_missing = set(missing_fdis or [])
        try:
            if self.current_image_path:
                base = os.path.splitext(self.current_image_path)[0]
                json_path = base + "_analysis.json"
                if os.path.exists(json_path):
                    with open(json_path, "r", encoding="utf-8") as f:
                        saved = json.load(f) or {}
                    sm = saved.get("missing_teeth_fdi") or []
                    for x in sm:
                        xs = str(x or "").strip()
                        if re.match(r"^\d{2}$", xs):
                            merged_missing.add(xs)
                    tp = saved.get("teeth_presence") or []
                    if isinstance(tp, list):
                        for rec in tp:
                            if not isinstance(rec, dict):
                                continue
                            if bool(rec.get("present", True)):
                                continue
                            xs = str(rec.get("fdi", "") or "").strip()
                            if re.match(r"^\d{2}$", xs):
                                merged_missing.add(xs)
        except Exception:
            pass
        try:
            missing_fdis = sorted(merged_missing, key=lambda x: int(x))
        except Exception:
            missing_fdis = sorted(list(merged_missing))

        detected_present = set()
        try:
            for i, f in enumerate(fdis):
                fs = str(f or "").strip()
                if not re.match(r"^\d{2}$", fs):
                    continue
                st = statuses_list[i] if i < len(statuses_list) else []
                st = st if isinstance(st, list) else []
                if any("ελλείπ" in str(x).lower() for x in st if str(x).strip()):
                    continue
                detected_present.add(fs)
        except Exception:
            detected_present = set()
        expected_present = max(0, 32 - len(missing_fdis))
        try:
            if missing_fdis:
                self.results_text_edit.append(f"Παρόντα: {len(detected_present)}/{expected_present} | Ελλείποντα: {len(missing_fdis)}")
        except Exception:
            pass
        
        # Group by FDI for text output
        # e.g. "18: healthy (0.95)"

        # Clear existing analysis items from scene to avoid duplicates
        try:
            if self.scene:
                items_to_remove = [item for item in self.scene.items() if isinstance(item, (EditableRectItem, EditableTextItem))]
                for item in items_to_remove:
                    self.scene.removeItem(item)
                self.analysis_items = []
        except Exception as e:
            print(f"Error clearing scene items: {e}")
        
        text_lines = []
        
        for i, box in enumerate(boxes):
            x1, y1, x2, y2 = box
            w = x2 - x1
            h = y2 - y1
            
            label = labels[i] if i < len(labels) else "Tooth"
            score = scores[i] if i < len(scores) else 0.0
            statuses = statuses_list[i] if i < len(statuses_list) else []
            notes = notes_list[i] if i < len(notes_list) else ""
            last_updated = last_updated_list[i] if i < len(last_updated_list) else ""
            bypass_grid = bypass_grid_list[i] if i < len(bypass_grid_list) else False
            fdi = fdis[i]
            try:
                is_missing = any("ελλείπ" in str(s).lower() for s in (statuses or []) if str(s).strip())
            except Exception:
                is_missing = False
            if (not bypass_grid) and (not is_missing) and img_w > 0.0 and img_h > 0.0:
                dx = max(3.0, img_w * 0.006)
                dy = max(3.0, img_h * 0.006)
                x1 = max(0.0, x1 - dx * 0.5)
                y1 = max(0.0, y1 - dy * 0.5)
                x2 = min(img_w, x2 + dx * 0.5)
                y2 = min(img_h, y2 + dy * 0.5)
                w = x2 - x1
                h = y2 - y1
            
            # Sanitize legacy invalid FDI
            if fdi:
                fdi_str = str(fdi)
                if fdi_str.endswith('?') and len(fdi_str) > 2:
                    fdi = "?"

            display_label = ""
            try:
                s_fdi = str(fdi or "").strip()
                if re.match(r"^\d+$", s_fdi):
                    display_label = s_fdi
            except Exception:
                display_label = ""
            # Optional: include condition if not healthy? 
            # User asked for numbers.
            
            # Create items without callback initially to avoid recursion during setup (setPos triggers itemChange)
            rect = EditableRectItem(x=x1, y=y1, w=w, h=h)

            if (not statuses) and isinstance(label, str) and ("healthy" in label.lower()):
                statuses = ["Υγιές"]

            self.scene.addItem(rect)
            rect.set_statuses(statuses, notify=False)
            rect.set_notes(notes)
            rect.set_last_updated(last_updated)
            rect.set_bypass_grid(bypass_grid)
            self.analysis_items.append(rect)
            
            text_item = EditableTextItem(display_label, rect_item=rect)
            text_item.setDefaultTextColor(QColor("red"))
            try:
                rect.label_offset = QPointF(0.0, 2.0) if bool(getattr(self, "grid_active", False)) else QPointF(0.0, -20.0)
            except Exception:
                pass
            self.scene.addItem(text_item)
            self.analysis_items.append(text_item)
            self._apply_overlay_visibility(rect, text_item)
            self._position_label_for_rect(rect)
            
            # Attach callbacks now that items are positioned
            rect.on_change_callback = self.recalculate_fdi
            text_item.on_change_callback = self.recalculate_fdi
            
            # Text List Entry
            summary = tooth_summary_list[i] if i < len(tooth_summary_list) else None
            status_text = ", ".join(statuses) if statuses else label
            if isinstance(summary, dict) and summary.get("text"):
                status_text = str(summary.get("text"))
                sev = summary.get("severity")
                if sev:
                    status_text = f"{status_text} | Σοβαρότητα: {sev}"
            if fdi:
                line = f"Δόντι {fdi} ({status_text}): {score:.2f}"
            else:
                line = f"Δόντι {i+1} ({status_text}): {score:.2f}"
            
            if notes:
                line += f" | Σχόλια: {notes}"
            
            text_lines.append((fdi if fdi else "99", line))
            
        # Sort text output by FDI
        text_lines.sort(key=lambda x: str(x[0]))
        
        try:
            for _, line in text_lines:
                self.results_text_edit.append(line)
        except Exception:
            pass

        try:
            if missing_fdis:
                self.results_text_edit.append("")
                self.results_text_edit.append(f"Ελλείποντα (καταγραφή): {', '.join(missing_fdis)}")
        except Exception:
            pass

        try:
            summary_block = self.compute_radiograph_summary(fdis, tooth_summary_list)
            if summary_block:
                try:
                    self.results_text_edit.append("")
                    self.results_text_edit.append("Σύνοψη Ακτινογραφίας:")
                    self.results_text_edit.append(summary_block.get("text", ""))
                except Exception:
                    pass
        except Exception:
            pass

        golden = self.compute_golden_ratio_metrics(results)
        if golden and golden.get("ratios"):
            try:
                self.results_text_edit.append("")
                self.results_text_edit.append("Χρυσή Τομή (φ=1.618):")
                for row in golden["ratios"]:
                    self.results_text_edit.append(row)
                if golden.get("mean_deviation_pct") is not None:
                    self.results_text_edit.append(f"Μέση απόκλιση: {golden['mean_deviation_pct']:.1f}%")
            except Exception:
                pass
        try:
            if self.view and (not bool(getattr(self, "manual_pan_enabled", False))):
                QTimer.singleShot(0, self.view.fit_scene_in_view)
        except Exception:
            try:
                if self.view and (not bool(getattr(self, "manual_pan_enabled", False))):
                    self.view.fit_scene_in_view()
            except Exception:
                pass

    def export_results_to_text(self):
        if not self.analysis_results: return
        started = None
        try:
            started = time.perf_counter()
        except Exception:
            started = None
        file_path, _ = QFileDialog.getSaveFileName(self, "Εξαγωγή", "", "Text Files (*.txt)")
        if not file_path:
            try:
                self._announce_action_done("Εξαγωγή κειμένου: ακυρώθηκε", elapsed_ms=(time.perf_counter() - started) * 1000.0 if started else None)
            except Exception:
                pass
            return
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(self.results_text_edit.toPlainText())
            self._announce_action_done(f"Εξαγωγή κειμένου: {file_path}", elapsed_ms=(time.perf_counter() - started) * 1000.0 if started else None)
        except Exception as e:
            try:
                self._announce_action_failed(f"Εξαγωγή κειμένου: {e}")
            except Exception:
                pass
            try:
                QMessageBox.warning(self, "Εξαγωγή", f"Αποτυχία εξαγωγής: {e}")
            except Exception:
                pass

    def _collect_jaw_state(self):
        """
        Helper to collect current jaw/separator line state for saving.
        """
        jaw_lines = {
            "visible": False,
            "y_split": None,
            "x_split": None,
            "curve_h": 0,
            # Also store normalized values for resolution independence
            "y_split_norm": None, 
            "x_split_norm": None,
            "zone_line_1_norm": None,
            "zone_line_2_norm": None
        }
        
        try:
            rect = self.pixmap_item.boundingRect()
            img_w = rect.width()
            img_h = rect.height()
            
            # 1. Jaw Separator (Horizontal/Curve)
            if hasattr(self, "jaw_separator_line") and self.jaw_separator_line:
                jaw_lines["visible"] = self.jaw_separator_line.isVisible()
                # Store absolute Y
                jaw_lines["y_split"] = self.jaw_separator_line.y_pos
                jaw_lines["curve_h"] = self.jaw_separator_line.curve_h
                # Store normalized Y (0.0 - 1.0)
                if img_h > 0:
                    jaw_lines["y_split_norm"] = self.jaw_separator_line.y_pos / img_h
            
            # 2. Vertical Separator (Midline)
            # Check 'vertical_separator_line' (legacy name) or 'midline_item' (new name)
            midline = getattr(self, "vertical_separator_line", None) or getattr(self, "midline_item", None)
            
            if midline:
                # Absolute X
                try:
                    if hasattr(midline, "x_pos"):
                         jaw_lines["x_split"] = midline.x_pos
                    else:
                         # If it's a QGraphicsRectItem, assume center or x
                         jaw_lines["x_split"] = midline.scenePos().x() + midline.rect().x() + midline.rect().width()/2
                except:
                     jaw_lines["x_split"] = 500 # Fallback
                
                # Normalized X
                if img_w > 0 and jaw_lines["x_split"] is not None:
                    jaw_lines["x_split_norm"] = jaw_lines["x_split"] / img_w
            
            # 3. Zone Lines (Anatomical Zones)
            if hasattr(self, "zone_lines") and self.zone_lines:
                z1 = self.zone_lines.get("line1")
                z2 = self.zone_lines.get("line2")
                if z1 and z2:
                    y1 = z1.y()
                    y2 = z2.y()
                    if img_h > 0:
                        jaw_lines["zone_line_1_norm"] = y1 / img_h
                        jaw_lines["zone_line_2_norm"] = y2 / img_h

        except Exception as e:
            print(f"Error collecting jaw state: {e}")
            
        return jaw_lines

    def save_edited_results(self, checked: bool = False):
        # DEBUG LOGGING
        print(f"DEBUG: save_edited_results called. Path: {getattr(self, 'current_image_path', 'None')}")
        
        if not self.current_image_path: 
            print("DEBUG: Aborting save - No current_image_path")
            return

        started = None
        try:
            started = time.perf_counter()
        except Exception:
            started = None
        try:
            self._trace_log("save_started", {"autosave": bool(checked), "analysis_step": str(getattr(self, "analysis_step", ""))})
        except Exception:
            pass
        try:
            self._pipeline_set(
                "save",
                "Αποθήκευση σε εξέλιξη",
                self._pipeline_hint_for_step("save"),
                progress=70,
                step_status_updates={"save": "RUN"},
            )
        except Exception:
            pass
        try:
            self._pipeline_pre_save_baseline = copy.deepcopy(getattr(self, "_pipeline_baseline_data", None)) if isinstance(getattr(self, "_pipeline_baseline_data", None), dict) else {}
        except Exception:
            self._pipeline_pre_save_baseline = {}
        
        # Capture current jaw lines state
        current_jaw_lines = self._collect_jaw_state()
        
        data = {
            'image_path': self.current_image_path,
            'boxes': [],
            'fdi': [],
            'statuses': [],
            'bypass_grid': [],
            'label_offsets': [],
            'label_offsets_user': [],
            'notes': [],
            'last_updated': [],
            'last_updated_by': [],
            'implants': [],
            'calibration': {},
            'jaw_lines': current_jaw_lines # Use the captured state
        }
        
        # 1. Collect Boxes and Labels from Scene
        rects_map = {}  
        
        # First pass: Get all rects
        for item in self.scene.items():
            if isinstance(item, EditableRectItem):
                r = item.rect()
                pos = item.scenePos()
                x1 = pos.x() + r.x()
                y1 = pos.y() + r.y()
                x2 = x1 + r.width()
                y2 = y1 + r.height()
                
                # Get statuses
                statuses = item.data(Qt.ItemDataRole.UserRole)
                if not isinstance(statuses, list):
                    statuses = []

                # Get notes and timestamp
                notes = item.get_notes()
                last_updated = item.get_last_updated()
                last_updated_by = item.get_last_updated_by() if hasattr(item, "get_last_updated_by") else ""
                implant = item.get_implant() if hasattr(item, "get_implant") else {}
                    
                # Store with item as key
                rects_map[item] = {
                    'rect': [x1, y1, x2, y2], 
                    'label': '?',
                    'statuses': statuses,
                    'notes': notes,
                    'last_updated': last_updated,
                    'last_updated_by': last_updated_by,
                    'implant': implant,
                    'label_offset': [0.0, -20.0],
                    'label_offset_user': bool(getattr(item, "label_offset_user", False))
                }

        # Second pass: Get labels from text items
        for item in self.scene.items():
            if isinstance(item, EditableTextItem):
                if hasattr(item, 'rect_item') and item.rect_item in rects_map:
                    rects_map[item.rect_item]['label'] = item.toPlainText()
                    try:
                        x1, y1, _, _ = rects_map[item.rect_item]['rect']
                        tp = item.scenePos()
                        rects_map[item.rect_item]['label_offset'] = [float(tp.x() - float(x1)), float(tp.y() - float(y1))]
                    except Exception:
                        pass
        
        for v in rects_map.values():
            data['boxes'].append(v['rect'])
            data['fdi'].append(v['label'])
            data['statuses'].append(v['statuses'])
            data['label_offsets'].append(v.get('label_offset', [0.0, -20.0]))
            data['label_offsets_user'].append(bool(v.get('label_offset_user', False)))
            data['notes'].append(v['notes'])
            data['last_updated'].append(v['last_updated'])
            data['last_updated_by'].append(v.get('last_updated_by'))
            data['implants'].append(v.get('implant', {}))

        # 2. Calibration
        if self.pixel_to_mm_scale_x or self.pixel_to_mm_scale_y:
            data['calibration']['scale_x'] = self.pixel_to_mm_scale_x
            data['calibration']['scale_y'] = self.pixel_to_mm_scale_y
            data['calibration']['scale'] = self.pixel_to_mm_scale
        elif self.pixel_to_mm_scale:
             data['calibration']['scale'] = self.pixel_to_mm_scale

        if self.calib_line_x and self.calib_line_x.scene() == self.scene:
            p1 = self.calib_line_x.mapToScene(self.calib_line_x.h1.pos())
            p2 = self.calib_line_x.mapToScene(self.calib_line_x.h2.pos())
            data['calibration']['line_x'] = {
                'coords': [p1.x(), p1.y(), p2.x(), p2.y()],
                'mm_length': self.calib_line_x.mm_length
            }
        try:
            data['calibration']['visible'] = bool(getattr(self, "is_calibrating", False))
        except Exception:
            pass
            
        if self.calib_line_y and self.calib_line_y.scene() == self.scene:
            p1 = self.calib_line_y.mapToScene(self.calib_line_y.h1.pos())
            p2 = self.calib_line_y.mapToScene(self.calib_line_y.h2.pos())
            data['calibration']['line_y'] = {
                'coords': [p1.x(), p1.y(), p2.x(), p2.y()],
                'mm_length': self.calib_line_y.mm_length
            }

        # 3. Jaw Lines
        jaw = getattr(self, "jaw_separator_line", None)
        if self._is_scene_item_alive(jaw):
             data['jaw_lines']['y_split'] = float(jaw.y())
             try:
                 data['jaw_lines']['curve_h'] = float(getattr(jaw, "curve_h", 0) or 0)
             except Exception:
                 data['jaw_lines']['curve_h'] = 0
             try:
                 data['jaw_lines']['visible'] = bool(jaw.isVisible())
             except Exception:
                 pass

        vline = getattr(self, "vertical_separator_line", None)
        if self._is_scene_item_alive(vline):
             data['jaw_lines']['x_split'] = float(self._get_vertical_split_x())
             try:
                 if 'visible' not in data['jaw_lines']:
                     data['jaw_lines']['visible'] = bool(vline.isVisible())
             except Exception:
                 pass

        grid_state = self._collect_grid_state()
        if isinstance(grid_state, dict) and grid_state:
            data["grid"] = grid_state

        try:
            golden = self.compute_golden_ratio_metrics({"boxes": data.get("boxes", []), "fdi": data.get("fdi", [])})
            if golden:
                data["golden_ratio"] = golden
        except Exception:
            pass

        try:
            data["tooth_summary"] = self.compute_tooth_summary_from_statuses(data.get("statuses", []))
        except Exception:
            pass

        try:
            data["radiograph_summary"] = self.compute_radiograph_summary(data.get("fdi", []), data.get("tooth_summary", []))
        except Exception:
            pass

        try:
            valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
            fdis0 = data.get("fdi", []) or []
            statuses0 = data.get("statuses", []) or []
            missing = []
            presence = []
            for i, f in enumerate(fdis0):
                f = str(f or "").strip()
                if f not in valid_fdi_set:
                    continue
                st = statuses0[i] if i < len(statuses0) else []
                st = st if isinstance(st, list) else []
                is_missing = any("ελλείπ" in str(x).lower() for x in st if str(x).strip())
                if is_missing:
                    missing.append(f)
                presence.append({"fdi": f, "present": (not is_missing)})
            try:
                missing = sorted(set(missing), key=lambda x: int(x))
            except Exception:
                missing = sorted(set(missing))
            if missing:
                data["missing_teeth_fdi"] = list(missing)
            if presence:
                data["teeth_presence"] = presence
        except Exception:
            pass

        # Prompt for Notes
        notes = ""
        ok = True
        is_autosave = False
        try:
            is_autosave = bool(getattr(self, "_autosave_in_progress", False))
        except Exception:
            is_autosave = False
        try:
            if bool(getattr(self, "_save_silent", False)):
                notes = str(getattr(self, "_save_silent_notes", "") or "")
                ok = True
            else:
                # Use QInputDialog with proper parent and flags to ensure visibility
                notes, ok = QInputDialog.getText(
                    self,
                    "Αποθήκευση Ανάλυσης",
                    "Σημειώσεις / Περιγραφή Αλλαγών (Προαιρετικό):",
                    QLineEdit.EchoMode.Normal,
                )
        except Exception as e:
            print(f"DEBUG: QInputDialog failed: {e}")
            # Fallback: if dialog fails, assume OK with empty notes to prevent data loss
            # OR show error message
            QMessageBox.warning(self, "Προειδοποίηση", f"Το παράθυρο διαλόγου απέτυχε: {e}\nΗ αποθήκευση συνεχίζεται χωρίς σημειώσεις.")
            notes = ""
            ok = True
            
        if not ok:
            print("DEBUG: Save cancelled by user or error.")
            try:
                self._announce_action_done("Αποθήκευση ανάλυσης: ακυρώθηκε", elapsed_ms=(time.perf_counter() - started) * 1000.0 if started else None)
            except Exception:
                pass
            return

        # Save to History
        if not is_autosave:
            if self.save_to_history(data, notes):
                 self.results_text_edit.append(f"✅ Το ιστορικό ενημερώθηκε ({datetime.now().strftime('%H:%M:%S')})")

        # Save to JSON
        json_path = os.path.splitext(self.current_image_path)[0] + "_analysis.json"
        try:
            tmp_path = json_path + ".tmp"
            try:
                if os.path.exists(json_path):
                    backup_path = json_path + ".bak"
                    try:
                        with open(json_path, 'r', encoding='utf-8', errors='ignore') as rf:
                            prev = rf.read()
                        with open(backup_path, 'w', encoding='utf-8') as bf:
                            bf.write(prev)
                    except Exception:
                        pass
            except Exception:
                pass
            with open(tmp_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=4)
                f.flush()
                os.fsync(f.fileno())
            os.replace(tmp_path, json_path)
            try:
                if not is_autosave:
                    self._trace_log("save_finished", {"path": str(json_path), "bytes": int(os.path.getsize(json_path)) if os.path.exists(json_path) else None})
            except Exception:
                pass
            try:
                try:
                    base0 = getattr(self, "_pipeline_pre_save_baseline", None) if isinstance(getattr(self, "_pipeline_pre_save_baseline", None), dict) else {}
                    headline, details = self._pipeline_summarize_changes(base0, data)
                    self._pipeline_last_change_summary = str(headline or "").strip()
                    self._pipeline_last_change_details = [str(x) for x in (details or []) if str(x).strip()]
                    self._pipeline_last_change_report = self._pipeline_build_full_change_report(base0, data)
                except Exception:
                    self._pipeline_last_change_summary = ""
                    self._pipeline_last_change_details = []
                    self._pipeline_last_change_report = None
                try:
                    self._pipeline_baseline_data = copy.deepcopy(data) if isinstance(data, dict) else {}
                except Exception:
                    pass
                self._pipeline_set(
                    "sync" if bool(getattr(self, "auto_pipeline_enabled", True)) else "save",
                    "Η αποθήκευση ολοκληρώθηκε",
                    self._pipeline_hint_for_step("sync" if bool(getattr(self, "auto_pipeline_enabled", True)) else "save"),
                    progress=75,
                    step_status_updates={"save": "OK", "sync": "TODO"},
                )
            except Exception:
                pass
            try:
                if is_autosave:
                    pass
                elif not bool(getattr(self, "_save_silent", False)):
                    QMessageBox.information(self, "Επιτυχία", f"Η ανάλυση αποθηκεύτηκε στο:\n{json_path}")
                else:
                    self.results_text_edit.append(f"✅ Η ανάλυση αποθηκεύτηκε ({os.path.basename(json_path)})")
            except Exception:
                pass
            try:
                if not is_autosave:
                    self._announce_action_done(f"Αποθήκευση ανάλυσης: {os.path.basename(json_path)}", elapsed_ms=(time.perf_counter() - started) * 1000.0 if started else None)
            except Exception:
                pass
        except Exception as e:
            try:
                self._announce_action_failed(f"Αποθήκευση ανάλυσης: {e}")
            except Exception:
                pass
            QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία αποθήκευσης: {e}")
            return

        try:
            try:
                self._last_saved_analysis_data = data
            except Exception:
                pass
            try:
                if not is_autosave:
                    data_for_state = data if isinstance(data, dict) else {}
                    if "device" not in data_for_state:
                        data_for_state["device"] = "manual"
                    self.analysis_results = data_for_state
                    try:
                        self.raw_analysis_results = copy.deepcopy(data_for_state)
                    except Exception:
                        self.raw_analysis_results = data_for_state
                    try:
                        self.export_button.setEnabled(True)
                    except Exception:
                        pass
                    try:
                        if hasattr(self, "analysis_text_button") and self.analysis_text_button:
                            self.analysis_text_button.setEnabled(True)
                    except Exception:
                        pass
                    try:
                        self.clear_analysis_button.setEnabled(True)
                    except Exception:
                        pass
                    try:
                        if getattr(self, "train_model_button", None) is not None:
                            self.train_model_button.setEnabled(True)
                    except Exception:
                        pass
                    try:
                        self._refresh_results_text_from_current_state()
                    except Exception:
                        pass
            except Exception:
                pass
            ok = False
            if not is_autosave:
                try:
                    self._training_allowed = True
                except Exception:
                    pass
            if (not is_autosave) and hasattr(self, "feedback_manager") and self.feedback_manager:
                try:
                    ok_json, _json_out = analysis_to_training_json(self.current_image_path, data)
                    if ok_json:
                        self.results_text_edit.append("✅ Ενημερώθηκαν δεδομένα εκπαίδευσης (radiographs JSON)")
                except Exception:
                    pass
                prev_cnt = 0
                thr = 0
                try:
                    prev_cnt = int(getattr(self.feedback_manager, "feedback_count", 0) or 0)
                    thr = int(getattr(self.feedback_manager, "feedback_threshold", 0) or 0)
                except Exception:
                    prev_cnt = 0
                    thr = 0
                skip_feedback = False
                try:
                    src_path = str(self.current_image_path or "")
                    p = Path(src_path)
                    parts = [x.lower() for x in p.parts]
                    pid = None
                    if "radiographs" in parts:
                        idx = parts.index("radiographs")
                        if idx + 1 < len(p.parts):
                            pid = str(p.parts[idx + 1]).strip()
                    if pid:
                        holdout_cfg = ensure_holdout_config(self.project_root, ratio=0.15, seed=42)
                        holdout_ids = holdout_cfg.get("patient_ids", []) if isinstance(holdout_cfg, dict) else []
                        holdout_set = {str(x).strip() for x in (holdout_ids or []) if str(x).strip()}
                        if pid in holdout_set:
                            skip_feedback = True
                except Exception:
                    skip_feedback = False
                if skip_feedback:
                    ok = False
                    self.results_text_edit.append("ℹ️ Παράλειψη δείγματος toothdet/toothcls (holdout ασθενής).")
                else:
                    ok = bool(self.feedback_manager.save_feedback(self.current_image_path, data))
                if ok:
                    try:
                        cnt = int(prev_cnt) + 1
                        if thr > 0:
                            self.results_text_edit.append(f"✅ Καταγράφηκε δείγμα εκπαίδευσης (toothdet/toothcls) — {cnt}/{thr}")
                        else:
                            self.results_text_edit.append("✅ Καταγράφηκε δείγμα εκπαίδευσης (toothdet/toothcls)")
                    except Exception:
                        self.results_text_edit.append("✅ Καταγράφηκε δείγμα εκπαίδευσης (toothdet/toothcls)")
                
                # --- ACTIVE LEARNING LOGGING ---
                try:
                    from app.ai.active_learning import FeedbackLogger
                    db_path = os.path.join(str(self.project_root), "data", "ai_feedback.db")
                    logger = FeedbackLogger(db_path)
                    original_ai = getattr(self, "_pipeline_pre_save_baseline", None)
                    if isinstance(original_ai, dict) and original_ai:
                        logger.log_diff(self.current_image_path, original_ai, data)
                except Exception as e:
                    print(f"Active Learning Error: {e}")
                # -------------------------------

                else:
                    self.results_text_edit.append("⚠️ Δεν καταγράφηκε δείγμα εκπαίδευσης")
            elif not is_autosave:
                self.results_text_edit.append("ℹ️ Δεν καταγράφηκε δείγμα εκπαίδευσης (δεν έχει επιβεβαιωθεί η ανάλυση).")
        except Exception:
            if not is_autosave:
                self.results_text_edit.append("⚠️ Σφάλμα καταγραφής δείγματος εκπαίδευσης")

        try:
            if bool(getattr(self, "_save_silent", False)):
                self._save_silent = False
                self._save_silent_notes = ""
        except Exception:
            pass
        try:
            if not is_autosave:
                self._auto_pipeline_after_save(data)
        except Exception:
            pass

    def save_to_history(self, data, notes=""):
        if not self.origin_patient_id or not self.current_image_path:
            return False
            
        try:
            conn_name = f"history_insert_{uuid.uuid4().hex}"
            db = QSqlDatabase.addDatabase("QSQLITE", conn_name)
            db_path = os.path.join(str(getattr(self, "project_root", "") or ""), "data", "patients.db")
            db.setDatabaseName(db_path)
            if not db.open():
                try:
                    print(f"History save error: {db.lastError().text()}")
                except Exception:
                    pass
                try:
                    QSqlDatabase.removeDatabase(conn_name)
                except Exception:
                    pass
                return False

            q_pragma = None
            try:
                q_pragma = QSqlQuery(db)
                q_pragma.exec("PRAGMA journal_mode=WAL")
                q_pragma.exec("PRAGMA busy_timeout=10000")
            except Exception:
                pass

            query = QSqlQuery(db)
            query.prepare(
                """
                INSERT INTO radiograph_history (patient_id, image_path, timestamp, action_type, notes, analysis_data)
                VALUES (?, ?, ?, ?, ?, ?)
                """
            )

            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            json_str = json.dumps(data, ensure_ascii=False)

            query.addBindValue(self.origin_patient_id)
            query.addBindValue(self.current_image_path)
            query.addBindValue(timestamp)
            query.addBindValue("Manual Correction")
            query.addBindValue(notes)
            query.addBindValue(json_str)

            success = False
            last_err = ""
            for _ in range(10):
                if query.exec():
                    success = True
                    break
                try:
                    last_err = str(query.lastError().text() or "")
                except Exception:
                    last_err = ""
                le = last_err.lower()
                if ("locked" in le) or ("busy" in le) or ("fetch row" in le) or ("unable to fetch row" in le):
                    try:
                        QThread.msleep(250)
                    except Exception:
                        pass
                    continue
                break

            try:
                query.finish()
                query.clear()
                del query
            except Exception:
                pass
            try:
                if q_pragma is not None:
                    q_pragma.finish()
                    q_pragma.clear()
                    del q_pragma
            except Exception:
                pass
            try:
                db.close()
            except Exception:
                pass
            try:
                del db
            except Exception:
                pass
            try:
                QSqlDatabase.removeDatabase(conn_name)
            except Exception:
                pass

            if not success:
                print(f"History save error: {last_err}")
            return bool(success)
        except Exception as e:
            print(f"History exception: {e}")
            return False

    def show_history_dialog(self):
        if not self.origin_patient_id:
            QMessageBox.warning(self, "Προσοχή", "Δεν έχει οριστεί ασθενής για αυτή την προβολή.")
            try:
                self._announce_action_failed("Ιστορικό: δεν υπάρχει ορισμένος ασθενής")
            except Exception:
                pass
            return

        dialog = QDialog(self)
        dialog.setWindowTitle("Ιστορικό Ακτινογραφίας")
        dialog.resize(800, 600)
        layout = QVBoxLayout(dialog)
        
        list_widget = QListWidget()
        list_widget.setWordWrap(True)
        # Style for better readability
        list_widget.setStyleSheet("QListWidget::item { border-bottom: 1px solid #ccc; padding: 10px; }")
        layout.addWidget(list_widget)
        
        conn_name = ""
        db = None
        query = None
        q_pragma = None
        try:
            conn_name = f"history_read_{uuid.uuid4().hex}"
            db = QSqlDatabase.addDatabase("QSQLITE", conn_name)
            db_path = os.path.join(str(getattr(self, "project_root", "") or ""), "data", "patients.db")
            db.setDatabaseName(db_path)
            if not db.open():
                list_widget.addItem(f"Σφάλμα σύνδεσης: {db.lastError().text()}")
                return
            try:
                q_pragma = QSqlQuery(db)
                q_pragma.exec("PRAGMA journal_mode=WAL")
                q_pragma.exec("PRAGMA busy_timeout=10000")
            except Exception:
                pass

            query = QSqlQuery(db)
            # Filter by patient
            sql = "SELECT timestamp, action_type, notes, analysis_data, image_path FROM radiograph_history WHERE patient_id=?"
            params = [self.origin_patient_id]
            
            # If we want to show history for ALL images of this patient, we remove the image_path filter
            # The user asked for "patient history and progress tracking", so seeing all images is better.
            # We can label which image it was.
            
            # If the user is viewing a specific image, maybe they want history for THAT image?
            # Let's show ALL but highlight if it matches current.
                
            sql += " ORDER BY timestamp DESC"
            
            query.prepare(sql)
            for p in params:
                query.addBindValue(p)

            ok = False
            last_err = ""
            for _ in range(10):
                if query.exec():
                    ok = True
                    break
                try:
                    last_err = str(query.lastError().text() or "")
                except Exception:
                    last_err = ""
                le = last_err.lower()
                if ("locked" in le) or ("busy" in le) or ("fetch row" in le) or ("unable to fetch row" in le):
                    try:
                        QThread.msleep(250)
                    except Exception:
                        pass
                    continue
                break

            if ok:
                while query.next():
                    ts = query.value(0)
                    action = query.value(1)
                    note = query.value(2)
                    json_data_str = query.value(3)
                    img_path = query.value(4)
                    
                    img_name = os.path.basename(img_path) if img_path else "?"
                    
                    # Parse JSON for details
                    details = ""
                    try:
                        data = json.loads(json_data_str)
                        if 'fdi' in data and 'statuses' in data:
                            fdis = data.get('fdi', [])
                            statuses_list = data.get('statuses', [])
                            radiograph_summary = data.get('radiograph_summary')
                            
                            # Count interesting items
                            teeth_count = len(fdis)
                            missing_count = 0
                            try:
                                for i in range(min(len(fdis), len(statuses_list))):
                                    st = statuses_list[i] if i < len(statuses_list) else []
                                    st = st if isinstance(st, list) else []
                                    if any("ελλείπ" in str(x).lower() for x in st if str(x).strip()):
                                        missing_count += 1
                            except Exception:
                                missing_count = 0
                            present_count = max(0, int(teeth_count) - int(missing_count))
                            findings = []
                            
                            for i, fdi in enumerate(fdis):
                                stats = statuses_list[i] if i < len(statuses_list) else []
                                if stats:
                                    findings.append(f"  • Δόντι {fdi}: {', '.join(stats)}")
                                    
                            details = f"Ακτινογραφία: {img_name}\nΠαρόντα: {present_count} | Ελλείποντα: {missing_count} | Σύνολο annotations: {teeth_count}"
                            if isinstance(radiograph_summary, dict) and radiograph_summary.get("text"):
                                details += "\nΣύνοψη:\n" + str(radiograph_summary.get("text"))
                            if findings:
                                details += "\nΕυρήματα:\n" + "\n".join(findings)
                    except Exception as e:
                        details = f"(Σφάλμα ανάγνωσης δεδομένων: {e})"

                    item_text = f"📅 {ts} | {action}\n"
                    if note:
                        item_text += f"📝 Σημειώσεις: {note}\n"
                    item_text += f"🔍 {details}"
                    
                    item = QListWidgetItem(item_text)
                    list_widget.addItem(item)
            else:
                list_widget.addItem(f"Σφάλμα φόρτωσης: {last_err or (query.lastError().text() if query is not None else '')}")
                
        except Exception as e:
            list_widget.addItem(f"Σφάλμα: {e}")
        finally:
            try:
                if query is not None:
                    query.finish()
                    query.clear()
            except Exception:
                pass
            try:
                if q_pragma is not None:
                    q_pragma.finish()
                    q_pragma.clear()
            except Exception:
                pass
            try:
                if db is not None:
                    db.close()
            except Exception:
                pass
            try:
                if conn_name:
                    try:
                        del query
                    except Exception:
                        pass
                    try:
                        del q_pragma
                    except Exception:
                        pass
                    try:
                        del db
                    except Exception:
                        pass
                    try:
                        import gc
                        gc.collect()
                    except Exception:
                        pass
                    QSqlDatabase.removeDatabase(conn_name)
            except Exception:
                pass
            
        btn = QPushButton("Κλείσιμο")
        btn.clicked.connect(dialog.accept)
        layout.addWidget(btn)
        
        dialog.exec()
        try:
            self._announce_action_done("Ιστορικό: ολοκληρώθηκε")
        except Exception:
            pass

    def compute_golden_ratio_metrics(self, results):
        phi = (1 + 5 ** 0.5) / 2
        boxes = results.get("boxes", []) or []
        fdis = results.get("fdi", []) or []
        generated = results.get("generated", []) or []

        def _to_fdi(v):
            if v is None:
                return None
            s = str(v).strip()
            if not s.isdigit() or len(s) != 2:
                return None
            return int(s)

        scale_x = self.pixel_to_mm_scale_x or self.pixel_to_mm_scale
        unit = "mm" if scale_x else "px"
        widths = {}

        for i, (box, fdi) in enumerate(zip(boxes, fdis)):
            # Skip generated (missing/ghost) teeth for Golden Ratio
            is_gen = generated[i] if i < len(generated) else False
            if is_gen:
                continue

            f = _to_fdi(fdi)
            if not f:
                continue
            try:
                w = float(box[2]) - float(box[0])
            except Exception:
                continue
            if w <= 0:
                continue
            if scale_x:
                try:
                    w = w / float(scale_x)
                except Exception:
                    pass
            widths[f] = w

        pairs = [
            ("Άνω δεξιά", 11, 12),
            ("Άνω δεξιά", 12, 13),
            ("Άνω αριστερά", 21, 22),
            ("Άνω αριστερά", 22, 23),
        ]

        ratio_rows = []
        deviations = []
        for side, a, b in pairs:
            if a not in widths or b not in widths:
                continue
            r = widths[a] / widths[b] if widths[b] else None
            if not r or not math.isfinite(r) or r <= 0:
                continue
            dev = abs(r - phi) / phi * 100.0
            deviations.append(dev)
            ratio_rows.append(f"{side}: {a}/{b} = {r:.3f} ({unit}), απόκλιση {dev:.1f}%")

        if not ratio_rows:
            return None

        mean_dev = sum(deviations) / len(deviations) if deviations else None
        return {"phi": float(phi), "unit": unit, "ratios": ratio_rows, "mean_deviation_pct": mean_dev, "title": "Αναλογία Πλάτους (Χρυσή Τομή)"}

    def compute_tooth_summary_from_statuses(self, statuses_list):
        status_category = {
            "Απόστημα": "Παθολογία",
            "Κύστη": "Παθολογία",
            "Καριές": "Παθολογία",
            "Περιοδοντίτιδα": "Παθολογία",
            "Κάταγμα": "Παθολογία",
            "Ριζικό υπόλειμμα": "Παθολογία",
            "Αιμορραγία": "Παθολογία",
            "Θύλακας": "Παθολογία",
            "Υποχώρηση ούλων": "Παθολογία",
            "Κινητικότητα": "Παθολογία",
            "Έγκλειστο": "Θέση/Ανατομία",
            "Ενδοδοντική": "Θεραπεία",
            "Έμφραξη": "Θεραπεία",
            "Στεφάνη": "Αποκατάσταση",
            "Γέφυρα": "Αποκατάσταση",
            "Εμφύτευμα": "Αποκατάσταση",
            "Ορθοδοντικό": "Θεραπεία",
            "Εξαγωγή": "Θεραπεία",
            "Αμφίβολο": "Αμφίβολο",
            "Υγιές": "Υγιές",
        }

        status_severity = {
            "Απόστημα": 4,
            "Κύστη": 4,
            "Κάταγμα": 3,
            "Ριζικό υπόλειμμα": 3,
            "Περιοδοντίτιδα": 3,
            "Καριές": 2,
            "Εξαγωγή": 2,
            "Θύλακας": 2,
            "Αιμορραγία": 2,
            "Υποχώρηση ούλων": 2,
            "Κινητικότητα": 2,
            "Έγκλειστο": 1,
            "Ενδοδοντική": 1,
            "Ορθοδοντικό": 1,
            "Αμφίβολο": 1,
            "Έμφραξη": 0,
            "Στεφάνη": 0,
            "Γέφυρα": 0,
            "Εμφύτευμα": 0,
            "Υγιές": 0,
        }

        def severity_label(rank):
            if rank >= 4:
                return "Κρίσιμο"
            if rank == 3:
                return "Υψηλό"
            if rank == 2:
                return "Μέτριο"
            if rank == 1:
                return "Χαμηλό"
            return "Χωρίς ένδειξη"

        out = []
        for statuses in statuses_list or []:
            statuses = statuses if isinstance(statuses, list) else []
            groups = {}
            sev_rank = 0
            for nm in statuses:
                cat = status_category.get(nm, "Άλλο")
                groups.setdefault(cat, [])
                groups[cat].append({"name": nm, "score": None})
                sev_rank = max(sev_rank, int(status_severity.get(nm, 0)))

            parts = []
            for cat in ["Παθολογία", "Θεραπεία", "Αποκατάσταση", "Θέση/Ανατομία", "Αμφίβολο", "Υγιές", "Άλλο"]:
                if cat not in groups:
                    continue
                txt = ", ".join([str(it["name"]) for it in groups[cat]])
                parts.append(f"{cat}: {txt}")

            text = " | ".join(parts) if parts else "Υγιές"
            out.append({"text": text, "severity": severity_label(sev_rank), "severity_rank": int(sev_rank), "groups": groups})

        return out

    def compute_radiograph_summary(self, fdis, tooth_summary_list):
        if not isinstance(tooth_summary_list, list) or not tooth_summary_list:
            return None
        if not isinstance(fdis, list):
            fdis = []

        buckets = {"Κρίσιμο": [], "Υψηλό": [], "Μέτριο": [], "Χαμηλό": [], "Χωρίς ένδειξη": []}
        counts = {k: 0 for k in buckets}

        for i, sm in enumerate(tooth_summary_list):
            if not isinstance(sm, dict):
                continue
            sev = sm.get("severity") or "Χωρίς ένδειξη"
            if sev not in buckets:
                sev = "Χωρίς ένδειξη"
            fdi = fdis[i] if i < len(fdis) else "?"
            fdi_s = str(fdi)
            if fdi_s.endswith("?") and len(fdi_s) > 2:
                fdi_s = "?"
            if fdi_s == "?":
                continue
            counts[sev] += 1
            buckets[sev].append(fdi_s)

        text = (
            f"Κρίσιμο: {counts['Κρίσιμο']} | "
            f"Υψηλό: {counts['Υψηλό']} | "
            f"Μέτριο: {counts['Μέτριο']} | "
            f"Χαμηλό: {counts['Χαμηλό']} | "
            f"Χωρίς ένδειξη: {counts['Χωρίς ένδειξη']}"
        )

        flags = []
        if buckets["Κρίσιμο"]:
            flags.append("Κρίσιμα δόντια: " + ", ".join(buckets["Κρίσιμο"]))
        if buckets["Υψηλό"]:
            flags.append("Υψηλής προτεραιότητας: " + ", ".join(buckets["Υψηλό"]))
        if buckets["Μέτριο"]:
            flags.append("Μέτριας προτεραιότητας: " + ", ".join(buckets["Μέτριο"]))

        if flags:
            text = text + "\n" + "\n".join(flags)

        return {"counts": counts, "buckets": buckets, "text": text}

    def delete_selected_items_action(self):
        """Called by the toolbar button."""
        # Check if we have a scene
        if not self.scene:
            return

        # 1. Try to delete selected items first
        selected_items = self.scene.selectedItems()
        if selected_items:
            # Logic to delete items
            items_deleted = False
            for item in selected_items:
                # We only want to delete editable items (Rects, Text)
                if isinstance(item, (EditableRectItem, EditableTextItem)):
                    # Remove from scene
                    self.scene.removeItem(item)
                    items_deleted = True
                    
                    # If it's a rect item, check for associated text item
                    if hasattr(item, "text_item") and item.text_item:
                         try:
                             if item.text_item.scene() == self.scene:
                                 self.scene.removeItem(item.text_item)
                         except Exception:
                             pass
            
            if items_deleted:
                # Trigger recalculation if needed
                if hasattr(self, "debounced_recalculate_fdi"):
                    self.debounced_recalculate_fdi()
                elif hasattr(self, "recalculate_fdi"):
                    self.recalculate_fdi()
            
            return # Done, items deleted

        # 2. If no items selected, offer to delete the analysis
        # Check if clear_analysis_button is enabled (proxy for "has analysis")
        can_clear = False
        if hasattr(self, "clear_analysis_button") and self.clear_analysis_button.isEnabled():
            can_clear = True
        elif self.analysis_results is not None:
             can_clear = True

        if can_clear:
            reply = QMessageBox.question(
                self, 
                "Διαγραφή Ανάλυσης", 
                "Δεν έχουν επιλεγεί αντικείμενα. Θέλετε να διαγράψετε ολόκληρη την ανάλυση;",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.clear_analysis()
        else:
            # Inform user nothing to delete
            # Optional: Don't show popup if nothing to delete to avoid annoyance, 
            # but user said "button doesn't respond", so feedback is good.
            QMessageBox.information(self, "Πληροφορία", "Δεν υπάρχουν επιλεγμένα αντικείμενα ή ενεργή ανάλυση για διαγραφή.")

    def _on_delete_current_radiograph_clicked(self):
        if not getattr(self, "current_image_path", None):
            try:
                QMessageBox.information(self, "Πληροφορία", "Δεν υπάρχει ενεργή ακτινογραφία για διαγραφή.")
            except Exception:
                pass
            return
        img_path = str(self.current_image_path)
        try:
            base = os.path.splitext(img_path)[0]
            json_path = base + "_analysis.json"
        except Exception:
            json_path = None
        try:
            reply = QMessageBox.question(
                self,
                "Διαγραφή Πανοραμικής",
                f"Η πανοραμική {os.path.basename(img_path)} θα διαγραφεί λόγω κακής ποιότητας και δεν θα εμφανίζεται ως ελλιπής ανάλυση.\n\nΘέλετε να συνεχίσετε;",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
        except Exception:
            reply = QMessageBox.StandardButton.No
        if reply != QMessageBox.StandardButton.Yes:
            return
        try:
            meta = {
                "deleted": True,
                "bad_quality": True,
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "image_path": img_path,
            }
            if json_path:
                try:
                    existing = None
                    if os.path.exists(json_path):
                        with open(json_path, "r", encoding="utf-8", errors="ignore") as f:
                            existing = json.load(f)
                    if isinstance(existing, dict):
                        existing.update(meta)
                        payload = existing
                    else:
                        payload = meta
                except Exception:
                    payload = meta
                with open(json_path, "w", encoding="utf-8") as f:
                    json.dump(payload, f, ensure_ascii=False, indent=4)
        except Exception:
            pass
        try:
            if os.path.exists(img_path):
                os.remove(img_path)
        except Exception as e:
            try:
                QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία διαγραφής ακτινογραφίας:\n{e}")
            except Exception:
                pass
            return
        try:
            self.results_text_edit.append("🗑 Η πανοραμική διαγράφηκε και σημάνθηκε ως κακής ποιότητας.")
        except Exception:
            pass
        try:
            self.delete_image_button.setEnabled(False)
        except Exception:
            pass
        try:
            self._announce_action_done("Διαγραφή πανοραμικής")
        except Exception:
            pass

    def clear_analysis(self):
        """
        Removes all analysis artifacts (boxes, labels) from the scene,
        resets the results text and internal state, AND deletes the saved JSON file.
        """
        if not self.scene: return

        # Use centralized removal to catch ghosts and everything
        self._clear_analysis_items()
            
        # Clear references
        self.jaw_separator_line = None
        self.vertical_separator_line = None
        self.zone_line_1 = None
        self.zone_line_2 = None
            
        # Clear Text
        self.results_text_edit.clear()
        self.results_text_edit.append(f"Εικόνα: {os.path.basename(str(self.current_image_path or ''))}")
        self.results_text_edit.append("Η ανάλυση διαγράφηκε.")
        
        # Restore Calibration Info in Text if available
        if self.pixel_to_mm_scale_x or self.pixel_to_mm_scale_y:
            self.results_text_edit.append("\n📏 Βαθμονόμηση:")
            if self.pixel_to_mm_scale_x:
                self.results_text_edit.append(f"X Scale: {self.pixel_to_mm_scale_x:.4f} px/mm")
            if self.pixel_to_mm_scale_y:
                self.results_text_edit.append(f"Y Scale: {self.pixel_to_mm_scale_y:.4f} px/mm")
        elif self.pixel_to_mm_scale:
            self.results_text_edit.append(f"\n📏 Βαθμονόμηση: {self.pixel_to_mm_scale:.4f} px/mm")
        
        # Reset State
        self.analysis_results = None
        self.raw_analysis_results = None
        self.box_items = [] # If used elsewhere
        
        # Update UI
        self.export_button.setEnabled(False)
        try:
            if hasattr(self, "analysis_text_button") and self.analysis_text_button:
                self.analysis_text_button.setEnabled(False)
        except Exception:
            pass
        self.save_analysis_button.setEnabled(False)
        self.clear_analysis_button.setEnabled(False)
        
        # CRITICAL FIX: Mark analysis as deleted instead of removing file
        # This prevents auto-workflow from triggering on reload
        if self.current_image_path:
            try:
                base = os.path.splitext(self.current_image_path)[0]
                json_path = base + "_analysis.json"
                
                # Write "deleted" marker
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump({
                        "deleted": True, 
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                        "image_path": self.current_image_path
                    }, f, indent=4)
                    
                print(f"Marked analysis as deleted: {json_path}")
            except Exception as e:
                print(f"Error marking analysis deleted: {e}")

        try:
            self._announce_action_done("Διαγραφή ανάλυσης")
        except Exception:
            pass
        
        # Save the empty state (optional, or let user click save)
        # self.save_edited_results() 
        
        

    def on_training_triggered(self, message):
        self.results_text_edit.append(f"\n🚀 {message}")
        try:
            self._append_comm("Σύστημα", message)
        except Exception:
            pass
        try:
            self._training_started_at = time.perf_counter()
        except Exception:
            self._training_started_at = None

        if hasattr(self, "training_worker") and self.training_worker:
            self._auto_train_pending = True
            self.results_text_edit.append("⚠️ Η εκπαίδευση είναι ήδη σε εξέλιξη. Προγραμματίστηκε επόμενη εκπαίδευση.")
            return
        try:
            if bool(getattr(self, "_autosave_in_progress", False)):
                self._auto_train_pending = True
                self.results_text_edit.append("⏳ Αναμονή ολοκλήρωσης auto-save πριν την εκπαίδευση...")
                qt = QTimer(self)
                qt.setSingleShot(True)
                qt.timeout.connect(lambda: self.on_training_triggered("Ξεκινάει αυτόματη εκπαίδευση (μετά το autosave)..."))
                qt.start(2000)
                return
        except Exception:
            pass

        try:
            create_toothdet_splits_if_missing(self.project_root)
        except Exception:
            pass
        stats = dataset_quality_check_toothdet(self.project_root)
        self._auto_train_data_stats = stats
        if not stats.get("ok", False):
            self.results_text_edit.append(f"❌ Δεν ξεκίνησε εκπαίδευση: {stats.get('reasons')}")
            try:
                self._announce_action_failed(f"Εκπαίδευση μοντέλου: {stats.get('reasons')}")
            except Exception:
                pass
            return

        params = choose_training_params(stats)

        self._auto_train_params = params
        run_name = "toothdet_autotrain_" + datetime.now().strftime("%Y%m%d_%H%M%S")
        self._auto_train_run_name = run_name

        self.results_text_edit.append(f"⏳ Εκκίνηση αυτόματης εκπαίδευσης: {run_name}")
        self.results_text_edit.append(f"- epochs={params.get('epochs')} batch={params.get('batch')} imgsz={params.get('imgsz')} lr={params.get('lr0')}")

        self.training_thread = QThread()
        base_model = None
        try:
            base_model = get_current_model(self.project_root, "toothdet")
        except Exception:
            base_model = None
        self.training_worker = ToothDetTrainingWorker(
            project_root=self.project_root,
            run_name=run_name,
            epochs=params.get("epochs", 30),
            batch_size=params.get("batch", 4),
            imgsz=params.get("imgsz", 640),
            lr0=params.get("lr0"),
            model_path=base_model,
        )
        self.training_worker.moveToThread(self.training_thread)

        self.training_thread.started.connect(self.training_worker.run)
        self.training_worker.log_message.connect(self.results_text_edit.append)
        try:
            self.training_worker.progress.connect(self._training_ui_set_progress)
        except Exception:
            pass
        self.training_worker.results.connect(self.on_training_results)
        self.training_worker.finished.connect(self.training_thread.quit)
        self.training_worker.finished.connect(self.training_worker.deleteLater)
        self.training_worker.finished.connect(self.on_training_finished)
        self.training_thread.finished.connect(self.training_thread.deleteLater)

        try:
            self._training_ui_show(f"Εκπαίδευση ToothDet: {run_name}")
        except Exception:
            pass
        self.training_thread.start()

    def on_training_results(self, res):
        if not self.isVisible(): return
        try:
            if getattr(self, "results_text_edit", None) is None: return
            # Check if C++ object deleted using sip (if imported) or just try/except
            # Since sip might not be imported, rely on try/except RuntimeError
            
            if res.get("success"):
                metrics = res.get("metrics", {})
                msg = "📊 Αποτελέσματα Βελτίωσης:\n"
                found_metrics = False
                for k, v in metrics.items():
                    # Prioritize mAP and Precision/Recall
                    if "mAP50" in k or "precision" in k.lower() or "recall" in k.lower():
                        # Clean up key names for display
                        key_display = k.replace("metrics/", "").replace("(B)", "").strip()
                        msg += f"- {key_display}: {v:.1%}\n"
                        found_metrics = True
                
                if not found_metrics:
                    msg += "- Η εκπαίδευση ολοκληρώθηκε, αλλά δεν βρέθηκαν μετρήσεις.\n"
                    
                try:
                    self.results_text_edit.append(msg)
                except RuntimeError:
                    pass
                
                try:
                    self._append_comm("Σύστημα", msg.strip())
                except Exception:
                    pass
            else:
                try:
                    self.results_text_edit.append(f"❌ Σφάλμα κατά την εκπαίδευση: {res.get('error_message')}")
                except RuntimeError:
                    pass
                try:
                    self._append_comm("Σύστημα", f"Σφάλμα εκπαίδευσης: {res.get('error_message')}")
                except Exception:
                    pass
        except Exception:
            pass

    def on_training_finished(self):
        try:
            if getattr(self, "results_text_edit", None) is not None:
                self.results_text_edit.append("✅ Η αυτόματη εκπαίδευση ολοκληρώθηκε!")
        except RuntimeError:
            pass
        except Exception:
            pass
            
        try:
            self._training_ui_set_progress(100)
        except Exception:
            pass
        try:
            try:
                started_at = getattr(self, "_training_started_at", None)
                elapsed = (time.perf_counter() - float(started_at)) * 1000.0 if started_at else None
            except Exception:
                elapsed = None
            self._announce_action_done("Εκπαίδευση μοντέλου", elapsed_ms=elapsed)
        except Exception:
            pass
        try:
            if bool(getattr(self, "_notify_training_finish", False)):
                msg = "Η εκπαίδευση ολοκληρώθηκε. Θέλεις να κάνω ανάλυση ξανά με το νέο μοντέλο;"
                self._append_comm("AI", msg)
        except Exception:
            pass

        run_name = self._auto_train_run_name
        run_dir = os.path.join(self.project_root, "runs", "detect", str(run_name)) if run_name else None
        best_pt = os.path.join(run_dir, "weights", "best.pt") if run_dir else None

        versioned = None
        if run_dir and best_pt and os.path.exists(best_pt):
            versioned = version_trained_model(self.project_root, run_dir, str(run_name))

        metrics = {}
        if run_dir:
            metrics = parse_yolo_results_csv(os.path.join(run_dir, "results.csv"))

        report_path = None
        try:
            report_path = write_training_report(
                self.project_root,
                str(run_name) if run_name else "stoma_autotrain",
                self._auto_train_params or {},
                self._auto_train_data_stats or {},
                metrics or {},
                versioned or best_pt,
            )
        except Exception:
            report_path = None

        chosen = None
        if versioned and os.path.exists(versioned):
            chosen = versioned
        elif best_pt and os.path.exists(best_pt):
            chosen = best_pt

        kind = "toothdet" if str(run_name or "").lower().startswith("toothdet_") else "detect"
        secured = None
        if chosen and os.path.exists(chosen):
            try:
                secured = register_model(
                    self.project_root,
                    chosen,
                    kind=kind,
                    run_name=str(run_name or ""),
                    metrics=metrics or {},
                    params=self._auto_train_params or {},
                    data_stats=self._auto_train_data_stats or {},
                    run_dir=run_dir,
                )
            except Exception:
                secured = None

        promoted = secured if secured and os.path.exists(secured) else (chosen if chosen and os.path.exists(chosen) else None)
        promote_ok = True
        if str(kind) == "toothdet" and promoted:
            try:
                mp = None
                try:
                    mp = float((metrics or {}).get("metrics/mAP50(B)"))
                except Exception:
                    mp = None
                if mp is not None and float(mp) < 0.10:
                    promote_ok = False
                else:
                    promote_ok = bool(self._toothdet_model_usable(promoted))
            except Exception:
                promote_ok = False

        if promoted and promote_ok:
            if str(kind) == "toothdet":
                try:
                    self.toothdet_model_path = promoted
                except Exception:
                    pass
                try:
                    self.results_text_edit.append("🔒 Το νέο toothdet μοντέλο αποθηκεύτηκε/ορίστηκε.")
                except Exception:
                    pass
                try:
                    self._append_comm("Σύστημα", "Ορίστηκε νέο toothdet μοντέλο.")
                except Exception:
                    pass
            else:
                try:
                    self.model_path = promoted
                    self.detect_model_path = promoted
                except Exception:
                    pass
                try:
                    self.results_text_edit.append("🔒 Το νέο μοντέλο αποθηκεύτηκε με ασφάλεια και φορτώθηκε.")
                except Exception:
                    pass
                try:
                    self._append_comm("Σύστημα", "Το νέο μοντέλο αποθηκεύτηκε με ασφάλεια και φορτώθηκε.")
                except Exception:
                    pass
        elif promoted and not promote_ok:
            try:
                self.results_text_edit.append("⚠️ Το νέο toothdet μοντέλο αποθηκεύτηκε αλλά δεν ενεργοποιήθηκε (χαμηλή αξιολόγηση).")
            except Exception:
                pass
            try:
                self._append_comm("Σύστημα", "Το νέο toothdet μοντέλο αποθηκεύτηκε αλλά δεν ενεργοποιήθηκε (χαμηλή αξιολόγηση).")
            except Exception:
                pass

        try:
            prefs = AppPrefs(Path(self.project_root))
            if str(kind) == "toothdet":
                if promoted and promote_ok:
                    prefs.set("selected_toothdet_model_path", promoted)
            else:
                if promoted and promote_ok:
                    prefs.set("selected_detect_model_path", promoted)
                    prefs.set("selected_model_path", promoted)
        except Exception:
            pass

        if report_path:
            try:
                self.results_text_edit.append(f"🧾 Αναφορά εκπαίδευσης: {report_path}")
            except Exception:
                pass
            try:
                self._append_comm("Σύστημα", f"Δημιουργήθηκε αναφορά εκπαίδευσης: {os.path.basename(str(report_path))}")
            except Exception:
                pass

        self.training_worker = None

        if getattr(self, "_auto_train_pending", False):
            self._auto_train_pending = False
            self.on_training_triggered("Ξεκινάει αυτόματη εκπαίδευση (queued)...")
        try:
            self._training_ui_hide_if_idle()
        except Exception:
            pass
        try:
            self._kick_auto_pipeline_queue()
        except Exception:
            pass

    def toggle_all_annotations_visibility(self):
        """Toggle visibility of ALL annotations (boxes, lines, zones, grid)."""
        should_hide = self.hide_all_annotations_button.isChecked()
        
        # 1. Toggle Boxes (uses existing logic)
        self.boxes_visible = not should_hide
        for item in self.analysis_results_items:
            try:
                item.setVisible(self.boxes_visible)
            except Exception:
                pass
                
        # 2. Toggle Grid (uses existing logic)
        if hasattr(self, 'grid_visible'):
            # If we are hiding, we force hide. If we are showing, we restore previous state?
            # Simpler: just set visibility based on the button
            pass # TODO: more complex logic if we want to restore exact previous state
            
        # 3. Toggle Jaw Lines
        if self.jaw_separator_line:
            self.jaw_separator_line.setVisible(not should_hide)
        if self.vertical_separator_line:
            self.vertical_separator_line.setVisible(not should_hide)
        if self._spee_lower_overlay_item:
            self._spee_lower_overlay_item.setVisible(not should_hide)
            
        # 4. Toggle Zone Lines
        if self.zone_line_1:
            self.zone_line_1.setVisible(not should_hide)
        if self.zone_line_2:
            self.zone_line_2.setVisible(not should_hide)
            
        # 5. Toggle FDI Items
        for item in self._fdi_item_cache.values():
             try:
                 item.setVisible(not should_hide)
             except:
                 pass

        if self.scene():
            self.scene().update()

    def toggle_box_visibility(self):
        self.view_mode = 0 if int(getattr(self, "view_mode", 1) or 1) == 1 else 1
        show_rects = (self.view_mode == 0)
        for item in self.scene.items():
            if isinstance(item, EditableRectItem):
                item.setVisible(show_rects)
            elif isinstance(item, EditableTextItem):
                item.setVisible(True)
        self.toggle_boxes_button.setText("Απόκρυψη Πλαισίων" if show_rects else "Εμφάνιση Πλαισίων")
        try:
            self._announce_action_done("Πλαίσια: εμφανή" if show_rects else "Πλαίσια: κρυμμένα")
        except Exception:
            pass

    def _apply_overlay_visibility(self, rect_item=None, text_item=None):
        try:
            show_rects = bool(int(getattr(self, "view_mode", 1) or 1) == 0)
        except Exception:
            show_rects = False
        try:
            if rect_item is not None:
                rect_item.setVisible(bool(show_rects))
        except Exception:
            pass
        try:
            if text_item is not None:
                text_item.setVisible(True)
        except Exception:
            pass

    def center_view(self):
        """
        Resets the view to fit the entire scene (image).
        """
        if self.view:
            self.view.fit_scene_in_view()
        try:
            self._announce_action_done("Κεντράρισμα πανοραμικής")
        except Exception:
            pass

    def toggle_fit_height(self):
        try:
            enabled = bool(self.fit_height_button.isChecked()) if hasattr(self, "fit_height_button") and self.fit_height_button is not None else False
        except Exception:
            enabled = False
        try:
            self.view_fit_mode = "height" if enabled else "scene"
        except Exception:
            self.view_fit_mode = "scene"
        try:
            self._save_viewer_prefs()
        except Exception:
            pass
        try:
            if self.view:
                self.view.fit_scene_in_view()
        except Exception:
            pass
        try:
            self._announce_action_done("Fit ύψος: ενεργό" if bool(enabled) else "Fit ύψος: ανενεργό")
        except Exception:
            pass

    def _update_scene_rect_for_pan(self):
        try:
            if not getattr(self, "scene", None):
                return
            pi = getattr(self, "pixmap_item", None)
            if pi is None or pi.scene() is None:
                return
            bounds = pi.mapToScene(pi.boundingRect()).boundingRect()
            if bounds.isEmpty():
                return
            if bool(getattr(self, "manual_pan_enabled", False)):
                pad_x = max(200.0, float(bounds.width()) * 0.65)
                pad_y = max(200.0, float(bounds.height()) * 0.65)
                self.scene.setSceneRect(bounds.adjusted(-pad_x, -pad_y, pad_x, pad_y))
            else:
                self.scene.setSceneRect(bounds)
        except Exception:
            pass

    def toggle_manual_pan(self):
        try:
            enabled = bool(self.pan_button.isChecked()) if hasattr(self, "pan_button") and self.pan_button is not None else False
        except Exception:
            enabled = False
        self.manual_pan_enabled = bool(enabled)
        try:
            self._update_scene_rect_for_pan()
        except Exception:
            pass
        try:
            if self.view and not bool(self.manual_pan_enabled):
                self.view.fit_scene_in_view()
        except Exception:
            pass
        try:
            self._announce_action_done("Μετακίνηση: ενεργή" if bool(enabled) else "Μετακίνηση: ανενεργή")
        except Exception:
            pass

    def _open_toolbar_layout_dialog(self):
        try:
            self._auto_assign_toolbar_object_names()
        except Exception:
            pass
        try:
            dlg = ToolbarLayoutDialog(self, self)
            dlg.exec()
        except Exception:
            pass

    def _open_screen_layout_dialog(self):
        try:
            dlg = ScreenLayoutDialog(self, self)
            dlg.exec()
        except Exception:
            pass

    def _detach_from_layout(self, w: QWidget):
        try:
            if w is None:
                return
        except Exception:
            return
        try:
            p = w.parentWidget()
        except Exception:
            p = None
        try:
            if p is not None:
                lay = p.layout()
                if lay is not None:
                    lay.removeWidget(w)
        except Exception:
            pass
        try:
            w.setParent(None)
        except Exception:
            pass

    def _apply_tools_location(self):
        w = getattr(self, "tools_container", None)
        if w is None:
            return
        loc = str(getattr(self, "tools_location", "top") or "top").strip().lower()
        loc = "bottom" if loc == "bottom" else "top"
        self.tools_location = loc
        self._detach_from_layout(w)
        if loc == "bottom":
            try:
                self.right_bottom_header_layout.insertWidget(0, w)
            except Exception:
                try:
                    self.right_bottom_header_layout.addWidget(w)
                except Exception:
                    pass
        else:
            try:
                self.right_top_layout.insertWidget(1, w)
            except Exception:
                try:
                    self.right_top_layout.addWidget(w)
                except Exception:
                    pass

    def _toggle_toolbar_reorder_mode(self):
        try:
            enabled = bool(self.toolbar_layout_button.isChecked()) if hasattr(self, "toolbar_layout_button") and self.toolbar_layout_button is not None else False
        except Exception:
            enabled = False
        self.toolbar_reorder_enabled = bool(enabled)
        try:
            self._announce_action_done("Διάταξη κουμπιών: ενεργή" if bool(enabled) else "Διάταξη κουμπιών: ανενεργή")
        except Exception:
            pass

    def _auto_assign_toolbar_object_names(self):
        try:
            for k, v in list(getattr(self, "__dict__", {}).items()):
                try:
                    if not isinstance(v, QWidget):
                        continue
                    if str(v.objectName() or "").strip():
                        continue
                    kk = str(k or "").strip()
                    if not kk:
                        continue
                    if not (kk.endswith("_button") or kk.endswith("_btn") or kk.endswith("_checkbox") or kk.endswith("_combo") or kk.endswith("_toggle")):
                        continue
                    v.setObjectName(kk)
                except Exception:
                    continue
        except Exception:
            pass

    def _on_button_row_reordered(self, key: str, order_names):
        try:
            if not isinstance(getattr(self, "_button_order_prefs", None), dict):
                self._button_order_prefs = {}
            k = str(key or "").strip() or "default"
            if not isinstance(order_names, list):
                order_names = []
            cleaned = [str(x or "").strip() for x in order_names if str(x or "").strip()]
            self._button_order_prefs[k] = cleaned
            self._save_viewer_prefs()
        except Exception:
            pass

    def toggle_crop_mode(self):
        self.is_cropping = self.crop_button.isChecked()
        if self.is_cropping:
            # Disable other modes
            try:
                if bool(getattr(self, "missing_cell_mode", False)):
                    self._set_missing_cell_mode(False)
            except Exception:
                pass
            if self.magic_wand_button.isChecked():
                self.magic_wand_button.setChecked(False)
                self.toggle_magic_wand_mode()
            if self.calibration_button.isChecked():
                self.calibration_button.setChecked(False)
                self.toggle_calibration_mode()
            self.view.setCursor(Qt.CursorShape.CrossCursor)
        else:
            self.view.setCursor(Qt.CursorShape.ArrowCursor)
            try:
                self._safe_remove_scene_item(getattr(self, "crop_selection_item", None))
            except Exception:
                pass
            self.crop_selection_item = None
        try:
            self._announce_action_done("Αποκοπή: ενεργή" if bool(getattr(self, "is_cropping", False)) else "Αποκοπή: ανενεργή")
        except Exception:
            pass

    def update_vertical_lines_geometry(self):
        """Updates the vertical span of grid lines based on horizontal lines."""
        if not self.grid_active or len(self.grid_lines_h) < 3:
            if not bool(getattr(self, "_bulk_scene_update", False)):
                self.debounced_recalculate_fdi()
            return
        
        # Sort horizontal lines by Y to identify Top, Mid, Bot
        h_lines = sorted(self.grid_lines_h, key=lambda l: l.y())
        y_top = h_lines[0].y()
        y_mid = h_lines[1].y()
        y_bot = h_lines[2].y()
        
        # Update Upper Verticals (Top to Mid)
        if hasattr(self, 'grid_lines_v_upper'):
            for v in self.grid_lines_v_upper:
                v.set_vertical_endpoints(y_top, y_mid)
        if hasattr(self, 'grid_lines_v_outer_upper'):
            for v in self.grid_lines_v_outer_upper:
                v.set_vertical_endpoints(y_top, y_mid)
            
        # Update Lower Verticals (Mid to Bot)
        if hasattr(self, 'grid_lines_v_lower'):
            for v in self.grid_lines_v_lower:
                v.set_vertical_endpoints(y_mid, y_bot)
        if hasattr(self, 'grid_lines_v_outer_lower'):
            for v in self.grid_lines_v_outer_lower:
                v.set_vertical_endpoints(y_mid, y_bot)
                
        if not bool(getattr(self, "_bulk_scene_update", False)):
            self.debounced_recalculate_fdi()
            self._schedule_layout_save()

    def _try_restore_grid_for_current_image(self) -> bool:
        try:
            path = self._layout_sidecar_path()
            if path and os.path.exists(path):
                try:
                    with open(path, "r", encoding="utf-8") as f:
                        data = json.load(f)
                except Exception:
                    data = None
                if isinstance(data, dict):
                    grid = data.get("grid")
                    if isinstance(grid, dict) and bool(grid.get("active")):
                        self._restore_grid_from_data(grid)
                        return True
        except Exception:
            pass
        try:
            key = self._get_patient_key()
            snap_by = getattr(self, "layout_snapshot_by_patient", None)
            if key != "general" and isinstance(snap_by, dict):
                snap = snap_by.get(str(key))
                if isinstance(snap, dict):
                    grid = snap.get("grid")
                    if isinstance(grid, dict) and bool(grid.get("active")):
                        self._restore_grid_from_data(grid)
                        return True
        except Exception:
            pass
        return False

    def _align_grid_to_separators(self) -> bool:
        try:
            if not bool(getattr(self, "grid_active", False)):
                return False
            if not getattr(self, "pixmap_item", None) or not getattr(self, "scene", None):
                return False
            if not getattr(self, "grid_lines_h", None):
                return False
        except Exception:
            return False

        rect = self.pixmap_item.boundingRect()
        w = float(rect.width() or 1.0)

        dx = 0.0
        dy = 0.0

        try:
            v = getattr(self, "vertical_separator_line", None)
            if self._is_scene_item_alive(v) and bool(v.isVisible()):
                target_x = float(self._get_vertical_split_x())
                gh = getattr(self, "grid_handle", None)
                current_x = float(gh.x()) if self._is_scene_item_alive(gh) else float(w / 2.0)
                dx = float(target_x - current_x)
        except Exception:
            dx = 0.0

        try:
            j = getattr(self, "jaw_separator_line", None)
            if self._is_scene_item_alive(j) and bool(j.isVisible()):
                gh = getattr(self, "grid_handle", None)
                x_ref = float(self._get_vertical_split_x()) if abs(dx) > 0.0 else (float(gh.x()) if self._is_scene_item_alive(gh) else float(w / 2.0))
                target_y = float(j.get_y_at_x(float(x_ref)))
                h_sorted = sorted([float(l.y()) for l in (getattr(self, "grid_lines_h", None) or []) if self._is_scene_item_alive(l)])
                if len(h_sorted) >= 2:
                    current_y = float(h_sorted[1]) if len(h_sorted) >= 3 else float(sum(h_sorted) / float(len(h_sorted)))
                    dy = float(target_y - current_y)
        except Exception:
            dy = 0.0

        if abs(dx) < 0.5 and abs(dy) < 0.5:
            return False

        prev_auto = bool(getattr(self, "auto_fdi_enabled", True))
        try:
            self.auto_fdi_enabled = False
        except Exception:
            pass

        try:
            for line in (getattr(self, "grid_lines_h", None) or []):
                if self._is_scene_item_alive(line):
                    line.setPos(line.pos() + QPointF(0.0, float(dy)))
        except Exception:
            pass

        for attr in ("grid_lines_v", "grid_lines_v_upper", "grid_lines_v_lower", "grid_lines_v_outer_upper", "grid_lines_v_outer_lower"):
            try:
                for line in (getattr(self, attr, None) or []):
                    if self._is_scene_item_alive(line):
                        line.setPos(line.pos() + QPointF(float(dx), 0.0))
            except Exception:
                pass

        try:
            gh = getattr(self, "grid_handle", None)
            if self._is_scene_item_alive(gh):
                gh.setPos(gh.pos() + QPointF(float(dx), float(dy)))
        except Exception:
            pass

        try:
            self.update_vertical_lines_geometry()
        except Exception:
            pass

        try:
            self.auto_fdi_enabled = prev_auto
        except Exception:
            pass
        try:
            self.recalculate_fdi()
            self._schedule_layout_save()
        except Exception:
            pass
        return True

    def _get_mm_per_px_x(self):
        try:
            v = getattr(self, "pixel_to_mm_scale_x", None)
            if v is not None:
                v = float(v)
                if v > 0:
                    return v
        except Exception:
            pass
        try:
            v = getattr(self, "pixel_to_mm_scale", None)
            if v is not None:
                v = float(v)
                if v > 0:
                    return v
        except Exception:
            pass
        return None

    def _get_mm_per_px_y(self):
        try:
            v = getattr(self, "pixel_to_mm_scale_y", None)
            if v is not None:
                v = float(v)
                if v > 0:
                    return v
        except Exception:
            pass
        try:
            v = getattr(self, "pixel_to_mm_scale", None)
            if v is not None:
                v = float(v)
                if v > 0:
                    return v
        except Exception:
            pass
        return None

    def _get_calibration_x_bounds(self):
        try:
            cl = getattr(self, "calib_line_x", None)
            if cl is None:
                return None
            if hasattr(cl, "scene") and cl.scene() != self.scene:
                return None
        except Exception:
            return None
        try:
            h1 = getattr(cl, "h1", None)
            h2 = getattr(cl, "h2", None)
            if h1 is None or h2 is None:
                return None
            p1 = h1.scenePos()
            p2 = h2.scenePos()
            x1 = float(p1.x())
            x2 = float(p2.x())
            if not (x1 == x1 and x2 == x2):
                return None
            if abs(x2 - x1) < 5.0:
                return None
            return (min(x1, x2), max(x1, x2))
        except Exception:
            return None

    def get_available_statuses(self):
        base_statuses = [
            "Τερηδόνα",
            "Σφράγισμα",
            "Απονεύρωση",
            "Εμφύτευμα",
            "Γέφυρα",
            "Στεφάνη",
            "Εγκλεισμός",
            "Ριζικό Υπόλειμμα",
            "Ελλείπον",
            "Υγιές",
        ]

        settings_file = Path("data/settings/custom_statuses.json")
        if settings_file.exists():
            try:
                with open(settings_file, "r", encoding="utf-8") as f:
                    loaded = json.load(f)
                if isinstance(loaded, list) and loaded:
                    base_statuses = list(dict.fromkeys([*loaded, *base_statuses]))
            except Exception:
                pass

        return [s for s in base_statuses if isinstance(s, str) and s.strip()]

    def get_available_statuses_grouped(self):
        statuses = self.get_available_statuses()
        categories = {
            "Παθολογία": {"Τερηδόνα", "Ριζικό Υπόλειμμα"},
            "Αποκατάσταση": {"Σφράγισμα", "Στεφάνη", "Γέφυρα"},
            "Ενδοδοντική": {"Απονεύρωση"},
            "Ανατομικό/Χειρουργικό": {"Εγκλεισμός", "Εμφύτευμα"},
            "Κατάσταση": {"Ελλείπον", "Υγιές"},
        }

        grouped = {k: [] for k in categories.keys()}
        extra = []

        for s in statuses:
            placed = False
            for cat, members in categories.items():
                if s in members:
                    grouped[cat].append(s)
                    placed = True
                    break
            if not placed:
                extra.append(s)

        if extra:
            grouped["Άλλο"] = extra

        grouped = {k: v for k, v in grouped.items() if v}
        if not grouped:
            return {"Όλα": statuses}
        return grouped

    def _status_color(self, statuses, label_text=None):
        st = [str(s).strip() for s in (statuses or []) if str(s).strip()]
        st_low = [s.lower() for s in st]

        def has_any(tokens):
            return any(t in st_low for t in tokens)

        if has_any(["ελλείπον", "missing"]):
            return QColor(200, 200, 200) # Bone/Gray for missing
        if has_any(["εγκλεισμός", "impaction", "impacted"]):
            return QColor(210, 160, 0)
        if has_any(["ριζικό υπόλειμμα", "root residue", "root"]):
            return QColor(210, 0, 120)
        if has_any(["τερηδόνα", "caries"]):
            return QColor(220, 60, 60)
        if has_any(["σφράγισμα", "filling"]):
            return QColor(50, 120, 220)
        if has_any(["απονεύρωση", "root canal", "endo"]):
            return QColor(240, 140, 0)
        if has_any(["υγιές", "healthy"]):
            return QColor(40, 170, 70)

        if label_text and isinstance(label_text, str) and "healthy" in label_text.lower():
            return QColor(40, 170, 70)

        return QColor(220, 220, 0)

    def apply_status_visuals_to_rect(self, rect_item):
        if not isinstance(rect_item, EditableRectItem):
            return

        statuses = rect_item.get_statuses() if hasattr(rect_item, "get_statuses") else []
        label_text = rect_item.get_label_text() if hasattr(rect_item, "get_label_text") else None

        if statuses == ["Manual"]:
            color = QColor(220, 220, 0)
            pen = QPen(color, 2)
            pen.setCosmetic(True)
            rect_item.setPen(pen)
            rect_item.setBrush(QBrush(QColor(0, 0, 0, 0)))
            if hasattr(rect_item, "_status_badge") and rect_item._status_badge is not None:
                rect_item._status_badge.setVisible(False)
            return

        color = self._status_color(statuses, label_text=label_text)

        pen = QPen(color, 2)
        pen.setCosmetic(True)
        
        # Bone Shadow / Missing Visuals
        is_missing = any(s.lower() in ["ελλείπον", "missing"] for s in [str(x).lower() for x in statuses])
        if is_missing:
            pen.setStyle(Qt.PenStyle.DashLine)
            pen.setWidth(2)
            # Ensure text is also visible/colored appropriately if needed
        elif len(statuses) > 1:
            pen.setStyle(Qt.PenStyle.DashLine)
            
        rect_item.setPen(pen)

        if is_missing:
             # Transparent fill for bone shadow
             brush = QBrush(QColor(0, 0, 0, 0))
        else:
             brush = QBrush(QColor(color.red(), color.green(), color.blue(), 28 if statuses else 0))
        rect_item.setBrush(brush)

        if hasattr(rect_item, "_status_badge"):
            if statuses:
                if rect_item._status_badge is None:
                    rect_item._status_badge = QGraphicsTextItem("", rect_item)
                    font = rect_item._status_badge.font()
                    font.setPointSize(7)
                    font.setBold(True)
                    rect_item._status_badge.setFont(font)
                    rect_item._status_badge.setDefaultTextColor(QColor(color.red(), color.green(), color.blue(), 180))
                    rect_item._status_badge.setZValue(50)

                if len(statuses) == 1:
                    rect_item._status_badge.setPlainText(statuses[0][:3])
                else:
                    rect_item._status_badge.setPlainText(str(len(statuses)))

                r = rect_item.rect()
                rect_item._status_badge.setPos(r.x() + 2, r.y() + 1)
                rect_item._status_badge.setVisible(True)
            else:
                if rect_item._status_badge is not None:
                    rect_item._status_badge.setVisible(False)

    def on_annotation_modified(self):
        try:
            if hasattr(self, "save_analysis_button") and self.save_analysis_button:
                self.save_analysis_button.setEnabled(True)
        except Exception:
            pass
        try:
            self._pipeline_set(
                "review",
                "Υπάρχουν αλλαγές — έτοιμο για αποθήκευση",
                self._pipeline_hint_for_step("review"),
                progress=60,
                step_status_updates={"review": "RUN", "save": "TODO"},
            )
        except Exception:
            pass
        self._sync_analysis_results_from_scene()
        try:
            self._schedule_autosave_current_analysis("διόρθωση/κατάσταση")
        except Exception:
            pass
        try:
            self._results_text_refresh_timer.start()
        except Exception:
            pass
        try:
            self._refresh_analysis_text_dialog_if_open()
        except Exception:
            pass

    def _build_analysis_text(self):
        results = getattr(self, "analysis_results", None)
        if not isinstance(results, dict):
            return ""
        boxes = results.get("boxes", []) or []
        fdis = results.get("fdi", None)
        if not isinstance(fdis, list):
            fdis = list(results.get("labels", []) or [])
        statuses_list = results.get("statuses", None)
        if not isinstance(statuses_list, list):
            statuses_list = [[] for _ in range(len(boxes))]
        notes_list = results.get("notes", None)
        if not isinstance(notes_list, list):
            notes_list = ["" for _ in range(len(boxes))]

        rows = []
        for i in range(max(len(fdis), len(boxes), len(statuses_list))):
            fdi = fdis[i] if i < len(fdis) else None
            if not fdi or str(fdi).strip() == "?":
                continue
            statuses = statuses_list[i] if i < len(statuses_list) else []
            if not isinstance(statuses, list):
                statuses = []
            statuses = [str(s).strip() for s in statuses if str(s).strip()]
            notes = notes_list[i] if i < len(notes_list) else ""
            notes = str(notes or "").strip()
            st_txt = ", ".join(statuses) if statuses else "-"
            line = f"Δόντι {fdi}: {st_txt}"
            if notes:
                line += f" | Σχόλια: {notes}"
            rows.append((str(fdi), line))

        try:
            rows.sort(key=lambda x: int(x[0]) if str(x[0]).isdigit() else 999)
        except Exception:
            rows.sort(key=lambda x: x[0])

        seen = {}
        out_lines = []
        for fdi, line in rows:
            n = int(seen.get(fdi, 0)) + 1
            seen[fdi] = n
            if n > 1:
                line = line.replace(f"Δόντι {fdi}:", f"Δόντι {fdi} (#{n}):", 1)
            out_lines.append(line)

        if not out_lines:
            return "Δεν υπάρχουν διαθέσιμες καταστάσεις για εμφάνιση."
        return "\n".join(out_lines)

    def _refresh_analysis_text_dialog_if_open(self):
        dlg = getattr(self, "_analysis_text_dialog", None)
        try:
            if dlg is None or dlg.isHidden():
                return
        except Exception:
            return
        try:
            dlg.set_text(self._build_analysis_text())
        except Exception:
            pass

    def open_analysis_text_dialog(self):
        try:
            dlg = getattr(self, "_analysis_text_dialog", None)
            if dlg is None:
                dlg = AnalysisTextDialog(self, title="Κείμενο Ανάλυσης")
                self._analysis_text_dialog = dlg
            dlg.set_text(self._build_analysis_text())
            try:
                dlg.show()
                dlg.raise_()
                dlg.activateWindow()
            except Exception:
                dlg.exec()
        except Exception:
            pass

    def _refresh_results_text_from_current_state(self):
        try:
            if not hasattr(self, "results_text_edit") or self.results_text_edit is None:
                return
        except Exception:
            return
        results = getattr(self, "analysis_results", None)
        if not isinstance(results, dict):
            return
        try:
            device = results.get('device', 'unknown')
            device_str = "GPU (CUDA)" if "cuda" in str(device).lower() else f"CPU ({device})"
        except Exception:
            device_str = "CPU (unknown)"

        try:
            self.results_text_edit.clear()
        except Exception:
            return

        try:
            self.results_text_edit.append(f"<b>Συσκευή Ανάλυσης: {device_str}</b>")
            self.results_text_edit.append("--------------------------------")
            self.results_text_edit.append("Αποτελέσματα Ανάλυσης:")
        except Exception:
            pass

        boxes = results.get('boxes', []) or []
        labels = results.get('labels', []) or []
        scores = results.get('scores', []) or []
        fdis = results.get('fdi', None)
        if not isinstance(fdis, list):
            fdis = list(labels)
        statuses_list = results.get('statuses', None)
        if not isinstance(statuses_list, list):
            statuses_list = [[] for _ in range(len(boxes))]
        tooth_summary_list = results.get('tooth_summary', None)
        if not isinstance(tooth_summary_list, list):
            tooth_summary_list = [None for _ in range(len(boxes))]
        notes_list = results.get('notes', None)
        if not isinstance(notes_list, list):
            notes_list = ["" for _ in range(len(boxes))]

        try:
            valid_fdi_set = {f"{q}{t}" for q in range(1, 5) for t in range(1, 9)}
            valid = [str(x).strip() for x in (fdis or []) if str(x).strip() in valid_fdi_set]
            unique_valid = sorted(set(valid), key=lambda s: int(s))
            dup_n = max(0, int(len(valid)) - int(len(unique_valid)))
            msg = f"FDI: {len(unique_valid)}/32"
            if dup_n:
                msg += f" | διπλότυπα: {dup_n}"
            self.results_text_edit.append(msg)
        except Exception:
            pass

        try:
            dbg = results.get("debug")
            if isinstance(dbg, dict):
                sel = ""
                try:
                    sel = str((dbg.get("filters") or {}).get("selected") or "").strip()
                except Exception:
                    sel = ""
                roi = dbg.get("roi") if isinstance(dbg.get("roi"), dict) else {}
                raw = dbg.get("raw_detections")
                post = dbg.get("post_filter")
                post_teeth = dbg.get("post_filter_teeth")
                parts = []
                if isinstance(raw, int):
                    parts.append(f"raw={raw}")
                if isinstance(post, int):
                    parts.append(f"kept={post}")
                if isinstance(post_teeth, int):
                    parts.append(f"teeth={post_teeth}")
                if sel:
                    parts.append(f"filters={sel}")
                if isinstance(roi, dict) and roi:
                    try:
                        parts.append(f"roi={int(roi.get('w',0))}x{int(roi.get('h',0))}@({int(roi.get('x0',0))},{int(roi.get('y0',0))})")
                    except Exception:
                        pass
                if parts:
                    self.results_text_edit.append("")
                    self.results_text_edit.append("Διαγνωστικά:")
                    self.results_text_edit.append("- " + " | ".join(parts))
                try:
                    tm = str(dbg.get("tooth_mode") or "").strip()
                    if tm:
                        self.results_text_edit.append(f"- tooth_mode={tm}")
                except Exception:
                    pass
                try:
                    rid = dbg.get("resolved_ids")
                    if isinstance(rid, dict):
                        tid = rid.get("tooth", None)
                        self.results_text_edit.append(f"- tooth_id={tid}")
                except Exception:
                    pass
                try:
                    hist = dbg.get("class_hist_top")
                    if isinstance(hist, list) and hist:
                        chunks = []
                        for it in hist[:8]:
                            if not isinstance(it, dict):
                                continue
                            cid = it.get("id")
                            nm = str(it.get("name") or "").strip()
                            cnt = it.get("count")
                            if cid is None or cnt is None:
                                continue
                            nm_part = f":{nm}" if nm else ""
                            chunks.append(f"{cid}{nm_part}({int(cnt)})")
                        if chunks:
                            self.results_text_edit.append("- classes=" + " | ".join(chunks))
                except Exception:
                    pass
        except Exception:
            pass

        text_lines = []
        for i, box in enumerate(boxes):
            try:
                label = labels[i] if i < len(labels) else "Tooth"
                score = float(scores[i]) if i < len(scores) else 0.0
            except Exception:
                label = "Tooth"
                score = 0.0
            statuses = statuses_list[i] if i < len(statuses_list) else []
            if not isinstance(statuses, list):
                statuses = []
            notes = notes_list[i] if i < len(notes_list) else ""
            fdi = fdis[i] if i < len(fdis) else None

            status_text = ", ".join([str(s) for s in statuses if str(s).strip()]) if statuses else str(label)
            summary = tooth_summary_list[i] if i < len(tooth_summary_list) else None
            if isinstance(summary, dict) and summary.get("text"):
                status_text = str(summary.get("text"))
                sev = summary.get("severity")
                if sev:
                    status_text = f"{status_text} | Σοβαρότητα: {sev}"

            if fdi:
                line = f"Δόντι {fdi} ({status_text}): {score:.2f}"
            else:
                line = f"Δόντι {i+1} ({status_text}): {score:.2f}"
            if notes:
                line += f" | Σχόλια: {notes}"
            text_lines.append((str(fdi or "99"), line))

        try:
            text_lines.sort(key=lambda x: str(x[0]))
        except Exception:
            pass
        for _, line in text_lines:
            try:
                self.results_text_edit.append(line)
            except Exception:
                pass

        try:
            summary_block = self.compute_radiograph_summary(fdis, tooth_summary_list)
            if summary_block:
                self.results_text_edit.append("")
                self.results_text_edit.append("Σύνοψη Ακτινογραφίας:")
                self.results_text_edit.append(summary_block.get("text", ""))
        except Exception:
            pass

        try:
            golden = self.compute_golden_ratio_metrics(results)
            if golden and golden.get("ratios"):
                self.results_text_edit.append("")
                self.results_text_edit.append("Χρυσή Τομή (φ=1.618):")
                for row in golden["ratios"]:
                    self.results_text_edit.append(row)
                if golden.get("mean_deviation_pct") is not None:
                    self.results_text_edit.append(f"Μέση απόκλιση: {golden['mean_deviation_pct']:.1f}%")
        except Exception:
            pass

    def _collect_scene_annotations(self):
        if not self.scene:
            return []

        rects = []
        for item in self.scene.items():
            if isinstance(item, EditableRectItem):
                r = item.rect()
                pos = item.scenePos()
                x1 = float(pos.x() + r.x())
                y1 = float(pos.y() + r.y())
                x2 = float(x1 + r.width())
                y2 = float(y1 + r.height())
                label_text = item.get_label_text() if hasattr(item, "get_label_text") else None
                statuses = item.get_statuses() if hasattr(item, "get_statuses") else []
                notes = item.get_notes() if hasattr(item, "get_notes") else ""
                last_updated = item.get_last_updated() if hasattr(item, "get_last_updated") else ""
                last_updated_by = item.get_last_updated_by() if hasattr(item, "get_last_updated_by") else ""
                implant = item.get_implant() if hasattr(item, "get_implant") else {}
                bypass_grid = item.get_bypass_grid() if hasattr(item, "get_bypass_grid") else False
                rects.append({
                    "item": item, 
                    "box": [x1, y1, x2, y2], 
                    "label": label_text or "?", 
                    "statuses": statuses,
                    "notes": notes,
                    "last_updated": last_updated,
                    "last_updated_by": last_updated_by,
                    "implant": implant,
                    "bypass_grid": bypass_grid
                })

        text_map = {}
        for item in self.scene.items():
            if isinstance(item, EditableTextItem) and hasattr(item, "rect_item") and item.rect_item:
                try:
                    text_map[item.rect_item] = str(item.toPlainText()).strip()
                except Exception:
                    pass

        for entry in rects:
            rect_item = entry["item"]
            if rect_item in text_map:
                entry["label"] = text_map[rect_item] or entry["label"]

        return rects

    def _sync_analysis_results_from_scene(self):
        scene_ann = self._collect_scene_annotations()
        if not scene_ann:
            return

        existing = self.analysis_results if isinstance(getattr(self, "analysis_results", None), dict) else None
        updated = dict(existing) if isinstance(existing, dict) else {}
        updated["boxes"] = []
        updated["labels"] = []
        updated["statuses"] = []
        updated["scores"] = []
        updated["notes"] = []
        updated["last_updated"] = []
        updated["last_updated_by"] = []
        updated["implants"] = []
        updated["bypass_grid"] = []
        updated["_item_refs"] = []

        for a in scene_ann:
            updated["boxes"].append(a["box"])
            updated["labels"].append(a["label"])
            updated["statuses"].append(a["statuses"])
            updated["scores"].append(1.0)
            updated["notes"].append(a.get("notes", ""))
            updated["last_updated"].append(a.get("last_updated", ""))
            updated["last_updated_by"].append(a.get("last_updated_by", ""))
            updated["implants"].append(a.get("implant", {}))
            updated["bypass_grid"].append(a.get("bypass_grid", False))
            updated["_item_refs"].append(a.get("item", None))

        if existing and isinstance(existing.get("scores"), list) and len(existing.get("scores")) == len(updated["boxes"]):
            updated["scores"] = existing.get("scores")
        try:
            updated["fdi"] = list(updated.get("labels") or [])
        except Exception:
            pass

        self.analysis_results = updated
        if getattr(self, "raw_analysis_results", None) is None:
            self.raw_analysis_results = copy.deepcopy(updated)
        try:
            self._update_odontogram_from_results(self.analysis_results)
        except Exception:
            pass

    def _find_similar_rects(self, reference_rect):
        if not isinstance(reference_rect, EditableRectItem) or not self.scene:
            return []

        ref_label = reference_rect.get_label_text() if hasattr(reference_rect, "get_label_text") else None
        if isinstance(ref_label, str):
            ref_label = ref_label.strip()

        all_rects = [i for i in self.scene.items() if isinstance(i, EditableRectItem)]
        if ref_label and re.fullmatch(r"\d{2}", ref_label) and ref_label != "?":
            return [r for r in all_rects if (r.get_label_text() or "").strip() == ref_label]

        if self.grid_active and self.grid_lines_h and self.grid_lines_v:
            ref_center = reference_rect.sceneBoundingRect().center()
            ref_slot = self._grid_slot_for_point(ref_center)
            if ref_slot is not None:
                out = []
                for r in all_rects:
                    c = r.sceneBoundingRect().center()
                    if self._grid_slot_for_point(c) == ref_slot:
                        out.append(r)
                return out

        ref_statuses = tuple(sorted(reference_rect.get_statuses() if hasattr(reference_rect, "get_statuses") else []))
        if ref_statuses:
            return [r for r in all_rects if tuple(sorted(r.get_statuses() if hasattr(r, "get_statuses") else [])) == ref_statuses]

        return [reference_rect]

    def _normalize_fdi_label(self, fdi_text: str) -> str:
        s = str(fdi_text or "").strip()
        if not re.fullmatch(r"\d{2}", s):
            return ""
        q = int(s) // 10
        t = int(s) % 10
        
        # Permanent: 11-18, 21-28, 31-38, 41-48
        if q in (1, 2, 3, 4) and (1 <= t <= 8):
            return s
        # Deciduous: 51-55, 61-65, 71-75, 81-85
        if q in (5, 6, 7, 8) and (1 <= t <= 5):
            return s
            
        return ""

    def _grid_zone_for_bounds(self, y1: float, y2: float, h_lines: list[float]) -> str:
        if not h_lines:
            return ""
        if len(h_lines) >= 3:
            y_mid = float(h_lines[1])
            if float(y2) <= y_mid:
                return "upper"
            if float(y1) >= y_mid:
                return "lower"
            upper_part = max(0.0, float(y_mid) - float(y1))
            lower_part = max(0.0, float(y2) - float(y_mid))
            return "lower" if lower_part >= upper_part else "upper"
        return "upper"

    def _grid_v_lines_for_zone(self, zone: str) -> list[float]:
        zone = str(zone or "").strip().lower()
        v_upper = []
        v_lower = []
        try:
            v_upper = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v_upper", None) or []) if l and l.scene() == self.scene])
        except Exception:
            v_upper = []
        try:
            v_lower = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v_lower", None) or []) if l and l.scene() == self.scene])
        except Exception:
            v_lower = []
        if v_upper or v_lower:
            return v_upper if zone == "upper" else (v_lower or v_upper)
        try:
            return sorted([float(l.x()) for l in (getattr(self, "grid_lines_v", None) or []) if l and l.scene() == self.scene])
        except Exception:
            return []

    def _grid_cell_key_for_rect(self, rect_item) -> str:
        try:
            if not rect_item or rect_item.scene() != self.scene:
                return ""
        except Exception:
            return ""
        try:
            br = rect_item.sceneBoundingRect()
        except Exception:
            return ""
        try:
            h_lines = sorted([float(l.y()) for l in (getattr(self, "grid_lines_h", None) or []) if l and l.scene() == self.scene])
        except Exception:
            h_lines = []
        if len(h_lines) < 2:
            return ""
        zone = self._grid_zone_for_bounds(float(br.top()), float(br.bottom()), h_lines)
        if not zone:
            return ""
        v_lines = self._grid_v_lines_for_zone(zone)
        if not v_lines:
            return ""
        cx = float(br.center().x())
        slot = 0
        for vx in v_lines:
            if cx > float(vx):
                slot += 1
        return f"{zone}:{int(slot)}"

    def _grid_slot_for_point(self, pos):
        try:
            if not pos:
                return None
        except Exception:
            return None
        try:
            h_lines = sorted([float(l.y()) for l in (getattr(self, "grid_lines_h", None) or []) if l and l.scene() == self.scene])
        except Exception:
            h_lines = []
        if len(h_lines) < 2:
            return None
        zone = "upper"
        if len(h_lines) >= 3:
            zone = "upper" if float(pos.y()) < float(h_lines[1]) else "lower"
        v_lines = self._grid_v_lines_for_zone(zone)
        if not v_lines:
            return None
        slot = 0
        for vx in v_lines:
            if float(pos.x()) > float(vx):
                slot += 1
        return (zone, int(slot))

    def _learn_grid_cell_label(self, rect_item, fdi_text: str) -> bool:
        return False
        try:
            self._save_layout_snapshot_to_prefs()
        except Exception:
            pass
        try:
            self._save_viewer_prefs()
        except Exception:
            pass
        try:
            self._schedule_layout_save(0)
        except Exception:
            pass
        return True

    def apply_statuses_to_similar(self, reference_rect, statuses):
        targets = self._find_similar_rects(reference_rect)
        for r in targets:
            if isinstance(r, EditableRectItem):
                r.set_statuses(list(statuses))

    def open_bulk_status_editor_for_similar(self, reference_rect):
        targets = self._find_similar_rects(reference_rect)
        initial = reference_rect.get_statuses() if hasattr(reference_rect, "get_statuses") else []
        self._open_bulk_status_editor(targets, initial_statuses=initial)

    def open_bulk_status_editor_for_selected(self):
        if not self.scene:
            return
        selected = [i for i in self.scene.selectedItems() if isinstance(i, EditableRectItem)]
        self._open_bulk_status_editor(selected, initial_statuses=None)

    def _open_bulk_status_editor(self, rect_items, initial_statuses=None):
        rect_items = [i for i in (rect_items or []) if isinstance(i, EditableRectItem)]
        if not rect_items:
            return

        dialog = QDialog(self)
        dialog.setWindowTitle("Μαζική Επεξεργασία Καταστάσεων")
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(f"Επιλεγμένα αντικείμενα: {len(rect_items)}"))

        grouped = self.get_available_statuses_grouped()
        checkboxes = []
        initial = set([str(s) for s in (initial_statuses or []) if str(s).strip()])

        for group_name, statuses in grouped.items():
            layout.addWidget(QLabel(group_name))
            for s in statuses:
                cb = QCheckBox(s)
                cb.setChecked(s in initial)
                layout.addWidget(cb)
                checkboxes.append(cb)

        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(dialog.accept)
        btns.rejected.connect(dialog.reject)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            statuses = [cb.text() for cb in checkboxes if cb.isChecked()]
            for r in rect_items:
                r.set_statuses(statuses)

    def add_status_region(self, pos, status):
        status = str(status).strip()
        if not status:
            return None

        w, h = 40, 60
        x = pos.x() - w / 2
        y = pos.y() - h / 2
        fdi_text = ""

        rect = EditableRectItem(x=x, y=y, w=w, h=h, on_change_callback=self.debounced_recalculate_fdi)
        self.scene.addItem(rect)
        rect.set_statuses([status])

        text = EditableTextItem(fdi_text, rect_item=rect, on_change_callback=self.debounced_recalculate_fdi)
        text.setDefaultTextColor(QColor("red"))
        self.scene.addItem(text)
        self.analysis_items.append(rect)
        self.analysis_items.append(text)
        self._apply_overlay_visibility(rect, text)
        self._position_label_for_rect(rect)

        return rect

    def _position_label_for_rect(self, rect_item):
        if not rect_item or not hasattr(rect_item, "text_item") or rect_item.text_item is None:
            return
        t = rect_item.text_item
        try:
            t.is_moving_linked = True
        except Exception:
            pass
        try:
            r = rect_item.rect()
            p = rect_item.scenePos()
            x1 = float(p.x() + float(r.x()))
            y1 = float(p.y() + float(r.y()))
            w = float(r.width())
            h = float(r.height())
            br = t.boundingRect()
            tw = br.width()
            
            off = getattr(rect_item, "label_offset", None)
            use_off = bool(getattr(rect_item, "label_offset_user", False))
            
            # Sanity Check for "Flying Labels" caused by previous bugs
            # If offset is huge (>200px), assume it's an artifact and reset it.
            if use_off and isinstance(off, QPointF):
                 dist = (off.x()**2 + off.y()**2)**0.5
                 if dist > 200.0:
                      # Reset
                      use_off = False
                      rect_item.label_offset_user = False
                      rect_item.label_offset = None
                      # Log it?
                      # print(f"Resetting flying label for {t.toPlainText()} (dist={dist:.1f})")

            if use_off and isinstance(off, QPointF):
                tx = x1 + float(off.x())
                ty = y1 + float(off.y())
            else:
                # Standard positioning: CENTERED above rect
                # Was: tx = x1
                tx = x1 + (w / 2.0) - (tw / 2.0)
                ty = y1 - 25.0 # Slightly higher to clear box
                
            t.setPos(QPointF(float(tx), float(ty)))
        except Exception:
            pass
        try:
            t.is_moving_linked = False
        except Exception:
            pass

    def debounced_recalculate_fdi(self):
        """Triggers recalculation with a slight delay to avoid freezing during rapid interactions."""
        # Fix: Always mark as modified so Save button enables, even if Auto-FDI is off
        try:
            self.on_annotation_modified()
        except Exception:
            pass

        try:
            if bool(getattr(self, "_manual_scan_active", False)) or bool(getattr(self, "_manual_scan_block_ai", False)):
                return
        except Exception:
            pass
        if self.auto_fdi_enabled:
            # _update_spee_lower_overlay call removed

            self.recalc_timer.start()

    def update_scene_labels(self, results):
        """Updates existing scene items with new FDI labels instead of recreating them."""
        if not results: return
        
        fdi_list = results.get('fdi', [])
        statuses_list = results.get('statuses', [])
        item_refs = results.get('_item_refs', [])
        
        # Keep track of active items to remove orphans (filtered out by NMS)
        active_rects = set()
        
        for i, rect_item in enumerate(item_refs):
            if rect_item and isinstance(rect_item, EditableRectItem) and self._is_scene_item_alive(rect_item):
                active_rects.add(rect_item)
                
                # Update FDI Label
                new_fdi = fdi_list[i]
                display_label = ""
                try:
                    s = str(new_fdi or "").strip()
                    if re.match(r"^\d+$", s):
                        display_label = s
                except Exception:
                    display_label = ""
                
                if rect_item.text_item:
                    # Update text if changed
                    if rect_item.text_item.toPlainText() != display_label:
                        rect_item.text_item.setPlainText(display_label)
                    self._position_label_for_rect(rect_item)
                
                # Update Status Visuals if needed
                # (Statuses might have been updated by user interaction, but we sync back to ensure consistency)
                # Actually, statuses usually come FROM the item, so they shouldn't change unless logic changed them.
                # But let's apply visuals to be sure (e.g. if FDI change affects color?)
                self.apply_status_visuals_to_rect(rect_item)

        # Remove items that are no longer in results (e.g. filtered by NMS)
        if self.scene:
            # We iterate a copy of items because we might remove some
            for item in list(self.scene.items()):
                if isinstance(item, EditableRectItem):
                    if item not in active_rects:
                        # This item was filtered out (e.g. NMS)
                        # Remove it and its text
                        if item.text_item and item.text_item.scene() == self.scene:
                            self.scene.removeItem(item.text_item)
                        self.scene.removeItem(item)

    def recalculate_fdi(self):
        if not self.auto_fdi_enabled:
            return
        try:
            if bool(getattr(self, "_manual_scan_active", False)) or bool(getattr(self, "_manual_scan_block_ai", False)):
                return
        except Exception:
            pass
        try:
            if bool(getattr(self, "_recalc_in_progress", False)):
                return
            self._recalc_in_progress = True
        except Exception:
            pass
        try:
            # _update_spee_lower_overlay call removed
            pass


            self._sync_analysis_results_from_scene()
            source_results = getattr(self, 'analysis_results', None)
            
            if source_results:
                self.analysis_results = self.assign_fdi_numbers(source_results.copy())
                self.update_scene_labels(self.analysis_results)
                
                if hasattr(self, "save_analysis_button") and self.save_analysis_button:
                    self.save_analysis_button.setEnabled(True)
            self._schedule_layout_save()
        finally:
            try:
                self._recalc_in_progress = False
            except Exception:
                pass

    def toggle_auto_fdi(self):
        self.auto_fdi_enabled = bool(self.auto_fdi_checkbox.isChecked())
        if not self.auto_fdi_enabled:
            try:
                self.recalc_timer.stop()
            except Exception:
                pass
        else:
            self.debounced_recalculate_fdi()
        self._save_viewer_prefs()
        try:
            self._announce_action_done("Auto FDI: ενεργό" if bool(self.auto_fdi_enabled) else "Auto FDI: ανενεργό")
        except Exception:
            pass

    def _set_auto_fdi_enabled_internal(self, enabled: bool):
        self.auto_fdi_enabled = bool(enabled)
        if not self.auto_fdi_enabled:
            try:
                self.recalc_timer.stop()
            except Exception:
                pass
        else:
            self.debounced_recalculate_fdi()

    def _set_corrections_mode(self, enabled: bool, announce: bool = False):
        en = bool(enabled)
        if en:
            if self._corrections_prev_auto_fdi is None:
                try:
                    self._corrections_prev_auto_fdi = bool(self.auto_fdi_enabled)
                except Exception:
                    self._corrections_prev_auto_fdi = False
            self.corrections_mode_active = True
            self.snap_annotations_to_grid_on_drop = False
            try:
                if hasattr(self, "auto_fdi_checkbox") and self.auto_fdi_checkbox is not None:
                    self.auto_fdi_checkbox.setEnabled(False)
                    self.auto_fdi_checkbox.blockSignals(True)
                    self.auto_fdi_checkbox.setChecked(False)
                    self.auto_fdi_checkbox.blockSignals(False)
            except Exception:
                pass
            self._set_auto_fdi_enabled_internal(False)
        else:
            self.corrections_mode_active = False
            self.snap_annotations_to_grid_on_drop = True
            prev = self._corrections_prev_auto_fdi
            self._corrections_prev_auto_fdi = None
            try:
                if hasattr(self, "auto_fdi_checkbox") and self.auto_fdi_checkbox is not None:
                    self.auto_fdi_checkbox.setEnabled(True)
                    if prev is not None:
                        self.auto_fdi_checkbox.blockSignals(True)
                        self.auto_fdi_checkbox.setChecked(bool(prev))
                        self.auto_fdi_checkbox.blockSignals(False)
                        self._set_auto_fdi_enabled_internal(bool(prev))
                    else:
                        self._set_auto_fdi_enabled_internal(bool(self.auto_fdi_checkbox.isChecked()))
            except Exception:
                self._set_auto_fdi_enabled_internal(bool(getattr(self, "auto_fdi_enabled", False)))

        try:
            if hasattr(self, "corrections_mode_button") and self.corrections_mode_button is not None:
                self.corrections_mode_button.blockSignals(True)
                self.corrections_mode_button.setChecked(bool(en))
                self.corrections_mode_button.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "corrections_mode_quick_button") and self.corrections_mode_quick_button is not None:
                self.corrections_mode_quick_button.blockSignals(True)
                self.corrections_mode_quick_button.setChecked(bool(en))
                self.corrections_mode_quick_button.blockSignals(False)
        except Exception:
            pass

        if announce:
            try:
                self._announce_action_done("Διορθώσεις: ενεργές" if en else "Διορθώσεις: ανενεργές")
            except Exception:
                pass

    def toggle_corrections_mode(self):
        try:
            en = bool(self.corrections_mode_button.isChecked())
        except Exception:
            en = False
        self._set_corrections_mode(en, announce=True)

    def toggle_layout_lock(self):
        self.layout_locked = bool(self.lock_layout_checkbox.isChecked()) if hasattr(self, "lock_layout_checkbox") else bool(self.layout_locked)
        self.apply_layout_lock()
        if self.layout_locked:
            try:
                self._save_layout_snapshot_to_prefs()
            except Exception:
                pass
            try:
                self._schedule_layout_save(0)
            except Exception:
                pass
        self._save_viewer_prefs()
        try:
            self._announce_action_done("Κλείδωμα: ενεργό" if bool(self.layout_locked) else "Κλείδωμα: ανενεργό")
        except Exception:
            pass

    def _sync_quick_lock_checkbox(self):
        try:
            if hasattr(self, "lock_layout_quick_checkbox") and self.lock_layout_quick_checkbox is not None:
                self.lock_layout_quick_checkbox.blockSignals(True)
                self.lock_layout_quick_checkbox.setChecked(bool(self.layout_locked))
                self.lock_layout_quick_checkbox.blockSignals(False)
        except Exception:
            pass

    def _on_jaw_lines_changed(self):
        try:
            if bool(getattr(self, "_bulk_scene_update", False)):
                return
            if hasattr(self, "debounced_recalculate_fdi"):
                self.debounced_recalculate_fdi()
            else:
                self.recalculate_fdi()
        except Exception:
            pass
        try:
            self._schedule_layout_save()
        except Exception:
            pass

    # --- ANATOMICAL ZONING (RESTORED MANUAL TOOLS) ---
    def toggle_zoning_mode(self, enabled: bool):
        """
        Activates/Deactivates the Anatomical Zoning Mode (Manual Lines) with Wizard Workflow.
        """
        self.zoning_mode_active = bool(enabled)
        
        if self.zoning_mode_active:
            if not self.pixmap_item:
                return
                
            rect = self.pixmap_item.boundingRect()
            w = rect.width()
            h = rect.height()
            
            # Predict initial positions
            y1, y2 = self.zone_manager.predict_zones((h, w))
            
            # --- WIZARD STEP 1: UPPER / MIDDLE SEPARATOR ---
            self.results_text_edit.append("🔷 Βήμα 1/4: Επιβεβαίωση Άνω Ζώνης (Ιγμόρεια / Άνω Γνάθος)")
            
            if not self._is_scene_item_alive(self.zone_line_1):
                self.zone_line_1 = ZoneSeparatorLine(w, 0, label="Όριο Ιγμορείων / Άνω Γνάθου", color=Qt.GlobalColor.green, on_change_callback=None)
                self.scene.addItem(self.zone_line_1)
            
            self.zone_line_1.setVisible(True)
            self.zone_line_1.setPos(0, y1)
            
            # Hide Line 2 initially
            if self._is_scene_item_alive(self.zone_line_2):
                self.zone_line_2.setVisible(False)
            
            # Show "Next" button instead of "Save"
            # NOTE: We pass 'label' as a keyword argument to show_continue_button, which we must support.
            self.show_continue_button(lambda: self.activate_zone_2_step(w, self.zone_line_1.y(), y2), label="Επόμενο: Διαχωρισμός Γνάθων")

        else:
            # Hide Lines
            if self._is_scene_item_alive(self.zone_line_1):
                self.zone_line_1.setVisible(False)
            if self._is_scene_item_alive(self.zone_line_2):
                self.zone_line_2.setVisible(False)
            
            if hasattr(self, "_continue_btn") and self._continue_btn:
                self._continue_btn.hide()
                
            self._announce_action_done("Λειτουργία Ζωνών: Ανενεργή")

    def toggle_manual_roi(self):
        active = self.manual_roi_button.isChecked()
        if active:
            if not hasattr(self, "_scan_roi_item") or self._scan_roi_item is None or not self._is_scene_item_alive(self._scan_roi_item):
                if self.pixmap_item:
                    brect = self.pixmap_item.boundingRect()
                    w = brect.width()
                    h = brect.height()
                    rect = QRectF(w*0.1, h*0.1, w*0.8, h*0.8)
                else:
                    rect = QRectF(100, 100, 500, 300)
                
                self._scan_roi_item = RoiRectItem(rect, color=Qt.GlobalColor.green, label="ROI Σάρωσης")
                self._scan_roi_item.setZValue(40)
                self.scene.addItem(self._scan_roi_item)
            else:
                self._scan_roi_item.setVisible(True)
            
            self._append_comm("Σύστημα", "Ενεργοποιήθηκε η χειροκίνητη ζώνη σάρωσης. Ρυθμίστε το πράσινο πλαίσιο.")
        else:
            # Hide ROI item
            if hasattr(self, "_scan_roi_item") and self._scan_roi_item:
                self._scan_roi_item.setVisible(False)
            self._append_comm("Σύστημα", "Απενεργοποιήθηκε η χειροκίνητη ζώνη σάρωσης.")

    def _manual_roi_set_from_click(self, scene_pos):
        if not self.pixmap_item:
            return
        try:
            brect = self.pixmap_item.boundingRect()
        except Exception:
            return
        try:
            x = float(scene_pos.x())
            y = float(scene_pos.y())
        except Exception:
            return
        w_img = float(brect.width())
        h_img = float(brect.height())
        try:
            w = max(50.0, w_img * 0.25)
            if w > w_img:
                w = w_img
        except Exception:
            w = max(50.0, w_img * 0.25 if w_img > 0 else 300.0)
        x0 = x - w / 2.0
        left = float(brect.left())
        right = float(brect.right())
        if x0 < left:
            x0 = left
        if x0 + w > right:
            x0 = right - w
        try:
            zl1 = getattr(self, "zone_line_1", None)
            zl2 = getattr(self, "zone_line_2", None)
            if self._is_scene_item_alive(zl1) and self._is_scene_item_alive(zl2):
                y1 = float(zl1.y())
                y2 = float(zl2.y())
            else:
                y1 = float(brect.top() + h_img * 0.15)
                y2 = float(brect.top() + h_img * 0.85)
        except Exception:
            y1 = float(brect.top() + h_img * 0.15)
            y2 = float(brect.top() + h_img * 0.85)
        if y2 <= y1:
            y1 = float(brect.top())
            y2 = float(brect.bottom())
        rect = QRectF(x0, y1, w, y2 - y1)
        try:
            if not hasattr(self, "_scan_roi_item") or self._scan_roi_item is None or not self._is_scene_item_alive(self._scan_roi_item):
                self._scan_roi_item = RoiRectItem(rect, color=Qt.GlobalColor.green, label="ROI Σάρωσης")
                self._scan_roi_item.setZValue(40)
                self.scene.addItem(self._scan_roi_item)
            else:
                self._scan_roi_item.setRect(rect)
                self._scan_roi_item.setVisible(True)
        except Exception:
            pass
        try:
            self._append_comm("Σύστημα", f"Ενημερώθηκε η ζώνη σάρωσης γύρω από το κλικ (x={int(x)}, y={int(y)}).")
        except Exception:
            pass

    def activate_zone_2_step(self, w, prev_y, y2):
        self.results_text_edit.append("🔷 Βήμα 2/4: Επιβεβαίωση Διαχωρισμού Γνάθων (Άνω Γνάθος / Κάτω Γνάθος)")
        
        # --- WIZARD STEP 2: MIDDLE / LOWER SEPARATOR ---
        if not self._is_scene_item_alive(self.zone_line_2):
            self.zone_line_2 = ZoneSeparatorLine(w, 0, label="Διαχωρισμός Άνω/Κάτω Γνάθου", color=Qt.GlobalColor.green, on_change_callback=None)
            self.scene.addItem(self.zone_line_2)
            
        self.zone_line_2.setVisible(True)
        self.zone_line_2.setPos(0, y2)
        
        # Show "Next" button
        self.show_continue_button(self.activate_upper_roi_step, label="Επόμενο: Περιοχή Άνω Γνάθου")

    def activate_upper_roi_step(self):
        self.results_text_edit.append("🔷 Βήμα 3/4: Επιλογή Περιοχής Άνω Γνάθου (Τετράγωνο)")
        
        rect = self.pixmap_item.boundingRect()
        w = rect.width()
        y1 = self.zone_line_1.y()
        y2 = self.zone_line_2.y()
        
        # Default rect: start below sinus line, end above jaw split
        initial_rect = QRectF(w*0.1, y1, w*0.8, max(50, y2 - y1))
        
        if not hasattr(self, 'upper_roi_item') or self.upper_roi_item is None or not self._is_scene_item_alive(self.upper_roi_item):
             self.upper_roi_item = RoiRectItem(initial_rect, color=Qt.GlobalColor.cyan, label="Περιοχή Άνω Γνάθου")
             self.scene.addItem(self.upper_roi_item)
        
        self.upper_roi_item.setVisible(True)
        
        self.show_continue_button(self.activate_lower_roi_step, label="Επόμενο: Περιοχή Κάτω Γνάθου")

    def activate_lower_roi_step(self):
        self.results_text_edit.append("🔷 Βήμα 4/4: Επιλογή Περιοχής Κάτω Γνάθου (Τετράγωνο)")
        
        rect = self.pixmap_item.boundingRect()
        w = rect.width()
        h = rect.height()
        y2 = self.zone_line_2.y()
        
        initial_rect = QRectF(w*0.1, y2, w*0.8, max(50, h - y2 - 20))
        
        if not hasattr(self, 'lower_roi_item') or self.lower_roi_item is None or not self._is_scene_item_alive(self.lower_roi_item):
             self.lower_roi_item = RoiRectItem(initial_rect, color=Qt.GlobalColor.magenta, label="Περιοχή Κάτω Γνάθου")
             self.scene.addItem(self.lower_roi_item)
        
        self.lower_roi_item.setVisible(True)
        
        self.show_continue_button(self.save_zoning_feedback, label="Ολοκλήρωση & Αποθήκευση")

    def show_continue_button(self, callback, label="Συνέχεια"):
        # Create or Reuse the floating button
        if not hasattr(self, "_continue_btn") or self._continue_btn is None:
            self._continue_btn = QPushButton(label, self.view)
            self._continue_btn.setStyleSheet("background-color: #27ae60; color: white; font-weight: bold; padding: 10px; border-radius: 5px; font-size: 14px;")
            self._continue_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        
        # Update properties
        self._continue_btn.setText(label)
        self._continue_btn.adjustSize()
        # Position top-right
        self._continue_btn.move(self.view.width() - self._continue_btn.width() - 30, 20)
        self._continue_btn.show()
        self._continue_btn.raise_()
        
        # Safe Disconnect
        try: 
            self._continue_btn.clicked.disconnect()
        except: 
            pass
        
        # Wrap callback to handle errors and break signal chain
        def safe_callback():
            print(f"DEBUG: Wizard Button Clicked for '{label}'")
            try:
                # Use Timer to break the signal stack trace (safer for UI updates inside slots)
                QTimer.singleShot(0, callback)
            except Exception as e:
                print(f"Error in wizard step dispatch: {e}")
                import traceback
                traceback.print_exc()
                
        self._continue_btn.clicked.connect(safe_callback)

    # _auto_detect_spee_curve removed as per user request


    def save_zoning_feedback(self):
        if not self.zoning_mode_active: return
        if not self.current_image_path: return
        
        y1 = self.zone_line_1.y() if self._is_scene_item_alive(self.zone_line_1) else 0
        y2 = self.zone_line_2.y() if self._is_scene_item_alive(self.zone_line_2) else 0
        
        rect = self.pixmap_item.boundingRect()
        h = rect.height()
        w = rect.width()

        # Get ROI Rects
        upper_roi = None
        if hasattr(self, 'upper_roi_item') and self._is_scene_item_alive(self.upper_roi_item):
            r = self.upper_roi_item.rect().normalized()
            pos = self.upper_roi_item.pos()
            x = r.x() + pos.x()
            y = r.y() + pos.y()
            upper_roi = [int(x), int(y), int(r.width()), int(r.height())]
            self.upper_roi_item.setVisible(False)
            
        lower_roi = None
        if hasattr(self, 'lower_roi_item') and self._is_scene_item_alive(self.lower_roi_item):
            r = self.lower_roi_item.rect().normalized()
            pos = self.lower_roi_item.pos()
            x = r.x() + pos.x()
            y = r.y() + pos.y()
            lower_roi = [int(x), int(y), int(r.width()), int(r.height())]
            self.lower_roi_item.setVisible(False)
        
        # Save correction
        self.zone_manager.save_feedback(self.current_image_path, (h, w), y1, y2, upper_roi=upper_roi, lower_roi=lower_roi)
        
        self._announce_action_done("Ζώνες & Περιοχές Αποθηκεύτηκαν!")
        
        if hasattr(self, "_continue_btn") and self._continue_btn:
            self._continue_btn.hide()
            
        # self.zone_manager.train_on_feedback() # Called inside save_feedback
        self._crop_and_save_zones(self.current_image_path, y1, y2)

    def _manual_scan_selected_quadrant(self) -> str:
        try:
            cb = getattr(self, "zoning_quadrant_combo", None)
            if cb is not None:
                q = cb.currentData()
                q = str(q or "").strip().lower()
                if q in ("q1", "q2", "q3", "q4"):
                    return q
        except Exception:
            pass
        return "q1"

    def _manual_scan_quadrant_cfg(self, quadrant: str | None = None) -> dict:
        q = str(quadrant or getattr(self, "_manual_scan_quadrant", "") or "").strip().lower()
        if q not in ("q1", "q2", "q3", "q4"):
            q = "q1"
        qn = int(q[1])
        start = int(qn * 10 + 1)
        end = int(qn * 10 + 8)
        is_upper = q in ("q1", "q2")
        is_left = q in ("q1", "q4")
        direction_right = q in ("q2", "q3")
        return {
            "quadrant": q,
            "fdi_start": start,
            "fdi_end": end,
            "is_upper": bool(is_upper),
            "is_left": bool(is_left),
            "direction_right": bool(direction_right),
        }

    def _manual_scan_next_fdi_and_quadrant(self, committed_fdi: int, cfg: dict | None = None) -> tuple[int | None, str | None]:
        try:
            cur = int(committed_fdi)
        except Exception:
            return (None, None)
        try:
            cfg0 = cfg if isinstance(cfg, dict) else self._manual_scan_quadrant_cfg()
        except Exception:
            cfg0 = {}
        q = str((cfg0 or {}).get("quadrant") or "").strip().lower()
        if q not in ("q1", "q2", "q3", "q4"):
            q = "q1"
        try:
            end_fdi = int((cfg0 or {}).get("fdi_end", int(q[1]) * 10 + 8) or (int(q[1]) * 10 + 8))
        except Exception:
            end_fdi = int(q[1]) * 10 + 8
        if cur < end_fdi:
            return (cur + 1, q)
        nxt_q = {"q1": "q2", "q2": "q3", "q3": "q4", "q4": None}.get(q)
        if not nxt_q:
            return (None, None)
        try:
            nxt_start = int(self._manual_scan_quadrant_cfg(nxt_q).get("fdi_start", int(nxt_q[1]) * 10 + 1) or (int(nxt_q[1]) * 10 + 1))
        except Exception:
            nxt_start = int(nxt_q[1]) * 10 + 1
        print(f"DEBUG: Next FDI/Quad for {committed_fdi} (cfg={q}): ({nxt_start}, {nxt_q})")
        return (nxt_start, nxt_q)

    def _manual_scan_item_in_quadrant(self, cx: float, cy: float, cfg: dict) -> bool:
        try:
            mid_x = float(getattr(self, "_scan_mid_x", 0.0) or 0.0)
        except Exception:
            mid_x = 0.0
        try:
            is_left = bool(cfg.get("is_left"))
        except Exception:
            is_left = True
        try:
            if mid_x > 0:
                if is_left and float(cx) > float(mid_x):
                    return False
                if (not is_left) and float(cx) < float(mid_x):
                    return False
        except Exception:
            pass
        try:
            is_upper = bool(cfg.get("is_upper"))
        except Exception:
            is_upper = True
        zl1 = getattr(self, "zone_line_1", None)
        zl2 = getattr(self, "zone_line_2", None)
        if is_upper:
            try:
                if self._is_scene_item_alive(zl1) and float(cy) < float(zl1.y()):
                    return False
            except Exception:
                pass
            try:
                if self._is_scene_item_alive(zl2) and float(cy) > float(zl2.y()):
                    return False
            except Exception:
                pass
        else:
            try:
                if self._is_scene_item_alive(zl2) and float(cy) < float(zl2.y()):
                    return False
            except Exception:
                pass
        return True


    def _update_scan_speed(self, value):
        try:
            # Map slider value (10=Fast, 200=Slow) to Speed (px/sec)
            # High Speed: 10ms -> ~400 px/sec
            # Low Speed: 200ms -> ~20 px/sec
            self._scan_speed_px_per_sec = 4000.0 / max(5.0, float(value))
            
            # Keep animation smooth with fixed interval (30ms ~ 33fps)
            # The slider now controls physical speed, not frame rate.
            if hasattr(self, "_scan_timer") and self._scan_timer:
                self._scan_timer.setInterval(30)
        except Exception:
            pass

    def _on_zoning_scan_button_clicked(self):
        if not bool(getattr(self, "_manual_scan_active", False)):
            self._start_manual_scan(self._manual_scan_selected_quadrant())
            return
        try:
            desired = str(self._manual_scan_selected_quadrant() or "").strip().lower()
        except Exception:
            desired = "q1"
        try:
            current = str(getattr(self, "_manual_scan_quadrant", "") or "").strip().lower()
        except Exception:
            current = ""
        if desired in ("q1", "q2", "q3", "q4") and desired and current and desired != current:
            self._start_manual_scan(desired)
            return
        is_running = False
        try:
            is_running = bool(hasattr(self, "_scan_timer") and self._scan_timer and self._scan_timer.isActive())
        except Exception:
            is_running = False
        if not bool(is_running):
            try:
                self._manual_scan_paused = False
            except Exception:
                pass
            self._resume_scanning()
            try:
                self.zoning_scan_button.setText("Παύση")
            except Exception:
                pass
            try:
                self._announce_action_done("Συνέχεια σάρωσης")
            except Exception:
                pass
            try:
                if getattr(self, "zoning_register_button", None):
                    self.zoning_register_button.setEnabled(True)
            except Exception:
                pass
            try:
                if getattr(self, "zoning_skip_button", None):
                    self.zoning_skip_button.setEnabled(False)
            except Exception:
                pass
        else:
            try:
                if hasattr(self, "_scan_timer") and self._scan_timer:
                    self._scan_timer.stop()
            except Exception:
                pass
            try:
                self._manual_scan_paused = True
            except Exception:
                pass
            try:
                self.zoning_scan_button.setText("Συνέχεια")
            except Exception:
                pass
            try:
                self._announce_action_done("Παύση σάρωσης")
            except Exception:
                pass
            try:
                cfg = self._manual_scan_quadrant_cfg()
            except Exception:
                cfg = {}
            try:
                start = int(cfg.get("fdi_start", 11) or 11)
                end = int(cfg.get("fdi_end", 18) or 18)
            except Exception:
                start, end = 11, 18
            try:
                nxt = int(getattr(self, "_scan_next_fdi", 0) or 0)
            except Exception:
                nxt = 0
            try:
                cur = int(getattr(self, "_manual_scan_current_fdi", start) or start)
            except Exception:
                cur = start
            try:
                if int(start) <= int(nxt) <= int(end):
                    cur = int(nxt)
            except Exception:
                pass
            try:
                self._manual_scan_current_fdi = int(cur)
            except Exception:
                pass
            try:
                self._manual_scan_fill_gaps_until(int(cur))
            except Exception:
                pass
            try:
                if getattr(self, "zoning_register_button", None):
                    self.zoning_register_button.setEnabled(True)
                    if cur:
                        self.zoning_register_button.setText(f"Καταχώρηση ({cur})")
            except Exception:
                pass
            try:
                if getattr(self, "zoning_skip_button", None):
                    self.zoning_skip_button.setEnabled(True)
                    if cur:
                        self.zoning_skip_button.setText(f"Παράλειψη ({cur})")
            except Exception:
                pass

    def _on_zoning_register_button_clicked(self):
        if not bool(getattr(self, "_manual_scan_active", False)):
            return
        try:
            was_paused = bool(getattr(self, "_manual_scan_paused", False))
        except Exception:
            was_paused = False
        try:
            if hasattr(self, "_scan_timer") and self._scan_timer and self._scan_timer.isActive():
                self._scan_timer.stop()
        except Exception:
            pass
        try:
            self._manual_scan_paused = True
        except Exception:
            pass
        try:
            self.zoning_scan_button.setText("Συνέχεια")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_skip_button", None):
                self.zoning_skip_button.setEnabled(True)
        except Exception:
            pass
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start = int(cfg.get("fdi_start", 11) or 11)
            end = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start, end = 11, 18
        try:
            cur = int(getattr(self, "_manual_scan_current_fdi", 0) or 0)
        except Exception:
            cur = 0
        if not bool(was_paused):
            try:
                nxt = int(getattr(self, "_scan_next_fdi", 0) or 0)
            except Exception:
                nxt = 0
            try:
                if int(start) <= int(nxt) <= int(end):
                    cur = int(nxt)
            except Exception:
                pass
            try:
                self._manual_scan_current_fdi = int(cur)
            except Exception:
                pass
            try:
                if int(start) <= int(cur) <= int(end):
                    self._manual_scan_apply_dot_suggestion(int(cur))
            except Exception:
                pass
        try:
            if getattr(self, "zoning_register_button", None) and int(cur):
                self.zoning_register_button.setText(f"Καταχώρηση ({int(cur)})")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_skip_button", None) and int(cur):
                self.zoning_skip_button.setText(f"Παράλειψη ({int(cur)})")
        except Exception:
            pass
        if int(cur):
            self._mark_current_tooth_and_continue(fdi_override=int(cur))
        else:
            self._mark_current_tooth_and_continue()

    def _on_zoning_skip_button_clicked(self):
        if not bool(getattr(self, "_manual_scan_active", False)):
            return
        try:
            was_paused = bool(getattr(self, "_manual_scan_paused", False))
        except Exception:
            was_paused = False
        try:
            if hasattr(self, "_scan_timer") and self._scan_timer and self._scan_timer.isActive():
                self._scan_timer.stop()
        except Exception:
            pass
        try:
            self._manual_scan_paused = True
        except Exception:
            pass
        try:
            self.zoning_scan_button.setText("Συνέχεια")
        except Exception:
            pass
        try:
            cur = int(getattr(self, "_manual_scan_current_fdi", 0) or 0)
        except Exception:
            cur = 0
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start = int(cfg.get("fdi_start", 11) or 11)
            end = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start, end = 11, 18
        if not bool(was_paused):
            try:
                nxt = int(getattr(self, "_scan_next_fdi", 0) or 0)
            except Exception:
                nxt = 0
            try:
                if int(start) <= int(nxt) <= int(end):
                    cur = int(nxt)
                    self._manual_scan_current_fdi = int(cur)
            except Exception:
                pass
        try:
            if int(start) <= int(cur) <= int(end) and (not self._manual_scan_is_registered(int(cur))):
                rect_item = self._manual_scan_create_missing(int(cur), reason="skip_btn")
                self._manual_scan_register_fdi(int(cur))
                try:
                    self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {int(cur)} (Ελλείπον)")
                except Exception:
                    pass
                try:
                    self._manual_scan_announce_commit(int(cur), rect_item=rect_item, is_missing=True)
                except Exception:
                    pass
            if int(start) <= int(cur) <= int(end):
                try:
                    nxt_fdi, nxt_q = self._manual_scan_next_fdi_and_quadrant(int(cur), cfg=cfg)
                    self._scan_next_fdi = int(nxt_fdi) if nxt_fdi is not None else 0
                except Exception:
                    pass
                try:
                    self._manual_scan_current_fdi = int(nxt_fdi) if nxt_fdi is not None else 0
                except Exception:
                    pass
                try:
                    if nxt_q and str(nxt_q).strip().lower() != str(cfg.get("quadrant") or "").strip().lower():
                        print(f"DEBUG: Transitioning (skip) from {cfg.get('quadrant')} to {nxt_q}")
                        self._manual_scan_paused = True
                        QTimer.singleShot(50, lambda q=str(nxt_q): self._start_manual_scan(q))
                        return
                except Exception:
                    pass
        except Exception:
            pass
        try:
            nxt = int(getattr(self, "_manual_scan_current_fdi", 0) or 0)
        except Exception:
            nxt = 0
        try:
            if getattr(self, "zoning_register_button", None):
                if nxt:
                    self.zoning_register_button.setText(f"Καταχώρηση ({nxt})")
                else:
                    self.zoning_register_button.setText("Καταχώρηση")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_skip_button", None):
                if nxt:
                    self.zoning_skip_button.setText(f"Παράλειψη ({nxt})")
                else:
                    self.zoning_skip_button.setText("Παράλειψη")
        except Exception:
            pass

    def _manual_scan_register_fdi(self, fdi: int):
        try:
            s = getattr(self, "_manual_scan_registered", None)
            if not isinstance(s, set):
                s = set()
                self._manual_scan_registered = s
            s.add(int(fdi))
        except Exception:
            pass
        try:
            last = int(getattr(self, "_manual_scan_last_committed_fdi", 10) or 10)
        except Exception:
            last = 10
        try:
            self._manual_scan_last_committed_fdi = max(int(last), int(fdi))
        except Exception:
            pass

    def _manual_scan_is_registered(self, fdi: int) -> bool:
        try:
            s = getattr(self, "_manual_scan_registered", None)
            if isinstance(s, set) and int(fdi) in s:
                return True
        except Exception:
            pass
        try:
            it = self._manual_scan_find_rect_for_fdi(int(fdi))
            return it is not None
        except Exception:
            return False

    def _manual_scan_find_rect_for_fdi(self, fdi: int):
        try:
            fdi_str = str(int(fdi))
        except Exception:
            return None
        try:
            if not getattr(self, "scene", None):
                return None
            for it in self.scene.items():
                if not isinstance(it, EditableRectItem):
                    continue
                ti = getattr(it, "text_item", None)
                if ti is None or ti.scene() != self.scene:
                    continue
                try:
                    if str(ti.toPlainText() or "").strip() == fdi_str:
                        return it
                except Exception:
                    continue
        except Exception:
            return None
        return None

    def _manual_scan_current_dot_xy(self):
        dot_x = None
        dot_y = None
        try:
            dot = getattr(self, "_scan_cusp_dot", None)
            if dot is not None and dot.scene() == self.scene:
                c = dot.sceneBoundingRect().center()
                dot_x = float(c.x())
                dot_y = float(c.y())
        except Exception:
            dot_x = None
            dot_y = None
        if dot_x is None:
            try:
                dot_x = float(self._scan_line_L.line().x1())
            except Exception:
                dot_x = 0.0
        if dot_y is None:
            try:
                dot_y = float(self._scan_line_L.line().y1() + self._scan_line_L.line().y2()) / 2.0
            except Exception:
                dot_y = 0.0
        return float(dot_x), float(dot_y)

    def _manual_scan_create_missing(self, fdi: int, dot_x: float | None = None, dot_y: float | None = None, reason: str | None = None):
        existing = None
        try:
            existing = self._manual_scan_find_rect_for_fdi(int(fdi))
        except Exception:
            existing = None
        if existing is not None:
            return existing

        if dot_x is None or dot_y is None:
            dot_x0, dot_y0 = self._manual_scan_current_dot_xy()
            if dot_x is None:
                dot_x = dot_x0
            if dot_y is None:
                dot_y = dot_y0
        try:
            sx = getattr(self, 'pixel_to_mm_scale_x', 1.0) or 1.0
            cfg = self._manual_scan_quadrant_cfg()
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            width_mm = 10.0 if int(fdi) >= int(start_fdi) + 5 else 8.0
            w_px = float(width_mm) * float(sx)
            h_px = float(w_px) * 2.2
        except Exception:
            w_px = 40.0
            h_px = 90.0

        x1 = float(dot_x) - (float(w_px) / 2.0)
        y1 = float(dot_y) - (float(h_px) / 2.0)
        rect_item = EditableRectItem(x=x1, y=y1, w=w_px, h=h_px, on_change_callback=self.debounced_recalculate_fdi)
        try:
            self.scene.addItem(rect_item)
        except Exception:
            return None
        try:
            rect_item.setZValue(8000)
        except Exception:
            pass
        try:
            rect_item.set_statuses(["Missing"], notify=False)
            rect_item.set_notes("Manual Gap")
        except Exception:
            pass
        text_item = EditableTextItem(str(int(fdi)), rect_item=rect_item, on_change_callback=self.debounced_recalculate_fdi)
        try:
            text_item.setDefaultTextColor(QColor("red"))
        except Exception:
            pass
        try:
            self.scene.addItem(text_item)
        except Exception:
            pass
        try:
            text_item.setZValue(8001)
        except Exception:
            pass
        try:
            brt = text_item.boundingRect()
            text_item.setPos(float(dot_x) - (float(brt.width()) / 2.0), float(dot_y) - (float(brt.height()) / 2.0))
            r = rect_item.rect()
            box_tl = rect_item.scenePos() + QPointF(float(r.x()), float(r.y()))
            rect_item.label_offset = QPointF(float(text_item.pos().x()) - float(box_tl.x()), float(text_item.pos().y()) - float(box_tl.y()))
            rect_item.label_offset_user = True
        except Exception:
            pass

        try:
            m = getattr(self, "_manual_scan_cusp_points", None)
            if not isinstance(m, dict):
                m = {}
                self._manual_scan_cusp_points = m
            m[int(fdi)] = (float(dot_x), float(dot_y))
        except Exception:
            pass
        try:
            cfg = self._manual_scan_quadrant_cfg()
            if str(cfg.get("quadrant") or "") == "q1":
                m2 = getattr(self, "_q1_cusp_points", None)
                if not isinstance(m2, dict):
                    m2 = {}
                    self._q1_cusp_points = m2
                m2[int(fdi)] = (float(dot_x), float(dot_y))
        except Exception:
            pass
        try:
            self._learn_q1_spacing_from_scene()
            self._schedule_layout_save(0)
        except Exception:
            pass
        try:
            self._manual_scan_log_sample(
                fdi=int(fdi),
                kind="missing",
                dot_x=float(dot_x),
                dot_y=float(dot_y),
                rect_item=rect_item,
                reason=str(reason or "").strip() or "missing",
            )
        except Exception:
            pass
        return rect_item

    def _manual_scan_apply_dot_suggestion(self, fdi: int):
        try:
            f = int(fdi)
        except Exception:
            return
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        if f < int(start_fdi) or f > int(end_fdi):
            return
        q = str(cfg.get("quadrant") or "q1")
        tpl = None
        try:
            tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
        except Exception:
            tpl = None
        try:
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(q)
        except Exception:
            pass
        if not isinstance(tpl, dict):
            return
        i = int(f) - int(start_fdi)
        try:
            cxs = tpl.get("cxs_px") or []
            x = float(cxs[i]) if isinstance(cxs, list) and 0 <= i < len(cxs) else None
        except Exception:
            x = None
        try:
            ys = tpl.get("ys_px") or []
            y = float(ys[i]) if isinstance(ys, list) and 0 <= i < len(ys) else None
        except Exception:
            y = None
        if x is None and y is None:
            return
        if x is not None:
            try:
                self._scan_current_offset = abs(float(x) - float(getattr(self, "_scan_mid_x", 0.0) or 0.0))
            except Exception:
                pass
            try:
                if getattr(self, "_scan_line_L", None) is not None:
                    lineL = self._scan_line_L.line()
                    lineL.setLine(float(x), lineL.y1(), float(x), lineL.y2())
                    self._scan_line_L.setLine(lineL)
            except Exception:
                pass
            try:
                dot = getattr(self, "_scan_cusp_dot", None)
                if dot is not None and dot.scene() == self.scene:
                    dot.setPos(float(x), float(dot.pos().y()))
            except Exception:
                pass
        if y is not None:
            try:
                dot = getattr(self, "_scan_cusp_dot", None)
                if dot is not None and dot.scene() == self.scene:
                    try:
                        cur_y = float(dot.pos().y())
                    except Exception:
                        cur_y = float(y)
                    try:
                        if abs(float(y) - float(cur_y)) <= 25.0:
                            dot.setPos(float(dot.pos().x()), float(y))
                    except Exception:
                        pass
            except Exception:
                pass

    def _manual_scan_guess_fdi_from_x(self, x: float, cfg: dict | None = None) -> int | None:
        cfg0 = cfg if isinstance(cfg, dict) else {}
        try:
            start_fdi = int(cfg0.get("fdi_start", 11) or 11)
            end_fdi = int(cfg0.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        if int(start_fdi) > int(end_fdi):
            return None
        try:
            q = str(cfg0.get("quadrant") or "q1")
        except Exception:
            q = "q1"

        tpl = None
        try:
            tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
        except Exception:
            tpl = None
        try:
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(q)
        except Exception:
            pass
        try:
            if isinstance(tpl, dict):
                cxs = tpl.get("cxs_px") or []
                if isinstance(cxs, list) and len(cxs) > 0:
                    best_i = 0
                    best_d = None
                    for i, cx in enumerate(cxs):
                        try:
                            d = abs(float(x) - float(cx))
                        except Exception:
                            continue
                        if best_d is None or d < best_d:
                            best_d = d
                            best_i = i
                    fdi = int(start_fdi) + int(best_i)
                    if int(fdi) < int(start_fdi):
                        fdi = int(start_fdi)
                    if int(fdi) > int(end_fdi):
                        fdi = int(end_fdi)
                    return int(fdi)
        except Exception:
            pass

        try:
            direction_right = bool(cfg0.get("direction_right"))
        except Exception:
            direction_right = False
        try:
            mid_x = float(getattr(self, "_scan_mid_x", 0.0) or 0.0)
        except Exception:
            mid_x = 0.0
        sign = 1.0 if direction_right else -1.0
        u = float(sign) * (float(x) - float(mid_x))
        base = 60.0
        step = 75.0
        if u <= float(base):
            idx = 0
        else:
            idx = int(round((float(u) - float(base)) / float(step)))
        max_i = int(end_fdi) - int(start_fdi)
        if idx < 0:
            idx = 0
        if idx > max_i:
            idx = max_i
        return int(start_fdi) + int(idx)

    def _manual_scan_set_dot(self, scene_pos, pause_if_running: bool = False):
        try:
            x = float(scene_pos.x())
            y = float(scene_pos.y())
        except Exception:
            return
        try:
            if bool(pause_if_running) and bool(getattr(self, "_manual_scan_active", False)) and (not bool(getattr(self, "_manual_scan_paused", False))):
                try:
                    if hasattr(self, "_scan_timer") and self._scan_timer and self._scan_timer.isActive():
                        self._scan_timer.stop()
                except Exception:
                    pass
                try:
                    self._manual_scan_paused = True
                except Exception:
                    pass
                try:
                    self.zoning_scan_button.setText("Συνέχεια")
                except Exception:
                    pass
        except Exception:
            pass
        try:
            if getattr(self, "_scan_line_L", None) is not None:
                lineL = self._scan_line_L.line()
                lineL.setLine(float(x), lineL.y1(), float(x), lineL.y2())
                self._scan_line_L.setLine(lineL)
        except Exception:
            pass
        try:
            dot = getattr(self, "_scan_cusp_dot", None)
            if dot is not None and dot.scene() == self.scene:
                dot.setPos(float(x), float(y))
        except Exception:
            pass
        try:
            self._scan_current_offset = abs(float(x) - float(getattr(self, "_scan_mid_x", 0.0) or 0.0))
        except Exception:
            pass

        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        try:
            q = str(cfg.get("quadrant") or "q1")
        except Exception:
            q = "q1"
        fdi = None
        try:
            fdi = self._manual_scan_guess_fdi_from_x(float(x), cfg=cfg)
        except Exception:
            fdi = None
        try:
            if fdi is None:
                fdi = int(getattr(self, "_manual_scan_current_fdi", start_fdi) or start_fdi)
        except Exception:
            fdi = int(start_fdi)
        try:
            if int(fdi) < int(start_fdi):
                fdi = int(start_fdi)
            if int(fdi) > int(end_fdi):
                fdi = int(end_fdi)
        except Exception:
            fdi = int(start_fdi)
        try:
            self._manual_scan_current_fdi = int(fdi)
        except Exception:
            pass
        try:
            if int(start_fdi) <= int(fdi) <= int(end_fdi):
                self._scan_next_fdi = int(fdi)
        except Exception:
            pass

        try:
            if bool(getattr(self, "_manual_scan_paused", False)):
                self._manual_scan_fill_gaps_until(int(fdi))
        except Exception:
            pass

        try:
            if getattr(self, "zoning_register_button", None):
                self.zoning_register_button.setEnabled(True)
                self.zoning_register_button.setText(f"Καταχώρηση ({int(fdi)})")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_skip_button", None):
                self.zoning_skip_button.setEnabled(True)
                self.zoning_skip_button.setText(f"Παράλειψη ({int(fdi)})")
        except Exception:
            pass
        try:
            self._announce_action_done(f"Στόχος δοντιού {int(fdi)}")
        except Exception:
            pass
        try:
            self._manual_scan_preview_labels_update()
        except Exception:
            pass

    def _manual_scan_select_fdi(self, fdi: int):
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        try:
            f = int(fdi)
        except Exception:
            return
        if f < int(start_fdi) or f > int(end_fdi):
            return
        try:
            self._manual_scan_current_fdi = int(f)
        except Exception:
            pass
        try:
            self._scan_next_fdi = int(f)
        except Exception:
            pass

        try:
            q = str(cfg.get("quadrant") or "q1")
        except Exception:
            q = "q1"
        x = None
        try:
            tpl = None
            try:
                tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
            except Exception:
                tpl = None
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(q)
            if isinstance(tpl, dict) and isinstance(tpl.get("cxs_px"), list):
                i = int(f) - int(start_fdi)
                cxs = tpl.get("cxs_px") or []
                if 0 <= int(i) < len(cxs):
                    x = float(cxs[int(i)])
        except Exception:
            x = None
        if x is not None:
            try:
                if getattr(self, "_scan_line_L", None) is not None:
                    lineL = self._scan_line_L.line()
                    lineL.setLine(float(x), lineL.y1(), float(x), lineL.y2())
                    self._scan_line_L.setLine(lineL)
            except Exception:
                pass
            try:
                dot = getattr(self, "_scan_cusp_dot", None)
                if dot is not None and dot.scene() == self.scene:
                    dot.setPos(float(x), float(dot.pos().y()))
            except Exception:
                pass
            try:
                self._scan_current_offset = abs(float(x) - float(getattr(self, "_scan_mid_x", 0.0) or 0.0))
            except Exception:
                pass
        else:
            try:
                direction_right = bool(cfg.get("direction_right"))
            except Exception:
                direction_right = False
            try:
                mid_x = float(getattr(self, "_scan_mid_x", 0.0) or 0.0)
            except Exception:
                mid_x = 0.0
            sign = 1.0 if direction_right else -1.0
            try:
                x2 = float(mid_x) + float(sign) * (60.0 + float(int(f) - int(start_fdi)) * 75.0)
                if getattr(self, "_scan_line_L", None) is not None:
                    lineL = self._scan_line_L.line()
                    lineL.setLine(float(x2), lineL.y1(), float(x2), lineL.y2())
                    self._scan_line_L.setLine(lineL)
                dot = getattr(self, "_scan_cusp_dot", None)
                if dot is not None and dot.scene() == self.scene:
                    dot.setPos(float(x2), float(dot.pos().y()))
                self._scan_current_offset = abs(float(x2) - float(mid_x))
            except Exception:
                pass

        try:
            if getattr(self, "zoning_register_button", None):
                self.zoning_register_button.setEnabled(True)
                self.zoning_register_button.setText(f"Καταχώρηση ({int(f)})")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_skip_button", None):
                self.zoning_skip_button.setEnabled(True)
                self.zoning_skip_button.setText(f"Παράλειψη ({int(f)})")
        except Exception:
            pass
        try:
            self._announce_action_done(f"Επιλογή δοντιού {int(f)}")
        except Exception:
            pass
        try:
            self._manual_scan_preview_labels_update()
        except Exception:
            pass

    def _manual_scan_preview_labels_update(self):
        try:
            if not getattr(self, "scene", None):
                return
        except Exception:
            return
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            q = str(cfg.get("quadrant") or "q1")
        except Exception:
            q = "q1"
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        direction_right = False
        try:
            direction_right = bool(cfg.get("direction_right"))
        except Exception:
            direction_right = False

        try:
            items = getattr(self, "_manual_scan_preview_labels", None)
            if not isinstance(items, dict):
                items = {}
                self._manual_scan_preview_labels = items
        except Exception:
            items = {}
            self._manual_scan_preview_labels = items

        tpl = None
        try:
            tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
        except Exception:
            tpl = None
        try:
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(q)
        except Exception:
            pass

        cxs = None
        ys = None
        if isinstance(tpl, dict):
            if isinstance(tpl.get("cxs_px"), list):
                cxs = tpl.get("cxs_px") or None
            if isinstance(tpl.get("ys_px"), list):
                ys = tpl.get("ys_px") or None

        y_base = None
        try:
            dot = getattr(self, "_scan_cusp_dot", None)
            if dot is not None and dot.scene() == self.scene:
                y_base = float(dot.pos().y())
        except Exception:
            y_base = None
        if y_base is None:
            try:
                y_base = float(self._scan_line_L.line().y1() + self._scan_line_L.line().y2()) / 2.0
            except Exception:
                y_base = 0.0
        y_text = float(y_base) - 34.0

        try:
            mid_x = float(getattr(self, "_scan_mid_x", 0.0) or 0.0)
        except Exception:
            mid_x = 0.0
        sign = 1.0 if direction_right else -1.0

        for fdi in range(int(start_fdi), int(end_fdi) + 1):
            it = items.get(int(fdi))
            if it is None or it.scene() != self.scene:
                it = QGraphicsTextItem(str(int(fdi)))
                it.setDefaultTextColor(QColor("#9aa7b2"))
                try:
                    font = QFont()
                    font.setPointSize(10)
                    font.setBold(True)
                    it.setFont(font)
                except Exception:
                    pass
                try:
                    it.setZValue(7000)
                except Exception:
                    pass
                try:
                    it.setOpacity(0.35)
                except Exception:
                    pass
                self.scene.addItem(it)
                items[int(fdi)] = it

            x = None
            i = int(fdi) - int(start_fdi)
            if isinstance(cxs, list) and 0 <= i < len(cxs):
                try:
                    x = float(cxs[i])
                except Exception:
                    x = None
            if x is None:
                x = float(mid_x) + (60.0 + float(i) * 75.0) * float(sign)

            y = None
            if isinstance(ys, list) and 0 <= i < len(ys):
                try:
                    y = float(ys[i]) - 34.0
                except Exception:
                    y = None
            if y is None:
                y = float(y_text)
            try:
                br = it.boundingRect()
                it.setPos(float(x) - float(br.width()) / 2.0, float(y))
            except Exception:
                pass

        try:
            extra = [k for k in list(items.keys()) if int(k) < int(start_fdi) or int(k) > int(end_fdi)]
            for k in extra:
                it = items.get(k)
                if it is not None and it.scene() == self.scene:
                    self.scene.removeItem(it)
                items.pop(k, None)
        except Exception:
            pass

    def _manual_scan_log_sample(self, fdi: int, kind: str, dot_x: float, dot_y: float, rect_item=None, reason: str | None = None):
        try:
            root = str(getattr(self, "project_root", "") or "").strip()
            if not root:
                root = str(Path(__file__).resolve().parents[2])
        except Exception:
            root = str(Path(__file__).resolve().parents[2])
        try:
            out_dir = os.path.join(root, "data", "manual_scan")
            os.makedirs(out_dir, exist_ok=True)
            out_path = os.path.join(out_dir, "fdi_samples.jsonl")
        except Exception:
            return
        rec = {}
        try:
            rec["ts"] = float(time.time())
        except Exception:
            pass
        try:
            rec["image_path"] = str(getattr(self, "current_image_path", "") or "").strip()
        except Exception:
            rec["image_path"] = ""
        try:
            rec["patient_id"] = str(getattr(self, "origin_patient_id", "") or "").strip()
        except Exception:
            rec["patient_id"] = ""
        try:
            rec["fdi"] = int(fdi)
        except Exception:
            rec["fdi"] = None
        try:
            rec["quadrant"] = int(int(fdi) // 10) if int(fdi) else None
        except Exception:
            rec["quadrant"] = None
        rec["kind"] = str(kind or "").strip()
        try:
            rec["dot_x"] = float(dot_x)
            rec["dot_y"] = float(dot_y)
        except Exception:
            pass
        try:
            rr = None
            if rect_item is not None and hasattr(rect_item, "sceneBoundingRect"):
                br = rect_item.sceneBoundingRect()
                rr = [float(br.x()), float(br.y()), float(br.width()), float(br.height())]
            rec["rect_xywh"] = rr
        except Exception:
            rec["rect_xywh"] = None
        try:
            rec["reason"] = str(reason or "").strip()
        except Exception:
            rec["reason"] = ""
        try:
            with open(out_path, "a", encoding="utf-8") as f:
                f.write(json.dumps(rec, ensure_ascii=False) + "\n")
        except Exception:
            pass

    def _manual_scan_get_committed_fdi(self, rect_item, fallback: int | None = None) -> int | None:
        try:
            if rect_item is None:
                return int(fallback) if fallback is not None else None
        except Exception:
            return int(fallback) if fallback is not None else None
        try:
            ti = getattr(rect_item, "text_item", None)
            if ti is not None and ti.scene() == self.scene:
                s = str(ti.toPlainText() or "").strip()
                if s.isdigit():
                    return int(s)
        except Exception:
            pass
        try:
            return int(fallback) if fallback is not None else None
        except Exception:
            return None

    def _manual_scan_announce_commit(self, intended_fdi: int, rect_item=None, is_missing: bool = False):
        committed = None
        try:
            committed = self._manual_scan_get_committed_fdi(rect_item, fallback=int(intended_fdi))
        except Exception:
            committed = int(intended_fdi)
        if committed is None:
            return
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            self._session_log(
                "manual_scan_commit",
                {
                    "quadrant": str((cfg or {}).get("quadrant") or "").strip(),
                    "intended": int(intended_fdi),
                    "committed": int(committed),
                    "missing": bool(is_missing),
                },
            )
        except Exception:
            pass
        try:
            if bool(is_missing):
                self._announce_action_done(f"Δόντι {int(committed)} ελλείπον")
            else:
                self._announce_action_done(f"Δόντι {int(committed)}")
        except Exception:
            pass
        try:
            if int(committed) != int(intended_fdi):
                try:
                    self.results_text_edit.append(f"⚠️ Ασυμφωνία: ζητήθηκε {int(intended_fdi)} αλλά καταχωρήθηκε {int(committed)}")
                except Exception:
                    pass
                try:
                    self._announce_action_failed(f"Ασυμφωνία: ζητήθηκε {int(intended_fdi)} αλλά καταχωρήθηκε {int(committed)}")
                except Exception:
                    pass
        except Exception:
            pass

    def _manual_scan_fill_gaps_until(self, cur_fdi: int):
        try:
            cur = int(cur_fdi)
        except Exception:
            return
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start = int(cfg.get("fdi_start", 11) or 11)
            end = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start, end = 11, 18
        if cur < int(start) or cur > int(end):
            return
        try:
            last = int(getattr(self, "_manual_scan_last_committed_fdi", int(start) - 1) or (int(start) - 1))
        except Exception:
            last = int(start) - 1
        if last < int(start):
            return
        if cur <= last + 1:
            return
        tpl = None
        try:
            q = str(cfg.get("quadrant") or "q1")
            tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
        except Exception:
            tpl = None
        try:
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(str(cfg.get("quadrant") or "q1"))
        except Exception:
            pass
        cxs = None
        ys = None
        if isinstance(tpl, dict):
            if isinstance(tpl.get("cxs_px"), list):
                cxs = tpl.get("cxs_px") or None
            if isinstance(tpl.get("ys_px"), list):
                ys = tpl.get("ys_px") or None
        dot_x, dot_y = self._manual_scan_current_dot_xy()
        for f in range(int(last) + 1, int(cur)):
            try:
                if self._manual_scan_is_registered(int(f)):
                    continue
            except Exception:
                pass
            fx = None
            fy = None
            i = int(f) - int(start)
            if isinstance(cxs, list) and 0 <= i < len(cxs):
                try:
                    fx = float(cxs[i])
                except Exception:
                    fx = None
            if isinstance(ys, list) and 0 <= i < len(ys):
                try:
                    fy = float(ys[i])
                except Exception:
                    fy = None
            if fx is None:
                fx = float(dot_x)
            if fy is None:
                fy = float(dot_y)
            try:
                self._manual_scan_create_missing(int(f), dot_x=float(fx), dot_y=float(fy), reason="gap_auto")
                self._manual_scan_register_fdi(int(f))
                try:
                    self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {int(f)} (Ελλείπον)")
                except Exception:
                    pass
            except Exception:
                pass

    def _manual_scan_finalize_on_end(self):
        try:
            if not bool(getattr(self, "_manual_scan_active", False)):
                return
        except Exception:
            return
        try:
            cur = int(getattr(self, "_scan_next_fdi", 0) or 0)
        except Exception:
            cur = 0
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        if cur < int(start_fdi) or cur > int(end_fdi):
            return
        try:
            dot_x, dot_y = self._manual_scan_current_dot_xy()
        except Exception:
            dot_x, dot_y = 0.0, 0.0
        tpl = None
        try:
            q = str(cfg.get("quadrant") or "q1")
            tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
        except Exception:
            tpl = None
        try:
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(str(cfg.get("quadrant") or "q1"))
        except Exception:
            pass
        created_any = False
        if isinstance(tpl, dict) and isinstance(tpl.get("cxs_px"), list):
            cxs = tpl.get("cxs_px") or []
            ys = tpl.get("ys_px") or []
            for f in range(int(cur), int(end_fdi) + 1):
                try:
                    if self._manual_scan_is_registered(int(f)):
                        continue
                except Exception:
                    pass
                i = int(f) - int(start_fdi)
                if i < 0 or i >= len(cxs):
                    continue
                try:
                    fx = float(cxs[i])
                except Exception:
                    continue
                try:
                    fy = float(ys[i]) if i < len(ys) else float(dot_y)
                except Exception:
                    fy = float(dot_y)
                try:
                    self._manual_scan_create_missing(int(f), dot_x=float(fx), dot_y=float(fy), reason="end_auto")
                    self._manual_scan_register_fdi(int(f))
                    created_any = True
                    try:
                        self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {int(f)} (Ελλείπον)")
                    except Exception:
                        pass
                except Exception:
                    continue
        else:
            try:
                if not self._manual_scan_is_registered(int(cur)):
                    self._manual_scan_create_missing(int(cur), dot_x=float(dot_x), dot_y=float(dot_y), reason="end_auto")
                    self._manual_scan_register_fdi(int(cur))
                    created_any = True
                    try:
                        self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {int(cur)} (Ελλείπον)")
                    except Exception:
                        pass
            except Exception:
                pass
        if created_any:
            try:
                nxt_fdi, nxt_q = self._manual_scan_next_fdi_and_quadrant(int(end_fdi), cfg=cfg)
                self._scan_next_fdi = int(nxt_fdi) if nxt_fdi is not None else 0
            except Exception:
                pass

    def _start_manual_scan_q1(self):
        self._start_manual_scan("q1")

    def _start_manual_scan(self, quadrant: str = "q1"):
        if not self.pixmap_item:
            return
        try:
            self._abort_running_analysis("manual_scan")
        except Exception:
            pass
        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg(quadrant)
        except Exception:
            cfg = {"quadrant": "q1", "fdi_start": 11, "fdi_end": 18, "is_upper": True, "is_left": True, "direction_right": False}
        try:
            self._manual_scan_quadrant = str(cfg.get("quadrant") or "q1")
        except Exception:
            self._manual_scan_quadrant = "q1"
        try:
            cb = getattr(self, "zoning_quadrant_combo", None)
            qv = str(getattr(self, "_manual_scan_quadrant", "") or "").strip().lower()
            if cb is not None and qv in ("q1", "q2", "q3", "q4"):
                try:
                    idx = int(cb.findData(qv))
                except Exception:
                    idx = -1
                if idx >= 0:
                    try:
                        cb.blockSignals(True)
                    except Exception:
                        pass
                    try:
                        cb.setCurrentIndex(int(idx))
                    except Exception:
                        pass
                    try:
                        cb.blockSignals(False)
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18
        try:
            self._trace_log("manual_scan_started", {"quadrant": str(cfg.get("quadrant") or quadrant), "start_fdi": int(start_fdi), "end_fdi": int(end_fdi)})
        except Exception:
            pass
        try:
            self._stop_scanning_animation()
        except Exception:
            pass
        try:
            self._stop_ai_q1_scan_overlay()
        except Exception:
            pass
        try:
            self._manual_scan_prev_auto_pipeline_enabled = bool(getattr(self, "auto_pipeline_enabled", True))
            self._manual_scan_prev_auto_analyze_on_open = bool(getattr(self, "auto_analyze_on_open", True))
            self.auto_pipeline_enabled = False
            self.auto_analyze_on_open = False
            try:
                if getattr(self, "auto_pipeline_checkbox", None) is not None:
                    self.auto_pipeline_checkbox.setEnabled(False)
                    self.auto_pipeline_checkbox.blockSignals(True)
                    self.auto_pipeline_checkbox.setChecked(False)
                    self.auto_pipeline_checkbox.blockSignals(False)
            except Exception:
                pass
            try:
                if getattr(self, "auto_analyze_on_open_checkbox", None) is not None:
                    self.auto_analyze_on_open_checkbox.setEnabled(False)
                    self.auto_analyze_on_open_checkbox.blockSignals(True)
                    self.auto_analyze_on_open_checkbox.setChecked(False)
                    self.auto_analyze_on_open_checkbox.blockSignals(False)
            except Exception:
                pass
        except Exception:
            self._manual_scan_prev_auto_pipeline_enabled = None
            self._manual_scan_prev_auto_analyze_on_open = None
        try:
            prev_auto = bool(getattr(self, "auto_fdi_enabled", False))
            self._manual_scan_prev_auto_fdi = prev_auto
            self._set_auto_fdi_enabled_internal(False)
            if hasattr(self, "auto_fdi_checkbox") and self.auto_fdi_checkbox is not None:
                self.auto_fdi_checkbox.setEnabled(False)
                self.auto_fdi_checkbox.blockSignals(True)
                self.auto_fdi_checkbox.setChecked(False)
                self.auto_fdi_checkbox.blockSignals(False)
        except Exception:
            self._manual_scan_prev_auto_fdi = None
        try:
            self._manual_scan_prev_analyze_enabled = bool(getattr(self, "analyze_button", None).isEnabled()) if getattr(self, "analyze_button", None) is not None else None
        except Exception:
            self._manual_scan_prev_analyze_enabled = None
        try:
            self._manual_scan_prev_verify_enabled = bool(getattr(self, "verify_button", None).isEnabled()) if getattr(self, "verify_button", None) is not None else None
        except Exception:
            self._manual_scan_prev_verify_enabled = None
        try:
            if getattr(self, "analyze_button", None) is not None:
                self.analyze_button.setEnabled(False)
        except Exception:
            pass
        try:
            if getattr(self, "verify_button", None) is not None:
                self.verify_button.setEnabled(False)
        except Exception:
            pass
        try:
            try:
                from PyQt6.QtCore import QProcess
            except Exception:
                QProcess = None
            p = getattr(self, "_analysis_proc", None)
            if p is not None and QProcess is not None:
                try:
                    self._analysis_abort_reason = "manual_scan"
                except Exception:
                    pass
                try:
                    p.setProperty("stoma_abort_reason", "manual_scan")
                except Exception:
                    pass
                try:
                    if p.state() != QProcess.ProcessState.NotRunning:
                        try:
                            p.terminate()
                        except Exception:
                            pass
                        try:
                            p.waitForFinished(1200)
                        except Exception:
                            pass
                        try:
                            if p.state() != QProcess.ProcessState.NotRunning:
                                p.kill()
                                p.waitForFinished(800)
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    p.deleteLater()
                except Exception:
                    pass
            self._analysis_proc = None
        except Exception:
            pass
        try:
            w = getattr(self, "_analysis_watchdog", None)
            if w is not None:
                w.stop()
                w.deleteLater()
            self._analysis_watchdog = None
        except Exception:
            pass
        try:
            tmr = getattr(self, "_analysis_prog_timer", None)
            if tmr is not None:
                tmr.stop()
                tmr.deleteLater()
            self._analysis_prog_timer = None
        except Exception:
            pass
        try:
            rect = self.pixmap_item.mapToScene(self.pixmap_item.boundingRect()).boundingRect()
        except Exception:
            rect = self.pixmap_item.boundingRect()

        self._scan_mid_x = self._get_vertical_split_x()
        if self._scan_mid_x <= 0:
            self._scan_mid_x = rect.center().x()
        
        # Ensure scan mid x is safely inside bounds to prevent immediate termination
        if self._scan_mid_x < rect.left() + 5:
            self._scan_mid_x = rect.left() + 5
        if self._scan_mid_x > rect.right() - 5:
            self._scan_mid_x = rect.right() - 5

        self._scan_left_limit = rect.left()
        self._scan_right_limit = rect.right()
        self._scan_current_offset = 0.0
        
        # Initialize speed from slider
        try:
            val = 40
            if hasattr(self, "scan_speed_slider") and self.scan_speed_slider:
                val = self.scan_speed_slider.value()
            self._update_scan_speed(val)
        except Exception:
            self._scan_speed_px_per_sec = 100.0
            
        self._scan_next_fdi = int(start_fdi)
        try:
            self._manual_scan_registered = set()
        except Exception:
            pass
        try:
            self._manual_scan_last_committed_fdi = int(start_fdi) - 1
        except Exception:
            pass
        try:
            self._manual_scan_current_fdi = int(start_fdi)
        except Exception:
            pass
        try:
            self._scan_direction_right = bool(cfg.get("direction_right"))
        except Exception:
            self._scan_direction_right = False

        top = rect.top()
        bottom = rect.bottom()
        try:
            self._scan_top = float(top)
            self._scan_bottom = float(bottom)
        except Exception:
            pass

        try:
            self._cleanup_scanning_mode(reveal_all=False, restore_state=False)
        except Exception:
            pass
        try:
            self._manual_scan_block_ai = True
        except Exception:
            pass

        self._manual_scan_active = True
        self._manual_scan_paused = False
        self.scanning_mode_active = True

        self._scan_line_L = QGraphicsLineItem(self._scan_mid_x, top, self._scan_mid_x, bottom)
        pen = QPen(QColor("#3498db"))
        pen.setWidth(4)
        self._scan_line_L.setPen(pen)
        self._scan_line_L.setZValue(9999)
        try:
            self._scan_line_L.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
            self._scan_line_L.setAcceptHoverEvents(False)
        except Exception:
            pass
        self.scene.addItem(self._scan_line_L)

        self._scan_line_R = None

        self._scanning_label = QGraphicsTextItem("Έναρξη: Μέση")
        self._scanning_label.setDefaultTextColor(QColor("#3498db"))
        font = QFont()
        font.setBold(True)
        font.setPointSize(12)
        self._scanning_label.setFont(font)
        self._scanning_label.setPos(self._scan_mid_x - 70, top + 20)
        self._scanning_label.setZValue(10000)
        try:
            self._scanning_label.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
        except Exception:
            pass
        self.scene.addItem(self._scanning_label)

        try:
            y0 = None
            try:
                zl1 = getattr(self, "zone_line_1", None)
                zl2 = getattr(self, "zone_line_2", None)
                if bool(cfg.get("is_upper")):
                    if self._is_scene_item_alive(zl1) and self._is_scene_item_alive(zl2):
                        y0 = (float(zl1.y()) + float(zl2.y())) / 2.0
                else:
                    if self._is_scene_item_alive(zl2):
                        y0 = float(zl2.y()) + (float(bottom) - float(zl2.y())) * 0.30
            except Exception:
                y0 = None
            if y0 is None:
                y0 = float(rect.center().y())
            self._scan_cusp_dot = ScanCuspDot(radius=6.0, viewer_widget=self)
            self._scan_cusp_dot.setPos(float(self._scan_mid_x), float(y0))
            self.scene.addItem(self._scan_cusp_dot)
        except Exception:
            self._scan_cusp_dot = None
        try:
            if not isinstance(getattr(self, "_manual_scan_cusp_points", None), dict):
                self._manual_scan_cusp_points = {}
        except Exception:
            pass
        try:
            if str(cfg.get("quadrant") or "") == "q1":
                if not isinstance(getattr(self, "_q1_cusp_points", None), dict):
                    self._q1_cusp_points = {}
        except Exception:
            pass

        self._scan_timer = QTimer(self)
        # Fixed 30ms interval for smooth animation (speed is controlled by px_per_sec)
        self._scan_timer.setInterval(30)
        self._scan_timer.timeout.connect(self._step_scanning_animation)
        self._scan_last_time = time.perf_counter()
        self._scan_timer.start()

        try:
            self._manual_scan_preview_labels_update()
        except Exception:
            pass
        try:
            self._announce_action_done(f"Έναρξη σάρωσης {str(cfg.get('quadrant') or '').upper()}")
        except Exception:
            pass

        try:
            self.zoning_scan_button.setText("Παύση")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_register_button", None):
                self.zoning_register_button.setEnabled(True)
                self.zoning_register_button.setText(f"Καταχώρηση ({int(start_fdi)})")
        except Exception:
            pass
        try:
            if getattr(self, "zoning_skip_button", None):
                self.zoning_skip_button.setEnabled(False)
                self.zoning_skip_button.setText(f"Παράλειψη ({int(start_fdi)})")
        except Exception:
            pass

    def _learn_q1_spacing_from_scene(self):
        try:
            if not getattr(self, "scene", None):
                return None
            cfg = self._manual_scan_quadrant_cfg()
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
            direction_right = bool(cfg.get("direction_right"))
            try:
                rect = self.pixmap_item.mapToScene(self.pixmap_item.boundingRect()).boundingRect() if self.pixmap_item else None
            except Exception:
                rect = self.pixmap_item.boundingRect() if self.pixmap_item else None
            mid_x = float(self._get_vertical_split_x() or 0.0)
            if mid_x <= 0 and rect is not None:
                mid_x = float(rect.center().x())

            xs_by_fdi = {}
            ys_by_fdi = {}
            try:
                cusp = getattr(self, "_manual_scan_cusp_points", None)
                if not isinstance(cusp, dict):
                    cusp = getattr(self, "_q1_cusp_points", None)
                if isinstance(cusp, dict):
                    for k, v in list(cusp.items()):
                        try:
                            kk = int(k)
                            if kk < int(start_fdi) or kk > int(end_fdi):
                                continue
                            if isinstance(v, (list, tuple)) and len(v) >= 2:
                                xs_by_fdi[kk] = float(v[0])
                                ys_by_fdi[kk] = float(v[1])
                        except Exception:
                            continue
            except Exception:
                pass
            for it in list(self.scene.items()):
                if not isinstance(it, EditableTextItem):
                    continue
                try:
                    s = str(it.toPlainText() or "").strip()
                    if not s.isdigit():
                        continue
                    v = int(s)
                except Exception:
                    continue
                if v < int(start_fdi) or v > int(end_fdi):
                    continue
                if v in xs_by_fdi and v in ys_by_fdi:
                    continue
                r = getattr(it, "rect_item", None)
                if r is None or r.scene() != self.scene:
                    continue
                try:
                    st = []
                    if hasattr(r, "get_statuses"):
                        st = r.get_statuses() or []
                    if any(str(x).strip().lower() == "missing" for x in st):
                        continue
                except Exception:
                    pass
                try:
                    br = r.sceneBoundingRect()
                    xs_by_fdi[v] = float(br.center().x())
                    ys_by_fdi[v] = float(br.center().y())
                except Exception:
                    continue

            deltas = []
            for f in range(int(start_fdi), int(end_fdi)):
                if f in xs_by_fdi and (f + 1) in xs_by_fdi:
                    dx = float(xs_by_fdi[f + 1] - xs_by_fdi[f]) if direction_right else float(xs_by_fdi[f] - xs_by_fdi[f + 1])
                    if dx > 0:
                        deltas.append(dx)
            if not deltas:
                return None
            base = float(np.median(np.array(deltas, dtype=np.float64)))
            if not (base > 0):
                return None
            full = []
            for f in range(int(start_fdi), int(end_fdi)):
                if f in xs_by_fdi and (f + 1) in xs_by_fdi:
                    dx = float(xs_by_fdi[f + 1] - xs_by_fdi[f]) if direction_right else float(xs_by_fdi[f] - xs_by_fdi[f + 1])
                    if dx > 0:
                        full.append(dx)
                    else:
                        full.append(base)
                else:
                    full.append(base)

            start_offset = None
            if int(start_fdi) in xs_by_fdi:
                start_offset = float(xs_by_fdi[int(start_fdi)] - mid_x) if direction_right else float(mid_x - xs_by_fdi[int(start_fdi)])
            elif int(start_fdi + 1) in xs_by_fdi:
                if direction_right:
                    start_offset = float(xs_by_fdi[int(start_fdi + 1)] - full[0] - mid_x)
                else:
                    start_offset = float(mid_x - (xs_by_fdi[int(start_fdi + 1)] + full[0]))
            if start_offset is None or start_offset <= 0:
                return None

            cxs_expected = []
            cx = float(mid_x) + float(start_offset) if direction_right else float(mid_x) - float(start_offset)
            for i in range(8):
                cxs_expected.append(float(cx))
                if i < 7:
                    cx = (cx + float(full[i])) if direction_right else (cx - float(full[i]))
            cxs_full = [float(xs_by_fdi.get(f, cxs_expected[f - int(start_fdi)])) for f in range(int(start_fdi), int(end_fdi) + 1)]
            for i in range(1, 8):
                if (int(start_fdi) + i) not in xs_by_fdi and (int(start_fdi) + i - 1) in xs_by_fdi:
                    cxs_full[i] = float(cxs_full[i - 1]) + float(full[i - 1]) if direction_right else float(cxs_full[i - 1]) - float(full[i - 1])
            for i in range(6, -1, -1):
                if (int(start_fdi) + i) not in xs_by_fdi and (int(start_fdi) + i + 1) in xs_by_fdi:
                    cxs_full[i] = float(cxs_full[i + 1]) - float(full[i]) if direction_right else float(cxs_full[i + 1]) + float(full[i])

            y_vals = [float(ys_by_fdi[k]) for k in sorted(ys_by_fdi.keys()) if k in ys_by_fdi]
            y_base = float(np.median(np.array(y_vals, dtype=np.float64))) if y_vals else None
            ys_full = []
            for f in range(int(start_fdi), int(end_fdi) + 1):
                if f in ys_by_fdi:
                    ys_full.append(float(ys_by_fdi[f]))
                elif y_base is not None:
                    ys_full.append(float(y_base))
                else:
                    ys_full.append(float(0.0))

            tpl = {
                "quadrant": str(cfg.get("quadrant") or ""),
                "direction_right": bool(direction_right),
                "start_offset_px": float(start_offset),
                "deltas_px": [float(x) for x in full],
                "cxs_px": [float(x) for x in cxs_full],
                "ys_px": [float(y) for y in ys_full],
            }
            try:
                ts = getattr(self, "_tooth_spacing", None)
                if not isinstance(ts, dict):
                    ts = {}
                    self._tooth_spacing = ts
                ts[str(cfg.get("quadrant") or "q1")] = tpl
            except Exception:
                pass
            try:
                if str(cfg.get("quadrant") or "") == "q1":
                    self._q1_spacing_template = tpl
            except Exception:
                pass
            try:
                self.results_text_edit.append(f"Αποθηκεύτηκε πρότυπο {str(cfg.get('quadrant') or '').upper()} από χειροκίνητη στοίχιση.")
            except Exception:
                pass
            try:
                self._manual_scan_preview_labels_update()
            except Exception:
                pass
            return tpl
        except Exception:
            return None

    # --- PRECISION SCANNING VISUALIZATION (Corrected: Midline Outwards) ---
    def toggle_scanning_visualization(self, enabled: bool):
        """
        Activates/Deactivates the Tooth Counting Visualization.
        Scans from the Midline OUTWARDS (Left & Right simultaneously) with a BLUE line,
        simulating the systematic tooth counting process (11->18, 21->28, etc.).
        """
        if enabled:
            self._start_manual_scan_q1()
        else:
            self._cleanup_scanning_mode(reveal_all=True)
            try:
                self.zoning_scan_button.setText("Σάρωση Επαλήθευσης")
            except Exception:
                pass

    def _mark_current_tooth_and_continue(self, fdi_override: int | None = None):
        """
        Manual Verification Logic:
        1. Find detected box closest to the Left Scan Line.
        2. Assign the next FDI number (e.g. 11, then 12...).
        3. Force alignment.
        4. Resume scanning.
        """
        if not hasattr(self, "_scan_line_L"): return
        
        # Current Line X
        line_x = self._scan_line_L.line().x1()
        dot_pt = None
        try:
            dot = getattr(self, "_scan_cusp_dot", None)
            if dot is not None and dot.scene() == self.scene:
                dot_pt = dot.sceneBoundingRect().center()
        except Exception:
            dot_pt = None

        dot_x = float(line_x)
        dot_y = None
        try:
            if dot_pt is not None:
                dot_x = float(dot_pt.x())
                dot_y = float(dot_pt.y())
        except Exception:
            dot_y = None

        cfg = {}
        try:
            cfg = self._manual_scan_quadrant_cfg()
        except Exception:
            cfg = {}
        try:
            start_fdi = int(cfg.get("fdi_start", 11) or 11)
            end_fdi = int(cfg.get("fdi_end", 18) or 18)
        except Exception:
            start_fdi, end_fdi = 11, 18

        try:
            fdi = int(fdi_override) if fdi_override is not None else int(self._scan_next_fdi)
        except Exception:
            fdi = int(getattr(self, "_scan_next_fdi", 11) or 11)
        try:
            if int(fdi) < int(start_fdi) or int(fdi) > int(end_fdi):
                return
        except Exception:
            pass
        
        # Find closest hidden or visible item
        best_item = None
        min_dist = float('inf')
        expected_x = None
        try:
            q = str(cfg.get("quadrant") or "q1")
        except Exception:
            q = "q1"
        try:
            tpl = None
            try:
                tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
            except Exception:
                tpl = None
            if tpl is None:
                ts = getattr(self, "_tooth_spacing", None)
                if isinstance(ts, dict):
                    tpl = ts.get(q)
            if isinstance(tpl, dict) and isinstance(tpl.get("cxs_px"), list):
                i0 = int(fdi) - int(start_fdi)
                cxs = tpl.get("cxs_px") or []
                if 0 <= int(i0) < len(cxs):
                    expected_x = float(cxs[int(i0)])
        except Exception:
            expected_x = None
        
        candidates = []
        if hasattr(self, "_temp_hidden_items"):
            candidates.extend(self._temp_hidden_items)
        # Also check visible items in case they were already revealed
        for item in self.scene.items():
            if isinstance(item, EditableRectItem) and item not in candidates:
                candidates.append(item)
                
        for item in candidates:
            if not isinstance(item, EditableRectItem): continue
            try:
                if item.text_item is not None:
                    txt = str(item.text_item.toPlainText() or "").strip()
                    if txt.isdigit():
                        continue
            except Exception:
                pass
            try:
                br0 = item.sceneBoundingRect()
                cx0 = float(br0.center().x())
                cy0 = float(br0.center().y())
                if not self._manual_scan_item_in_quadrant(float(cx0), float(cy0), cfg):
                    continue
            except Exception:
                pass
            
            # Get item center X in scene coordinates
            scene_br = item.sceneBoundingRect()
            item_cx = scene_br.center().x()
            item_cy = scene_br.center().y()
            
            # Check distance to line
            try:
                dx = abs(float(item_cx) - float(expected_x)) if expected_x is not None else abs(float(item_cx) - float(line_x))
            except Exception:
                dx = abs(item_cx - line_x)
            try:
                dy = abs(float(item_cy) - float(dot_y)) if dot_y is not None else 0.0
            except Exception:
                dy = 0.0
            dist = float(dx) + (0.25 * float(dy))
            
            # Tighten tolerance when template exists to avoid assigning wrong tooth
            tol = 200.0 if expected_x is None else 90.0
            if float(dist) < float(tol):
                if dist < min_dist:
                    min_dist = dist
                    best_item = item
        
        try:
            if dot_pt is not None:
                m = getattr(self, "_manual_scan_cusp_points", None)
                if not isinstance(m, dict):
                    m = {}
                    self._manual_scan_cusp_points = m
                m[int(fdi)] = (float(line_x), float(dot_pt.y()))
                try:
                    if str(cfg.get("quadrant") or "") == "q1":
                        m2 = getattr(self, "_q1_cusp_points", None)
                        if not isinstance(m2, dict):
                            m2 = {}
                            self._q1_cusp_points = m2
                        m2[int(fdi)] = (float(line_x), float(dot_pt.y()))
                except Exception:
                    pass
        except Exception:
            pass

        if dot_y is None:
            try:
                dot_y = float(self._scan_line_L.line().y1() + self._scan_line_L.line().y2()) / 2.0
            except Exception:
                dot_y = float(0.0)

        try:
            fdi_str0 = str(int(fdi))
            fdi_item = None
            for it in self.scene.items():
                if not isinstance(it, EditableRectItem):
                    continue
                ti = getattr(it, "text_item", None)
                if ti is None or ti.scene() != self.scene:
                    continue
                if str(ti.toPlainText() or "").strip() != fdi_str0:
                    continue
                try:
                    br0 = it.sceneBoundingRect()
                    cx0 = float(br0.center().x())
                    cy0 = float(br0.center().y())
                    if not self._manual_scan_item_in_quadrant(float(cx0), float(cy0), cfg):
                        continue
                except Exception:
                    pass
                fdi_item = it
                break
            if fdi_item is not None:
                best_item = fdi_item
                try:
                    min_dist = abs(float(best_item.sceneBoundingRect().center().x()) - float(line_x))
                except Exception:
                    min_dist = 0.0
        except Exception:
            pass
        
        if best_item:
            # Assign FDI
            if int(start_fdi) <= int(fdi) <= int(end_fdi):
                fdi_str = str(fdi)
                
                # Update Item
                try:
                    if getattr(best_item, "text_item", None) is None or best_item.text_item.scene() != self.scene:
                        best_item.text_item = EditableTextItem(fdi_str, rect_item=best_item, on_change_callback=self.debounced_recalculate_fdi)
                        best_item.text_item.setDefaultTextColor(QColor("red"))
                        self.scene.addItem(best_item.text_item)
                    else:
                        best_item.text_item.setPlainText(fdi_str)
                    best_item.setVisible(True)
                    best_item.text_item.setVisible(True)
                    if dot_pt is not None:
                        brt = best_item.text_item.boundingRect()
                        best_item.text_item.setPos(float(dot_x) - (float(brt.width()) / 2.0), float(dot_y) - (float(brt.height()) / 2.0))
                        try:
                            r = best_item.rect()
                            box_tl = best_item.scenePos() + QPointF(float(r.x()), float(r.y()))
                            best_item.label_offset = QPointF(float(best_item.text_item.pos().x()) - float(box_tl.x()), float(best_item.text_item.pos().y()) - float(box_tl.y()))
                            best_item.label_offset_user = True
                        except Exception:
                            pass
                    else:
                        self._position_label_for_rect(best_item)
                except Exception:
                    pass
                
                # Visual Feedback
                self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {fdi_str} (απόσταση: {min_dist:.1f}px)")
                
                try:
                    self._manual_scan_announce_commit(int(fdi), rect_item=best_item, is_missing=False)
                except Exception:
                    pass
                try:
                    self._learn_q1_spacing_from_scene()
                    self._schedule_layout_save(0)
                except Exception:
                    pass
                try:
                    nxt_fdi = None
                    nxt_q = None
                    nxt_fdi, nxt_q = self._manual_scan_next_fdi_and_quadrant(int(fdi), cfg=cfg)
                except Exception:
                    nxt_fdi = None
                    nxt_q = None
                try:
                    if getattr(self, "zoning_register_button", None):
                        if nxt_fdi is not None:
                            self.zoning_register_button.setText(f"Καταχώρηση ({int(nxt_fdi)})")
                except Exception:
                    pass
                try:
                    if getattr(self, "zoning_skip_button", None):
                        self.zoning_skip_button.setEnabled(True)
                        if nxt_fdi is not None:
                            self.zoning_skip_button.setText(f"Παράλειψη ({int(nxt_fdi)})")
                        else:
                            self.zoning_skip_button.setText("Παράλειψη")
                except Exception:
                    pass
                
                # Force Update
                self.scene.update()
                
                try:
                    self._manual_scan_register_fdi(int(fdi))
                except Exception:
                    pass
                try:
                    self._manual_scan_log_sample(
                        fdi=int(fdi),
                        kind="present",
                        dot_x=float(dot_x),
                        dot_y=float(dot_y),
                        rect_item=best_item,
                        reason="register",
                    )
                except Exception:
                    pass
                try:
                    nxt_fdi2 = None
                    nxt_q2 = None
                    nxt_fdi2, nxt_q2 = self._manual_scan_next_fdi_and_quadrant(int(fdi), cfg=cfg)
                    self._scan_next_fdi = int(nxt_fdi2) if nxt_fdi2 is not None else 0
                except Exception:
                    try:
                        self._scan_next_fdi = 0
                    except Exception:
                        pass
                try:
                    self._manual_scan_current_fdi = int(nxt_fdi2) if nxt_fdi2 is not None else 0
                except Exception:
                    pass
                try:
                    if nxt_q2 and str(nxt_q2).strip().lower() != str(cfg.get("quadrant") or "").strip().lower():
                        print(f"DEBUG: Transitioning (existing rect) from {cfg.get('quadrant')} to {nxt_q2}")
                        self._manual_scan_paused = True
                        QTimer.singleShot(50, lambda q=str(nxt_q2): self._start_manual_scan(q))
                        return
                except Exception:
                    pass
        else:
            if int(start_fdi) <= int(fdi) <= int(end_fdi):
                try:
                    sx = getattr(self, 'pixel_to_mm_scale_x', 1.0) or 1.0
                    sy = getattr(self, 'pixel_to_mm_scale_y', 1.0) or 1.0
                    width_mm = 10.0 if int(fdi) >= int(start_fdi) + 5 else 8.0
                    w_px = float(width_mm) * float(sx)
                    h_px = w_px * 2.2
                    y_ref = None
                    try:
                        if bool(cfg.get("is_upper")) and self._is_scene_item_alive(getattr(self, "zone_line_1", None)) and self._is_scene_item_alive(getattr(self, "zone_line_2", None)):
                            y_ref = (float(self.zone_line_1.y()) + float(self.zone_line_2.y())) / 2.0
                    except Exception:
                        y_ref = None
                    if dot_y is not None:
                        y_ref = float(dot_y)
                    if y_ref is None:
                        y_ref = float(self._scan_line_L.line().y1() + self._scan_line_L.line().y2()) / 2.0
                    x1 = float(dot_x) - (w_px / 2.0)
                    y1 = float(y_ref) - (h_px / 2.0)
                    rect_item = EditableRectItem(x=x1, y=y1, w=w_px, h=h_px, on_change_callback=self.debounced_recalculate_fdi)
                    self.scene.addItem(rect_item)
                    try:
                        rect_item.setZValue(8000)
                    except Exception:
                        pass
                    treat_as_missing = False
                    try:
                        ar = getattr(self, "analysis_results", None)
                        if isinstance(ar, dict):
                            bx = ar.get("boxes", [])
                            if isinstance(bx, list) and len(bx) > 0:
                                treat_as_missing = True
                    except Exception:
                        treat_as_missing = False
                    if not treat_as_missing:
                        try:
                            for it0 in candidates:
                                if not isinstance(it0, EditableRectItem):
                                    continue
                                try:
                                    n0 = str(it0.get_notes() or "").strip().lower()
                                except Exception:
                                    n0 = ""
                                if n0.startswith("manual"):
                                    continue
                                ti0 = getattr(it0, "text_item", None)
                                if ti0 is None or ti0.scene() != self.scene:
                                    continue
                                t0 = str(ti0.toPlainText() or "").strip()
                                if t0.isdigit():
                                    continue
                                treat_as_missing = True
                                break
                        except Exception:
                            pass
                    if treat_as_missing:
                        rect_item.set_statuses(["Missing"], notify=False)
                        rect_item.set_notes("Manual Gap")
                    else:
                        rect_item.set_statuses([], notify=False)
                        rect_item.set_notes("Manual")
                    text_item = EditableTextItem(str(fdi), rect_item=rect_item, on_change_callback=self.debounced_recalculate_fdi)
                    text_item.setDefaultTextColor(QColor("red"))
                    self.scene.addItem(text_item)
                    try:
                        text_item.setZValue(8001)
                    except Exception:
                        pass
                    if dot_pt is not None:
                        brt = text_item.boundingRect()
                        text_item.setPos(float(dot_x) - (float(brt.width()) / 2.0), float(dot_y) - (float(brt.height()) / 2.0))
                        try:
                            r = rect_item.rect()
                            box_tl = rect_item.scenePos() + QPointF(float(r.x()), float(r.y()))
                            rect_item.label_offset = QPointF(float(text_item.pos().x()) - float(box_tl.x()), float(text_item.pos().y()) - float(box_tl.y()))
                            rect_item.label_offset_user = True
                        except Exception:
                            pass
                    else:
                        self._position_label_for_rect(rect_item)
                    if treat_as_missing:
                        self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {fdi} (Missing)")
                    else:
                        self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {fdi}")
                    try:
                        self._manual_scan_announce_commit(int(fdi), rect_item=rect_item, is_missing=bool(treat_as_missing))
                    except Exception:
                        pass
                    try:
                        self._learn_q1_spacing_from_scene()
                        self._schedule_layout_save(0)
                    except Exception:
                        pass
                    try:
                        self._manual_scan_register_fdi(int(fdi))
                    except Exception:
                        pass
                    try:
                        self._manual_scan_log_sample(
                            fdi=int(fdi),
                            kind="present" if (not bool(treat_as_missing)) else "missing",
                            dot_x=float(dot_x),
                            dot_y=float(dot_y),
                            rect_item=rect_item,
                            reason="register_new_rect",
                        )
                    except Exception:
                        pass
                    try:
                        nxt_fdi, nxt_q = self._manual_scan_next_fdi_and_quadrant(int(fdi), cfg=cfg)
                    except Exception:
                        nxt_fdi, nxt_q = None, None
                    try:
                        if getattr(self, "zoning_register_button", None):
                            if nxt_fdi is not None:
                                self.zoning_register_button.setText(f"Καταχώρηση ({int(nxt_fdi)})")
                    except Exception:
                        pass
                    try:
                        if getattr(self, "zoning_skip_button", None):
                            self.zoning_skip_button.setEnabled(True)
                            if nxt_fdi is not None:
                                self.zoning_skip_button.setText(f"Παράλειψη ({int(nxt_fdi)})")
                            else:
                                self.zoning_skip_button.setText("Παράλειψη")
                    except Exception:
                        pass
                    try:
                        self._scan_next_fdi = int(nxt_fdi) if nxt_fdi is not None else 0
                    except Exception:
                        try:
                            self._scan_next_fdi = 0
                        except Exception:
                            pass
                    try:
                        self._manual_scan_current_fdi = int(nxt_fdi) if nxt_fdi is not None else 0
                    except Exception:
                        pass
                    try:
                        if nxt_q and str(nxt_q).strip().lower() != str(cfg.get("quadrant") or "").strip().lower():
                            print(f"DEBUG: Transitioning (fallback create) from {cfg.get('quadrant')} to {nxt_q}")
                            self._manual_scan_paused = True
                            QTimer.singleShot(50, lambda q=str(nxt_q): self._start_manual_scan(q))
                            return
                    except Exception:
                        pass
                except Exception:
                    self.results_text_edit.append(f"⚠️ Δεν βρέθηκε δόντι κοντά στη γραμμή (X={line_x:.0f}).")
                    self._announce_action_done("Δεν βρέθηκε")
            else:
                self.results_text_edit.append(f"⚠️ Δεν βρέθηκε δόντι κοντά στη γραμμή (X={line_x:.0f}).")
                self._announce_action_done("Δεν βρέθηκε")
            
        try:
            if int(start_fdi) <= int(fdi) <= int(end_fdi):
                if self._manual_scan_find_rect_for_fdi(int(fdi)) is None:
                    sx = getattr(self, 'pixel_to_mm_scale_x', 1.0) or 1.0
                    w_mm, h_mm = self._get_avg_tooth_dims(int(fdi))
                    w_px = float(w_mm) * float(sx)
                    h_px = float(h_mm) * float(sx)
                    y_ref = None
                    try:
                        if bool(cfg.get("is_upper")) and self._is_scene_item_alive(getattr(self, "zone_line_1", None)) and self._is_scene_item_alive(getattr(self, "zone_line_2", None)):
                            y_ref = (float(self.zone_line_1.y()) + float(self.zone_line_2.y())) / 2.0
                    except Exception:
                        y_ref = None
                    if dot_y is not None:
                        y_ref = float(dot_y)
                    if y_ref is None:
                        y_ref = float(self._scan_line_L.line().y1() + self._scan_line_L.line().y2()) / 2.0
                    x1 = float(dot_x) - (w_px / 2.0)
                    y1 = float(y_ref) - (h_px / 2.0)
                    rect_item = EditableRectItem(x=x1, y=y1, w=w_px, h=h_px, on_change_callback=self.debounced_recalculate_fdi)
                    self.scene.addItem(rect_item)
                    rect_item.set_statuses([], notify=False)
                    rect_item.set_notes("Manual")
                    try:
                        rect_item.setZValue(8000)
                    except Exception:
                        pass
                    text_item = EditableTextItem(str(int(fdi)), rect_item=rect_item, on_change_callback=self.debounced_recalculate_fdi)
                    text_item.setDefaultTextColor(QColor("red"))
                    self.scene.addItem(text_item)
                    try:
                        text_item.setZValue(8001)
                    except Exception:
                        pass
                    try:
                        brt = text_item.boundingRect()
                        text_item.setPos(float(dot_x) - (float(brt.width()) / 2.0), float(y_ref) - (float(brt.height()) / 2.0))
                    except Exception:
                        self._position_label_for_rect(rect_item)
                    try:
                        self.results_text_edit.append(f"✅ Καταχωρήθηκε Δόντι {int(fdi)}")
                    except Exception:
                        pass
                    try:
                        self._manual_scan_announce_commit(int(fdi), rect_item=rect_item, is_missing=False)
                    except Exception:
                        pass
                    try:
                        self._manual_scan_register_fdi(int(fdi))
                    except Exception:
                        pass
                    try:
                        self._manual_scan_log_sample(
                            fdi=int(fdi),
                            kind="present",
                            dot_x=float(dot_x),
                            dot_y=float(y_ref),
                            rect_item=rect_item,
                            reason="fallback_create_rect",
                        )
                    except Exception:
                        pass
        except Exception:
            pass

        try:
            if not bool(getattr(self, "_manual_scan_paused", False)):
                QTimer.singleShot(500, self._resume_scanning)
        except Exception:
            QTimer.singleShot(500, self._resume_scanning)

    def _resume_scanning(self):
        try:
            if bool(getattr(self, "_manual_scan_paused", False)):
                return
        except Exception:
            pass
        if hasattr(self, "_scan_timer"):
            self._scan_last_time = time.perf_counter()
            self._scan_timer.start()
            try:
                self.zoning_scan_button.setText("Παύση")
            except Exception:
                self.zoning_scan_button.setText("Παύση")
            try:
                if getattr(self, "zoning_register_button", None):
                    nxt = int(getattr(self, "_scan_next_fdi", 0) or 0)
                    self.zoning_register_button.setEnabled(True)
                    if nxt:
                        self.zoning_register_button.setText(f"Καταχώρηση ({nxt})")
                    else:
                        self.zoning_register_button.setText("Καταχώρηση")
            except Exception:
                pass
            try:
                if getattr(self, "zoning_skip_button", None):
                    self.zoning_skip_button.setEnabled(False)
            except Exception:
                pass

    def _step_scanning_animation(self):
        try:
            if not hasattr(self, "_scan_line_L") or self._scan_line_L is None: 
                return
            
            now = time.perf_counter()
            dt = now - self._scan_last_time
            if dt < 0:
                dt = 0
            if dt > 0.05:
                dt = 0.05
            self._scan_last_time = now
            
            # Update Offset (Outwards)
            move_px = float(getattr(self, "_scan_speed_px_per_sec", 2.0) or 2.0) * dt
            self._scan_current_offset += move_px
            
            cfg = {}
            try:
                cfg = self._manual_scan_quadrant_cfg()
            except Exception:
                cfg = {}
            try:
                start_fdi = int(cfg.get("fdi_start", 11) or 11)
                end_fdi = int(cfg.get("fdi_end", 18) or 18)
            except Exception:
                start_fdi, end_fdi = 11, 18
            direction_right = False
            try:
                direction_right = bool(cfg.get("direction_right"))
            except Exception:
                direction_right = False
            x_cur = (float(self._scan_mid_x) + float(self._scan_current_offset)) if direction_right else (float(self._scan_mid_x) - float(self._scan_current_offset))

            tpl = None
            try:
                q = str(cfg.get("quadrant") or "q1")
            except Exception:
                q = "q1"
            try:
                tpl = getattr(self, "_q1_spacing_template", None) if q == "q1" else None
            except Exception:
                tpl = None
            try:
                if tpl is None:
                    ts = getattr(self, "_tooth_spacing", None)
                    if isinstance(ts, dict):
                        tpl = ts.get(q)
            except Exception:
                pass
            try:
                cxs = (tpl or {}).get("cxs_px") if isinstance(tpl, dict) else None
                if isinstance(cxs, list) and len(cxs) >= 2:
                    bounds = []
                    for i in range(len(cxs) - 1):
                        try:
                            bounds.append((float(cxs[i]) + float(cxs[i + 1])) / 2.0)
                        except Exception:
                            bounds.append(None)
                    idx = 0
                    try:
                        for i, b in enumerate(bounds):
                            if b is None:
                                continue
                            if direction_right:
                                if float(x_cur) > float(b):
                                    idx = i + 1
                            else:
                                if float(x_cur) < float(b):
                                    idx = i + 1
                    except Exception:
                        idx = 0
                    cur = int(start_fdi) + int(idx)
                    try:
                        if cur < int(start_fdi):
                            cur = int(start_fdi)
                        if cur > int(end_fdi):
                            cur = int(end_fdi)
                        self._manual_scan_current_fdi = int(cur)
                    except Exception:
                        pass
                else:
                    try:
                        self._manual_scan_current_fdi = int(getattr(self, "_scan_next_fdi", start_fdi) or start_fdi)
                    except Exception:
                        pass
            except Exception:
                pass
            
            # Check Bounds
            bound = float(getattr(self, "_scan_right_limit" if direction_right else "_scan_left_limit", x_cur))
            if (direction_right and float(x_cur) >= float(bound)) or ((not direction_right) and float(x_cur) <= float(bound)):
                try:
                    x_cur = float(bound)
                except Exception:
                    pass
                self._scan_timer.stop()
                try:
                    if self._scan_line_L:
                        lineL = self._scan_line_L.line()
                        lineL.setLine(float(x_cur), lineL.y1(), float(x_cur), lineL.y2())
                        self._scan_line_L.setLine(lineL)
                except Exception:
                    pass
                try:
                    dot = getattr(self, "_scan_cusp_dot", None)
                    if dot is not None and dot.scene() == self.scene:
                        dot.setPos(float(x_cur), float(dot.pos().y()))
                except Exception:
                    pass
                try:
                    self._manual_scan_finalize_on_end()
                except Exception:
                    pass
                self.results_text_edit.append("✅ Ολοκλήρωση Σάρωσης.")
                self._cleanup_scanning_mode(reveal_all=False)
                return

            # Move Lines
            if self._scan_line_L:
                lineL = self._scan_line_L.line()
                lineL.setLine(float(x_cur), lineL.y1(), float(x_cur), lineL.y2())
                self._scan_line_L.setLine(lineL)
            try:
                dot = getattr(self, "_scan_cusp_dot", None)
                if dot is not None and dot.scene() == self.scene:
                    dot.setPos(float(x_cur), float(dot.pos().y()))
            except Exception:
                pass

            if self._scan_line_R:
                x_other = float(self._scan_mid_x) - float(self._scan_current_offset) if direction_right else float(self._scan_mid_x) + float(self._scan_current_offset)
                lineR = self._scan_line_R.line()
                lineR.setLine(float(x_other), lineR.y1(), float(x_other), lineR.y2())
                self._scan_line_R.setLine(lineR)
            
            # Update Label
            sx = getattr(self, 'pixel_to_mm_scale_x', 1.0) or 1.0
            dist_mm = self._scan_current_offset * sx
            if self._scanning_label:
                try:
                    cur_fdi = int(getattr(self, "_manual_scan_current_fdi", 0) or 0)
                except Exception:
                    cur_fdi = 0
                if cur_fdi:
                    self._scanning_label.setPlainText(f"Δόντι: {cur_fdi} | Απόσταση: {dist_mm:.1f} mm")
                else:
                    self._scanning_label.setPlainText(f"Απόσταση: {dist_mm:.1f} mm")
        except Exception as e:
            print(f"Error in scanning animation: {e}")
            self._cleanup_scanning_mode()

    def _cleanup_scanning_mode(self, reveal_all=True, restore_state: bool = True):
        if hasattr(self, "_scan_timer"):
            try:
                self._scan_timer.stop()
            except Exception:
                pass
        
        for attr in ["_scan_line_L", "_scan_line_R", "_scanning_label", "_scanning_line", "_scan_cusp_dot"]:
            if hasattr(self, attr) and getattr(self, attr):
                try:
                    it = getattr(self, attr)
                    if it and it.scene() == self.scene:
                        self.scene.removeItem(it)
                except Exception:
                    pass
                setattr(self, attr, None)
        try:
            prevs = getattr(self, "_manual_scan_preview_labels", None)
            if isinstance(prevs, dict):
                for it in list(prevs.values()):
                    try:
                        if it is not None and it.scene() == self.scene:
                            self.scene.removeItem(it)
                    except Exception:
                        pass
                prevs.clear()
        except Exception:
            pass
        if bool(restore_state):
            try:
                self._manual_scan_active = False
                self._manual_scan_paused = False
                self.scanning_mode_active = False
            except Exception:
                pass
            try:
                self._manual_scan_block_ai = False
            except Exception:
                pass
            try:
                prev_pipe = getattr(self, "_manual_scan_prev_auto_pipeline_enabled", None)
                prev_open = getattr(self, "_manual_scan_prev_auto_analyze_on_open", None)
                self._manual_scan_prev_auto_pipeline_enabled = None
                self._manual_scan_prev_auto_analyze_on_open = None
                if prev_pipe is not None:
                    self.auto_pipeline_enabled = bool(prev_pipe)
                    try:
                        if getattr(self, "auto_pipeline_checkbox", None) is not None:
                            self.auto_pipeline_checkbox.setEnabled(True)
                            self.auto_pipeline_checkbox.blockSignals(True)
                            self.auto_pipeline_checkbox.setChecked(bool(prev_pipe))
                            self.auto_pipeline_checkbox.blockSignals(False)
                    except Exception:
                        pass
                if prev_open is not None:
                    self.auto_analyze_on_open = bool(prev_open)
                    try:
                        if getattr(self, "auto_analyze_on_open_checkbox", None) is not None:
                            self.auto_analyze_on_open_checkbox.setEnabled(True)
                            self.auto_analyze_on_open_checkbox.blockSignals(True)
                            self.auto_analyze_on_open_checkbox.setChecked(bool(prev_open))
                            self.auto_analyze_on_open_checkbox.blockSignals(False)
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                prev = getattr(self, "_manual_scan_prev_analyze_enabled", None)
                self._manual_scan_prev_analyze_enabled = None
                if prev is not None and getattr(self, "analyze_button", None) is not None:
                    self.analyze_button.setEnabled(bool(prev))
            except Exception:
                pass
            try:
                prev = getattr(self, "_manual_scan_prev_verify_enabled", None)
                self._manual_scan_prev_verify_enabled = None
                if prev is not None and getattr(self, "verify_button", None) is not None:
                    self.verify_button.setEnabled(bool(prev))
            except Exception:
                pass
            try:
                prev = getattr(self, "_manual_scan_prev_auto_fdi", None)
                self._manual_scan_prev_auto_fdi = None
                if prev is not None:
                    if hasattr(self, "auto_fdi_checkbox") and self.auto_fdi_checkbox is not None:
                        self.auto_fdi_checkbox.setEnabled(True)
                        self.auto_fdi_checkbox.blockSignals(True)
                        self.auto_fdi_checkbox.setChecked(bool(prev))
                        self.auto_fdi_checkbox.blockSignals(False)
                    self._set_auto_fdi_enabled_internal(bool(prev))
            except Exception:
                pass
            try:
                self.zoning_scan_button.setText("Σάρωση Επαλήθευσης")
            except Exception:
                pass
            try:
                if getattr(self, "zoning_register_button", None):
                    self.zoning_register_button.setEnabled(False)
                    self.zoning_register_button.setText("Καταχώρηση")
            except Exception:
                pass
            try:
                if getattr(self, "zoning_skip_button", None):
                    self.zoning_skip_button.setEnabled(False)
                    self.zoning_skip_button.setText("Παράλειψη")
            except Exception:
                pass
            
    # Legacy / Placeholder for replaced methods
    def animate_zone_line(self, line_item, start_y, end_y, on_finished): pass
    def _animation_step(self): pass
    def ask_validation_zone_1(self, w, y1, y2): pass
    # show_continue_button REMOVED to avoid overwriting real implementation
    # activate_zone_2_step REMOVED to avoid overwriting real implementation
    def ask_validation_zone_2(self): pass
    # save_zoning_feedback REMOVED to avoid overwriting real implementation
    
    # Removed dangling code from old save_zoning_feedback implementation


    def _crop_and_save_zones(self, image_path, y1, y2):
        print(f"DEBUG: Starting crop for {image_path}")
        try:
            # Load original image
            # Ensure path is valid and handles unicode
            image_path_str = str(image_path)
            print(f"DEBUG: Reading image from {image_path_str}")
            
            # Use numpy to read unicode paths
            stream = open(image_path_str, "rb")
            bytes_data = bytearray(stream.read())
            numpy_array = np.asarray(bytes_data, dtype=np.uint8)
            img = cv2.imdecode(numpy_array, cv2.IMREAD_UNCHANGED)
            stream.close()
            
            if img is None: 
                print(f"DEBUG: Failed to load image: {image_path}")
                QMessageBox.warning(self, "Σφάλμα", f"Αδυναμία φόρτωσης εικόνας:\n{image_path}")
                return
            
            print(f"DEBUG: Image loaded. Shape: {img.shape}")
            
            # Use Zone Manager to split
            upper, middle, lower = self.zone_manager.extract_zones(img, int(y1), int(y2))
            print(f"DEBUG: Zones extracted. Upper: {upper.shape}, Middle: {middle.shape}, Lower: {lower.shape}")
            
            # Save crops
            base_dir = os.path.dirname(image_path_str)
            name = os.path.splitext(os.path.basename(image_path_str))[0]
            
            # Helper to save with unicode support
            def save_img(path, im):
                print(f"DEBUG: Saving to {path}")
                try:
                    is_success, im_buf = cv2.imencode(".jpg", im)
                    if is_success:
                        with open(path, "wb") as f:
                            im_buf.tofile(f)
                        print("DEBUG: Save success")
                        return True
                    else:
                        print("DEBUG: Encode failed")
                        return False
                except Exception as ex:
                    print(f"DEBUG: Save exception: {ex}")
                    return False
            
            p1 = os.path.join(base_dir, f"{name}_zone_upper.jpg")
            p2 = os.path.join(base_dir, f"{name}_zone_middle.jpg")
            p3 = os.path.join(base_dir, f"{name}_zone_lower.jpg")
            
            s1 = save_img(p1, upper)
            s2 = save_img(p2, middle)
            s3 = save_img(p3, lower)
            
            if s1 and s2 and s3:
                QMessageBox.information(self, "Επιτυχία", f"Δημιουργήθηκαν 3 εικόνες:\n{name}_zone_upper.jpg\n{name}_zone_middle.jpg\n{name}_zone_lower.jpg")
            else:
                QMessageBox.warning(self, "Σφάλμα", "Κάποια αρχεία δεν αποθηκεύτηκαν σωστά.")
            
        except Exception as e:
            print(f"DEBUG: Global exception: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(self, "Σφάλμα", f"Αποτυχία αποκοπής: {e}")

    def manual_crop_action(self):
        """
        Triggered by the manual crop button.
        Uses current zone lines if available, or predicts them.
        """
        print("DEBUG: Manual crop button clicked.")
        if not self.current_image_path:
            QMessageBox.warning(self, "Προσοχή", "Δεν υπάρχει φορτωμένη εικόνα.")
            return

        # Get positions from lines if they exist, else predict
        y1, y2 = 0, 0
        if self._is_scene_item_alive(self.zone_line_1) and self._is_scene_item_alive(self.zone_line_2):
            y1 = self.zone_line_1.y()
            y2 = self.zone_line_2.y()
            print(f"DEBUG: Using active zone lines: y1={y1}, y2={y2}")
        else:
            # Predict
            print("DEBUG: No active zone lines. Predicting...")
            if not self.pixmap_item:
                 print("DEBUG: No pixmap item. Cannot predict.")
                 return
            rect = self.pixmap_item.boundingRect()
            h = rect.height()
            w = rect.width()
            y1, y2 = self.zone_manager.predict_zones((h, w))
            print(f"DEBUG: Predicted zones: y1={y1}, y2={y2}")
            
        # Call the existing crop logic
        print("DEBUG: Calling _crop_and_save_zones...")
        self._crop_and_save_zones(self.current_image_path, y1, y2)

    def apply_layout_lock(self):
        locked = bool(self.layout_locked)

        jaw = getattr(self, "jaw_separator_line", None)
        if self._is_scene_item_alive(jaw):
            try:
                if hasattr(jaw, "set_locked"):
                    jaw.set_locked(locked)
                else:
                    jaw.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, not locked)
            except Exception:
                pass

        vline = getattr(self, "vertical_separator_line", None)
        if self._is_scene_item_alive(vline):
            try:
                vline.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, not locked)
                vline.setCursor(Qt.CursorShape.ArrowCursor if locked else Qt.CursorShape.SizeHorCursor)
            except Exception:
                pass

        gh = getattr(self, "grid_handle", None)
        if self._is_scene_item_alive(gh):
            try:
                gh.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, not locked)
                gh.setCursor(Qt.CursorShape.ArrowCursor if locked else Qt.CursorShape.SizeAllCursor)
            except Exception:
                pass

        for attr in ("grid_lines_h", "grid_lines_v", "grid_lines_v_upper", "grid_lines_v_lower", "grid_lines_v_outer_upper", "grid_lines_v_outer_lower"):
            lines = getattr(self, attr, None)
            if not lines:
                continue
            for l in list(lines):
                try:
                    if self._is_scene_item_alive(l):
                        l.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, not locked)
                        if hasattr(l, "lock_axis") and l.lock_axis in ("x", "y"):
                            if locked:
                                l.setCursor(Qt.CursorShape.ArrowCursor)
                except Exception:
                    pass
        try:
            self._sync_quick_lock_checkbox()
        except Exception:
            pass

    def _detect_jaw_bottom(self, x_center):
        """
        Detects the bottom edge of the lower jaw (Menton).
        Improved Smart Top-Down Scan:
        1. Starts from Zone Line 2 (Jaw Separation) or Middle.
        2. Scans DOWNWARDS to find the transition to background.
        3. Skips small dark gaps (roots/marrow) to find the TRUE bottom edge.
        4. Stops before hitting bottom artifacts (letters/frame) by detecting large gaps.
        """
        try:
            if not self.pixmap_item: return None
                
            img = self.pixmap_item.pixmap().toImage()
            h = img.height()
            w = img.width()
            
            x_center = int(x_center)
            if x_center < 0 or x_center >= w: x_center = w // 2
            
            # Start Y: Use Zone Line 2 (Jaw Split) if available, else Middle
            start_y = h // 2
            zl2 = getattr(self, "zone_line_2", None)
            if self._is_scene_item_alive(zl2):
                start_y = int(zl2.y()) + 50 # Start a bit below the split
            
            if start_y >= h: start_y = h // 2
            
            # Scan window around center
            search_range = range(x_center - 10, x_center + 11)
            valid_ys = []
            
            for x in search_range:
                if x < 0 or x >= w: continue
                
                # Scan DOWNWARDS
                found_edge_y = -1
                
                # We look for a sustained dark region
                # Current logic: If we hit dark, look ahead.
                # If we see bright again soon -> It was a gap/root -> Skip it.
                # If we see dark for a long time -> It is the background -> Stop.
                
                y = start_y
                while y < h - 5: # Stop 5px before edge
                    clr = img.pixelColor(x, y)
                    val = (clr.red() + clr.green() + clr.blue()) / 3.0
                    
                    # If we hit a dark pixel (Background or Gap)
                    # Threshold increased to 55 to catch dark gray backgrounds
                    if val < 55:
                        # Look ahead to see if it's a small gap or the void
                        is_sustained_dark = True
                        gap_size = 0
                        max_gap_to_skip = 15 # Reduced to avoid jumping over chin shadow (was 30)
                        
                        # Peek ahead
                        peek_y = y + 1
                        while peek_y < h:
                             c2 = img.pixelColor(x, peek_y)
                             v2 = (c2.red() + c2.green() + c2.blue()) / 3.0
                             
                             # Requirement to be "Bone" again increased to 80
                             # This prevents jumping over the chin if there is just noise below it
                             if v2 > 80: 
                                 # Found bright pixel again! It was a gap.
                                 is_sustained_dark = False
                                 break
                             
                             gap_size += 1
                             if gap_size > max_gap_to_skip:
                                 # Too big to be a root canal, must be background
                                 break
                             peek_y += 1
                             
                        if is_sustained_dark:
                            # It's the real bottom edge
                            found_edge_y = y - 1
                            break # Stop scanning this column
                        else:
                            # It was a gap, jump over it
                            y = peek_y # Resume from the bright pixel found
                    
                    y += 1
                
                if found_edge_y != -1:
                    valid_ys.append(found_edge_y)
            
            if valid_ys:
                # We want the lowest point (Maximum Y) that is not an outlier
                # Median might be safer than Max to avoid shooting down to artifacts
                # But typically Max is fine if we stopped correctly.
                # Let's use max because the chin is convex downwards.
                return float(max(valid_ys))
            
            # Fallback
            return float(h - (h * 0.15))
            
        except Exception as e:
            print(f"Error detecting jaw bottom: {e}")
            return None

    def _get_vertical_split_x(self) -> float:
        try:
            # Check for newer "midline_item" first (User-Visible Item)
            m = getattr(self, "midline_item", None)
            if self._is_scene_item_alive(m) and m.isVisible():
                try:
                    # VerticalSeparatorLine usually has a line() or x()
                    # If it's a QGraphicsLineItem
                    if hasattr(m, "line"):
                        return float(m.line().x1())
                    # If it's a custom item with x position
                    return float(m.x())
                except Exception:
                    pass

            # Fallback to older "vertical_separator_line"
            v = getattr(self, "vertical_separator_line", None)
            if self._is_scene_item_alive(v):
                try:
                    return float(v.x() + (v.rect().width() / 2.0))
                except Exception:
                    return float(v.x())
        except Exception:
            pass
        try:
            rect = self.pixmap_item.boundingRect() if self.pixmap_item else self.scene.sceneRect()
            return float(rect.width() / 2.0)
        except Exception:
            return 0.0

    def _get_condyle_x_limits(self, tolerance_px: float = 0.0) -> tuple[float, float] | None:
        c_line = getattr(self, "calib_line_x", None)
        if not self._is_scene_item_alive(c_line):
            return None
        try:
            if hasattr(c_line, "isVisible") and (not bool(c_line.isVisible())):
                return None
        except Exception:
            pass
        try:
            base_pos = c_line.pos()
            h1_pos = c_line.h1.pos()
            h2_pos = c_line.h2.pos()
            p1 = base_pos + h1_pos
            p2 = base_pos + h2_pos
            x1 = float(p1.x())
            x2 = float(p2.x())
        except Exception:
            try:
                p1 = c_line.mapToScene(c_line.h1.pos())
                p2 = c_line.mapToScene(c_line.h2.pos())
                x1 = float(p1.x())
                x2 = float(p2.x())
            except Exception:
                return None
        mn = min(float(x1), float(x2))
        mx = max(float(x1), float(x2))
        try:
            tol = float(tolerance_px or 0.0)
        except Exception:
            tol = 0.0
        return (mn - tol, mx + tol)

    # _spee_lower_polygon and related overlay methods removed as per user request


    def _collect_jaw_state(self) -> dict:
        out = {}
        try:
            j = getattr(self, "jaw_separator_line", None)
            if self._is_scene_item_alive(j):
                out["y_split"] = float(j.y())
                out["curve_h"] = float(getattr(j, "curve_h", 0) or 0)
                out["visible"] = bool(j.isVisible())
        except Exception:
            pass
        try:
            v = getattr(self, "vertical_separator_line", None)
            if self._is_scene_item_alive(v):
                out["x_split"] = float(self._get_vertical_split_x())
                if "visible" not in out:
                    out["visible"] = bool(v.isVisible())
        except Exception:
            pass
        try:
            if getattr(self, "pixmap_item", None):
                rect = self.pixmap_item.boundingRect()
                w = float(rect.width() or 1.0)
                h = float(rect.height() or 1.0)
                if "y_split" in out:
                    out["y_split_norm"] = float(out["y_split"]) / h
                if "curve_h" in out:
                    out["curve_h_norm"] = float(out["curve_h"]) / h
                if "x_split" in out:
                    out["x_split_norm"] = float(out["x_split"]) / w
        except Exception:
            pass
        return out

    def _collect_grid_state(self) -> dict:
        out = {}
        try:
            h_ys = []
            if hasattr(self, "grid_lines_h"):
                h_ys = [float(line.y()) for line in (self.grid_lines_h or []) if self._is_scene_item_alive(line)]
            out["h_ys"] = sorted(h_ys)
            
            def _get_xs(lines):
                return [float(line.x()) for line in (lines or []) if self._is_scene_item_alive(line)]

            out["v_xs_upper"] = sorted(_get_xs(getattr(self, "grid_lines_v_upper", [])))
            out["v_xs_lower"] = sorted(_get_xs(getattr(self, "grid_lines_v_lower", [])))
            out["v_outer_xs_upper"] = sorted(_get_xs(getattr(self, "grid_lines_v_outer_upper", [])))
            out["v_outer_xs_lower"] = sorted(_get_xs(getattr(self, "grid_lines_v_outer_lower", [])))
            
            if hasattr(self, "grid_handle") and self._is_scene_item_alive(self.grid_handle):
                 out["handle"] = {
                     "x": float(self.grid_handle.x()),
                     "y": float(self.grid_handle.y()),
                     "drag_speed": float(getattr(self.grid_handle, "drag_speed", 1.0) or 1.0)
                 }
            out["visible"] = bool(getattr(self, "grid_active", False))
        except Exception:
            pass
        return out

    def _collect_calibration_state(self) -> dict:
        out = {}
        try:
            if self.pixel_to_mm_scale_x is not None:
                out["scale_x"] = float(self.pixel_to_mm_scale_x)
            if self.pixel_to_mm_scale_y is not None:
                out["scale_y"] = float(self.pixel_to_mm_scale_y)
            if self.pixel_to_mm_scale is not None:
                out["scale"] = float(self.pixel_to_mm_scale)
        except Exception:
            pass
        try:
            if self.calib_line_x and self.calib_line_x.scene() == self.scene:
                p1 = self.calib_line_x.mapToScene(self.calib_line_x.h1.pos())
                p2 = self.calib_line_x.mapToScene(self.calib_line_x.h2.pos())
                out["line_x"] = {
                    "coords": [float(p1.x()), float(p1.y()), float(p2.x()), float(p2.y())],
                    "mm_length": float(self.calib_line_x.mm_length) if self.calib_line_x.mm_length is not None else None,
                }
        except Exception:
            pass
        try:
            if self.calib_line_y and self.calib_line_y.scene() == self.scene:
                p1 = self.calib_line_y.mapToScene(self.calib_line_y.h1.pos())
                p2 = self.calib_line_y.mapToScene(self.calib_line_y.h2.pos())
                out["line_y"] = {
                    "coords": [float(p1.x()), float(p1.y()), float(p2.x()), float(p2.y())],
                    "mm_length": float(self.calib_line_y.mm_length) if self.calib_line_y.mm_length is not None else None,
                }
        except Exception:
            pass
        try:
            out["visible"] = bool(getattr(self, "is_calibrating", False)) and bool(out.get("line_x") or out.get("line_y"))
        except Exception:
            pass
        return out

    def _save_layout_snapshot_to_prefs(self):
        try:
            key = self._get_patient_key()
            if key == "general":
                return
            snap = {"jaw_lines": self._collect_jaw_state(), "grid": self._collect_grid_state(), "calibration": self._collect_calibration_state()}
            if not isinstance(getattr(self, "layout_snapshot_by_patient", None), dict):
                self.layout_snapshot_by_patient = {}
            self.layout_snapshot_by_patient[str(key)] = snap
        except Exception:
            return

    def _layout_sidecar_path(self) -> str:
        try:
            if not getattr(self, "current_image_path", None):
                return ""
            base = os.path.splitext(str(self.current_image_path))[0]
            return base + "_layout.json"
        except Exception:
            return ""

    def _schedule_layout_save(self, delay_ms: int = 800):
        try:
            if not getattr(self, "current_image_path", None):
                return
            has_any = bool(getattr(self, "grid_active", False))
            try:
                j = getattr(self, "jaw_separator_line", None)
                v = getattr(self, "vertical_separator_line", None)
                cx = getattr(self, "calib_line_x", None)
                cy = getattr(self, "calib_line_y", None)
                has_any = (
                    has_any
                    or self._is_scene_item_alive(j)
                    or self._is_scene_item_alive(v)
                    or self._is_scene_item_alive(cx)
                    or self._is_scene_item_alive(cy)
                )
            except Exception:
                pass
            if not has_any:
                return
            if getattr(self, "_layout_save_timer", None) is None:
                self._layout_save_timer = QTimer(self)
                self._layout_save_timer.setSingleShot(True)
                self._layout_save_timer.timeout.connect(self._save_layout_sidecar)
            self._layout_save_timer.start(max(0, int(delay_ms)))
        except Exception:
            pass

    def _save_layout_sidecar(self):
        try:
            path = self._layout_sidecar_path()
            if not path:
                return
            image_path = str(getattr(self, "current_image_path", "") or "")
            jaw = self._collect_jaw_state()
            grid = self._collect_grid_state()
            calibration = self._collect_calibration_state()
            tooth_spacing = None
            try:
                ts = getattr(self, "_tooth_spacing", None)
                if not isinstance(ts, dict):
                    ts = {}
                q1 = getattr(self, "_q1_spacing_template", None)
                if isinstance(q1, dict) and isinstance(q1.get("deltas_px"), list):
                    ts = dict(ts)
                    ts["q1"] = q1
                tooth_spacing = ts if ts else None
            except Exception:
                tooth_spacing = None
            sig_payload = {"jaw_lines": jaw, "grid": grid, "calibration": calibration, "tooth_spacing": tooth_spacing}
            sig = ""
            try:
                sig = hashlib.md5(json.dumps(sig_payload, ensure_ascii=False, sort_keys=True, separators=(",", ":")).encode("utf-8")).hexdigest()
            except Exception:
                sig = ""
            try:
                prev = getattr(self, "_layout_last_sig_by_image", None)
                if not isinstance(prev, dict):
                    prev = {}
                    self._layout_last_sig_by_image = prev
                if sig and prev.get(image_path) == sig and os.path.exists(path):
                    return
            except Exception:
                pass

            data = {
                "image_path": image_path,
                "saved_at": datetime.now().isoformat(timespec="seconds"),
                "jaw_lines": jaw,
                "grid": grid,
                "calibration": calibration,
            }
            try:
                if isinstance(tooth_spacing, dict) and tooth_spacing:
                    data["tooth_spacing"] = tooth_spacing
            except Exception:
                pass
            try:
                if getattr(self, "pixmap_item", None):
                    rect = self.pixmap_item.boundingRect()
                    data["image_w"] = float(rect.width() or 0.0)
                    data["image_h"] = float(rect.height() or 0.0)
            except Exception:
                pass
            tmp_path = path + ".tmp"
            with open(tmp_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                f.flush()
                os.fsync(f.fileno())
            os.replace(tmp_path, path)
            try:
                if sig:
                    self._layout_last_sig_by_image[image_path] = sig
            except Exception:
                pass
            try:
                self._save_layout_snapshot_to_prefs()
                self._schedule_prefs_save(0)
            except Exception:
                pass
            try:
                now = time.monotonic()
                if (now - float(getattr(self, "_layout_last_notify_at", 0.0) or 0.0)) >= 1.5:
                    self._layout_last_notify_at = now
                    self._show_layout_saved_indicator()
            except Exception:
                pass
        except Exception:
            pass

    def _show_layout_saved_indicator(self):
        try:
            if not hasattr(self, "layout_save_label") or self.layout_save_label is None:
                return
            ts = datetime.now().strftime("%H:%M:%S")
            self.layout_save_label.setText(f"Αποθηκεύτηκε layout {ts}")
            QTimer.singleShot(1600, self._clear_layout_save_label)
        except Exception:
            pass

    def _clear_layout_save_label(self):
        try:
            lbl = getattr(self, "layout_save_label", None)
            if lbl is None:
                return
            lbl.setText("")
        except Exception:
            pass

    def _is_scene_item_alive(self, item) -> bool:
        try:
            if item is None or not getattr(self, "scene", None):
                return False
            if not hasattr(item, "scene"):
                return False
            return item.scene() == self.scene
        except Exception:
            return False

    def _safe_remove_scene_item(self, item):
        try:
            if item is None or not getattr(self, "scene", None):
                return
            try:
                if hasattr(item, "scene") and item.scene() != self.scene:
                    return
            except Exception:
                pass
            try:
                self.scene.removeItem(item)
            except Exception:
                pass
        except Exception:
            pass

    def _pixmap_scene_bounds(self):
        try:
            pi = getattr(self, "pixmap_item", None)
            if pi is None or pi.scene() is None:
                return None
            return pi.mapToScene(pi.boundingRect()).boundingRect()
        except Exception:
            return None

    def _clamp_calibration_coords(self, coords, axis_type):
        if not isinstance(coords, (list, tuple)) or len(coords) < 4:
            return coords
        bounds = self._pixmap_scene_bounds()
        if bounds is None:
            return coords
        try:
            x1 = float(coords[0])
            y1 = float(coords[1])
            x2 = float(coords[2])
            y2 = float(coords[3])
        except Exception:
            return coords

        try:
            axis = str(axis_type or "any").lower().strip()
        except Exception:
            axis = "any"
        if axis == "x":
            y2 = y1
        elif axis == "y":
            x2 = x1

        try:
            x1 = min(max(x1, float(bounds.left())), float(bounds.right()))
            x2 = min(max(x2, float(bounds.left())), float(bounds.right()))
            y1 = min(max(y1, float(bounds.top())), float(bounds.bottom()))
            y2 = min(max(y2, float(bounds.top())), float(bounds.bottom()))
        except Exception:
            return coords

        return [x1, y1, x2, y2]

    def _load_layout_sidecar(self):
        path = self._layout_sidecar_path()
        if not path or not os.path.exists(path):
            self._loaded_layout_from_sidecar = False
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            self._loaded_layout_from_sidecar = False
            return
        if not isinstance(data, dict):
            self._loaded_layout_from_sidecar = False
            return

        applied = False
        try:
            rect = self.pixmap_item.boundingRect() if self.pixmap_item else None
            if rect is None:
                self._loaded_layout_from_sidecar = False
                return
            width = rect.width()
            height = rect.height()

            # Restore calibration (scales and optional lines)
            try:
                calib = data.get("calibration") or {}
                sx = calib.get("scale_x")
                sy = calib.get("scale_y")
                sc = calib.get("scale")
                vis = True
                try:
                    if "visible" in calib:
                        vis = bool(calib.get("visible"))
                except Exception:
                    vis = True
                if sx is not None or sy is not None or sc is not None:
                    self.pixel_to_mm_scale_x = sx
                    self.pixel_to_mm_scale_y = sy
                    self.pixel_to_mm_scale = sc if sc is not None else (sx if sx is not None else sy)
                lx = calib.get("line_x")
                ly = calib.get("line_y")
                if isinstance(lx, dict) and isinstance(lx.get("coords"), list):
                    try:
                        self._safe_remove_scene_item(getattr(self, "calib_line_x", None))
                    except Exception:
                        pass
                    c = lx.get("coords")
                    try:
                        c = self._clamp_calibration_coords(c, "x")
                    except Exception:
                        pass
                    self.calib_line_x = CalibrationLine(*c, on_calibrated=self.apply_calibration, axis_type='x', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                    self.calib_line_x.mm_length = lx.get("mm_length")
                    self.scene.addItem(self.calib_line_x)
                    applied = True
                if isinstance(ly, dict) and isinstance(ly.get("coords"), list):
                    try:
                        self._safe_remove_scene_item(getattr(self, "calib_line_y", None))
                    except Exception:
                        pass
                    c = ly.get("coords")
                    try:
                        c = self._clamp_calibration_coords(c, "y")
                    except Exception:
                        pass
                    self.calib_line_y = CalibrationLine(*c, on_calibrated=self.apply_calibration, axis_type='y', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                    self.calib_line_y.mm_length = ly.get("mm_length")
                    self.scene.addItem(self.calib_line_y)
                    applied = True
                try:
                    if self.calib_line_x:
                        self.calib_line_x.setVisible(bool(vis))
                    if self.calib_line_y:
                        self.calib_line_y.setVisible(bool(vis))
                except Exception:
                    pass
                try:
                    self.calibration_button.blockSignals(True)
                    self.calibration_button.setChecked(bool(vis))
                    self.calibration_button.blockSignals(False)
                except Exception:
                    pass
                self.is_calibrating = bool(vis)
            except Exception:
                pass

            jaw = data.get("jaw_lines")
            jaw_visible = True
            try:
                if isinstance(jaw, dict) and "visible" in jaw:
                    jaw_visible = bool(jaw.get("visible"))
            except Exception:
                jaw_visible = True
            if isinstance(jaw, dict) and (not self._is_scene_item_alive(getattr(self, "jaw_separator_line", None))):
                yv = jaw.get("y_split", None)
                xv = jaw.get("x_split", None)
                curve_h = float(jaw.get("curve_h") or 0)
                if yv is not None:
                    self.jaw_separator_line = ZoneSeparatorLine(width, float(yv), label="Jaw Separator", color=Qt.GlobalColor.cyan, on_change_callback=self._on_jaw_lines_changed)

                    self.scene.addItem(self.jaw_separator_line)
                    try:
                        self.jaw_separator_line.setVisible(bool(jaw_visible))
                    except Exception:
                        pass
                if xv is not None:
                    self.vertical_separator_line = VerticalSeparatorLine(height, float(xv), on_change_callback=self._on_jaw_lines_changed)
                    self.scene.addItem(self.vertical_separator_line)
                    try:
                        self.vertical_separator_line.setVisible(bool(jaw_visible))
                    except Exception:
                        pass
                self.apply_layout_lock()
                applied = True
            elif isinstance(jaw, dict):
                try:
                    jaw_line = getattr(self, "jaw_separator_line", None)
                    if self._is_scene_item_alive(jaw_line):
                        jaw_line.setVisible(bool(jaw_visible))
                    vline = getattr(self, "vertical_separator_line", None)
                    if self._is_scene_item_alive(vline):
                        vline.setVisible(bool(jaw_visible))
                except Exception:
                    pass

            grid = data.get("grid")
            if isinstance(grid, dict) and bool(grid.get("active")):
                has_grid = bool(getattr(self, "grid_lines_h", None)) and (
                    bool(getattr(self, "grid_lines_v_upper", None)) or bool(getattr(self, "grid_lines_v_lower", None)) or bool(getattr(self, "grid_lines_v", None))
                )
                if (not bool(getattr(self, "grid_active", False))) or (not has_grid):
                    self._restore_grid_from_data(grid)
                    applied = True
            try:
                ts = data.get("tooth_spacing") or {}
                if isinstance(ts, dict):
                    q1 = ts.get("q1")
                    if isinstance(q1, dict) and isinstance(q1.get("deltas_px"), list):
                        self._q1_spacing_template = q1
                    try:
                        self._tooth_spacing = dict(ts)
                        applied = True
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            applied = False

        self._loaded_layout_from_sidecar = bool(applied)

    def _restore_grid_from_data(self, grid_data: dict):
        if not isinstance(grid_data, dict):
            return
        if not self.pixmap_item or not self.scene:
            return
        rect = self.pixmap_item.boundingRect()
        w = rect.width()
        h = rect.height()

        visible = True
        try:
            if "visible" in grid_data:
                visible = bool(grid_data.get("visible"))
        except Exception:
            visible = True

        try:
            self.grid_button.blockSignals(True)
            self.grid_button.setChecked(bool(visible))
            self.grid_button.blockSignals(False)
        except Exception:
            pass
        self.grid_active = True
        self.grid_visible = bool(visible)
        try:
            cm = grid_data.get("cell_map")
            if isinstance(cm, dict):
                self.grid_cell_label_map = {str(k): str(v) for k, v in cm.items() if str(k).strip()}
            else:
                self.grid_cell_label_map = {}
        except Exception:
            self.grid_cell_label_map = {}

        for attr in ("grid_lines_h", "grid_lines_v", "grid_lines_v_upper", "grid_lines_v_lower", "grid_lines_v_outer_upper", "grid_lines_v_outer_lower"):
            lines = getattr(self, attr, None)
            if not lines:
                continue
            for l in list(lines):
                try:
                    if self._is_scene_item_alive(l):
                        self.scene.removeItem(l)
                except Exception:
                    pass
        try:
            gh = getattr(self, "grid_handle", None)
            if self._is_scene_item_alive(gh):
                self.scene.removeItem(gh)
        except Exception:
            pass

        self.grid_lines_h = []
        self.grid_lines_v = []
        self.grid_lines_v_upper = []
        self.grid_lines_v_lower = []
        self.grid_lines_v_outer_upper = []
        self.grid_lines_v_outer_lower = []
        self.grid_handle = None

        sx = getattr(self, "pixel_to_mm_scale_x", None) or getattr(self, "pixel_to_mm_scale", None)
        sy = getattr(self, "pixel_to_mm_scale_y", None) or getattr(self, "pixel_to_mm_scale", None)

        def _restore_y_list(obj):
            ys_mm = obj.get("h_ys_mm") if isinstance(obj, dict) else None
            if sy and isinstance(ys_mm, list) and ys_mm:
                try:
                    ys = [float(v) * float(sy) for v in ys_mm if isinstance(v, (int, float))]
                    if ys:
                        return ys
                except Exception:
                    pass
            ys_norm = obj.get("h_ys_norm") if isinstance(obj, dict) else None
            if isinstance(ys_norm, list) and ys_norm:
                try:
                    ys = [float(v) * float(h) for v in ys_norm if isinstance(v, (int, float))]
                    if ys:
                        return ys
                except Exception:
                    pass
            return [float(y) for y in ((obj or {}).get("h_ys") or []) if isinstance(y, (int, float))]

        def _restore_x_list(obj, key_px, key_norm, key_mm):
            xs_mm = obj.get(key_mm) if isinstance(obj, dict) else None
            if sx and isinstance(xs_mm, list) and xs_mm:
                try:
                    xs = [float(v) * float(sx) for v in xs_mm if isinstance(v, (int, float))]
                    if xs:
                        return xs
                except Exception:
                    pass
            xs_norm = obj.get(key_norm) if isinstance(obj, dict) else None
            if isinstance(xs_norm, list) and xs_norm:
                try:
                    xs = [float(v) * float(w) for v in xs_norm if isinstance(v, (int, float))]
                    if xs:
                        return xs
                except Exception:
                    pass
            return [float(x) for x in ((obj or {}).get(key_px) or []) if isinstance(x, (int, float))]

        h_ys = _restore_y_list(grid_data)
        if len(h_ys) < 3:
            h_ys = [h * 0.1, h * 0.5, h * 0.9]
        h_ys = sorted(h_ys)[:3]

        h_top = DraggableLineItem(0, 0, w, 0, 'horizontal', on_change_callback=self._on_grid_changed)
        h_top.setPos(0, h_ys[0])
        self.scene.addItem(h_top)
        h_mid = DraggableLineItem(0, 0, w, 0, 'horizontal', on_change_callback=self._on_grid_changed)
        h_mid.setPos(0, h_ys[1])
        self.scene.addItem(h_mid)
        h_bot = DraggableLineItem(0, 0, w, 0, 'horizontal', on_change_callback=self._on_grid_changed)
        h_bot.setPos(0, h_ys[2])
        self.scene.addItem(h_bot)
        self.grid_lines_h = [h_top, h_mid, h_bot]

        y_top = float(h_top.y())
        y_mid = float(h_mid.y())
        y_bot = float(h_bot.y())

        def _create_verticals(y_start: float, y_end: float, xs: list, out_list: list):
            xs = [float(x) for x in (xs or []) if isinstance(x, (int, float))]
            if not xs:
                cx = (grid_data.get("handle") or {}).get("x")
                try:
                    cx = float(cx)
                except Exception:
                    cx = None
                
                # Sync with VerticalSeparatorLine (Midline) if available and no explicit grid handle
                if cx is None and hasattr(self, "vertical_separator_line") and self._is_scene_item_alive(self.vertical_separator_line):
                    try:
                        cx = float(self.vertical_separator_line.x())
                    except Exception:
                        pass

                if cx is None:
                    cx = w / 2.0

                n_per_side = int((grid_data.get("n_per_side") or 7) or 7)
                step_left = cx / max(1, (n_per_side + 1))
                step_right = (w - cx) / max(1, (n_per_side + 1))
                xs = [cx] + [cx - i * step_left for i in range(1, n_per_side + 1)] + [cx + i * step_right for i in range(1, n_per_side + 1)]
                xs = sorted(xs)
            for x in xs:
                # Visual Check: Don't draw center line if it overlaps exactly with Midline
                is_center = False
                if hasattr(self, "vertical_separator_line") and self._is_scene_item_alive(self.vertical_separator_line):
                    if abs(x - self.vertical_separator_line.x()) < 2.0:
                        is_center = True
                
                v = DraggableLineItem(0, y_start, 0, y_end, 'vertical', on_change_callback=self._on_grid_changed)
                v.setPos(float(x), 0)
                if not is_center:
                    self.scene.addItem(v)
                else:
                    # We still add it to the list for calculation, but don't add to scene (invisible)
                    # Actually, if we don't add to scene, scene() will be None.
                    # We should add it but make it invisible?
                    # Or just rely on the user seeing the Magenta line.
                    # But logic often checks `if l.scene() == self.scene`.
                    # Let's add it but setVisible(False) if we want to hide it.
                    # But the user complains about "2 lines".
                    # If I set visible False, the logic works?
                    # Let's try adding it but hiding it.
                    self.scene.addItem(v)
                    v.setVisible(False)
                    
                out_list.append(v)
            out_list.sort(key=lambda o: o.x())

        _create_verticals(y_top, y_mid, _restore_x_list(grid_data, "v_xs_upper", "v_xs_upper_norm", "v_xs_upper_mm"), self.grid_lines_v_upper)
        _create_verticals(y_mid, y_bot, _restore_x_list(grid_data, "v_xs_lower", "v_xs_lower_norm", "v_xs_lower_mm"), self.grid_lines_v_lower)
        try:
            self.grid_lines_v = list(self.grid_lines_v_upper or [])
        except Exception:
            self.grid_lines_v = []

        def _create_outer(y_start: float, y_end: float, xs: list, out_list: list):
            xs = [float(x) for x in (xs or []) if isinstance(x, (int, float))]
            if len(xs) < 2:
                try:
                    margin = float(getattr(self, "grid_outer_molar_margin_px", 0.0) or 0.0)
                except Exception:
                    margin = 0.0
                if margin <= 0.0:
                    margin = float(max(8.0, min(60.0, w * 0.03)))
                xs = [margin, float(w - margin)]
            xs = sorted(xs)[:2]
            for x in xs:
                v = DraggableLineItem(0, y_start, 0, y_end, 'vertical', on_change_callback=self._on_grid_changed)
                v.setPos(float(x), 0)
                self.scene.addItem(v)
                out_list.append(v)
            out_list.sort(key=lambda o: o.x())

        _create_outer(y_top, y_mid, _restore_x_list(grid_data, "v_outer_xs_upper", "v_outer_xs_upper_norm", "v_outer_xs_upper_mm"), self.grid_lines_v_outer_upper)
        _create_outer(y_mid, y_bot, _restore_x_list(grid_data, "v_outer_xs_lower", "v_outer_xs_lower_norm", "v_outer_xs_lower_mm"), self.grid_lines_v_outer_lower)

        handle = grid_data.get("handle") or {}
        hx = handle.get("x", None)
        hy = handle.get("y", None)
        if sx and hx is None and isinstance(handle.get("x_mm"), (int, float)):
            try:
                hx = float(handle.get("x_mm")) * float(sx)
            except Exception:
                hx = None
        if hy is None and sy and isinstance(handle.get("y_mm"), (int, float)):
            try:
                hy = float(handle.get("y_mm")) * float(sy)
            except Exception:
                hy = None
        if hx is None and isinstance(handle.get("x_norm"), (int, float)):
            try:
                hx = float(handle.get("x_norm")) * float(w)
            except Exception:
                hx = None
        if hy is None and isinstance(handle.get("y_norm"), (int, float)):
            try:
                hy = float(handle.get("y_norm")) * float(h)
            except Exception:
                hy = None
        if hx is None:
            hx = w / 2.0
        if hy is None:
            hy = h / 2.0
        self.grid_handle = GridHandleItem(self, float(hx), float(hy))
        try:
            self.grid_handle.drag_speed = float(handle.get("drag_speed", 1.0))
        except Exception:
            pass
        self.scene.addItem(self.grid_handle)
        try:
            self._set_grid_visible(bool(visible))
        except Exception:
            pass
        self.apply_layout_lock()

    def _apply_layout_snapshot_from_prefs(self):
        try:
            key = self._get_patient_key()
            snap_by = getattr(self, "layout_snapshot_by_patient", None)
            if key == "general" or not isinstance(snap_by, dict):
                return
            snap = snap_by.get(str(key))
            if not isinstance(snap, dict):
                return
            rect = self.pixmap_item.boundingRect() if self.pixmap_item else None
            if rect is None:
                return
            width = rect.width()
            height = rect.height()

            jaw = snap.get("jaw_lines")
            if isinstance(jaw, dict) and (not self._is_scene_item_alive(getattr(self, "jaw_separator_line", None))):
                yv = jaw.get("y_split", None)
                xv = jaw.get("x_split", None)
                curve_h = float(jaw.get("curve_h") or 0)
                if yv is not None:
                    y_split = float(yv or 0)
                    self.jaw_separator_line = ZoneSeparatorLine(width, y_split, label="Jaw Separator", color=Qt.GlobalColor.cyan, on_change_callback=self._on_jaw_lines_changed)

                    self.scene.addItem(self.jaw_separator_line)
                if xv is not None:
                    x_split = float(xv or 0)
                    self.vertical_separator_line = VerticalSeparatorLine(height, x_split, on_change_callback=self._on_jaw_lines_changed)
                    self.scene.addItem(self.vertical_separator_line)
                self.apply_layout_lock()
            if isinstance(jaw, dict):
                try:
                    vis = bool(jaw.get("visible", True))
                    jaw_line = getattr(self, "jaw_separator_line", None)
                    if self._is_scene_item_alive(jaw_line):
                        jaw_line.setVisible(vis)
                    vline = getattr(self, "vertical_separator_line", None)
                    if self._is_scene_item_alive(vline):
                        vline.setVisible(vis)
                except Exception:
                    pass

            calib = snap.get("calibration") or {}
            try:
                sx = calib.get("scale_x")
                sy = calib.get("scale_y")
                sc = calib.get("scale")
                if sx is not None or sy is not None or sc is not None:
                    self.pixel_to_mm_scale_x = sx
                    self.pixel_to_mm_scale_y = sy
                    self.pixel_to_mm_scale = sc if sc is not None else (sx if sx is not None else sy)
                vis = bool(calib.get("visible", False))
                lx = calib.get("line_x")
                ly = calib.get("line_y")
                if isinstance(lx, dict) and isinstance(lx.get("coords"), list):
                    try:
                        self._safe_remove_scene_item(getattr(self, "calib_line_x", None))
                    except Exception:
                        pass
                    c = lx.get("coords")
                    try:
                        c = self._clamp_calibration_coords(c, "x")
                    except Exception:
                        pass
                    self.calib_line_x = CalibrationLine(*c, on_calibrated=self.apply_calibration, axis_type='x', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                    self.calib_line_x.mm_length = lx.get("mm_length")
                    self.scene.addItem(self.calib_line_x)
                if isinstance(ly, dict) and isinstance(ly.get("coords"), list):
                    try:
                        self._safe_remove_scene_item(getattr(self, "calib_line_y", None))
                    except Exception:
                        pass
                    c = ly.get("coords")
                    try:
                        c = self._clamp_calibration_coords(c, "y")
                    except Exception:
                        pass
                    self.calib_line_y = CalibrationLine(*c, on_calibrated=self.apply_calibration, axis_type='y', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                    self.calib_line_y.mm_length = ly.get("mm_length")
                    self.scene.addItem(self.calib_line_y)
                if self.calib_line_x:
                    self.calib_line_x.setVisible(vis)
                if self.calib_line_y:
                    self.calib_line_y.setVisible(vis)
                try:
                    self.calibration_button.blockSignals(True)
                    self.calibration_button.setChecked(bool(vis))
                    self.calibration_button.blockSignals(False)
                except Exception:
                    pass
                self.is_calibrating = bool(vis)
            except Exception:
                pass

            grid = snap.get("grid")
            if isinstance(grid, dict) and bool(grid.get("active")):
                has_grid = bool(getattr(self, "grid_lines_h", None)) and (
                    bool(getattr(self, "grid_lines_v_upper", None)) or bool(getattr(self, "grid_lines_v_lower", None)) or bool(getattr(self, "grid_lines_v", None))
                )
                if (not bool(getattr(self, "grid_active", False))) or (not has_grid):
                    self._restore_grid_from_data(grid)
                    self.recalculate_fdi()
        except Exception:
            pass

    def start_crop_selection(self, pos):
        try:
            self._safe_remove_scene_item(getattr(self, "crop_selection_item", None))
        except Exception:
            pass
        self.crop_selection_item = None
        self.crop_start_pos = pos
        self.crop_selection_item = CropRectItem(QRectF(pos, pos))
        self.scene.addItem(self.crop_selection_item)

    def update_crop_selection(self, pos):
        if self.crop_selection_item and self.crop_start_pos:
            rect = QRectF(self.crop_start_pos, pos).normalized()
            try:
                self.crop_selection_item.setRect(rect)
            except RuntimeError:
                self.crop_selection_item = None
                self.crop_start_pos = None

    def finish_crop_selection(self):
        if not self.crop_selection_item: return
        try:
            rect = self.crop_selection_item.rect()
        except RuntimeError:
            self.crop_selection_item = None
            self.crop_button.setChecked(False)
            self.toggle_crop_mode()
            return
        if rect.width() < 10 or rect.height() < 10:
            try:
                self._safe_remove_scene_item(self.crop_selection_item)
            except Exception:
                pass
            self.crop_selection_item = None
            return

        # Ask user to confirm
        reply = QMessageBox.question(self, "Επιβεβαίωση Αποκοπής", 
                                     "Θέλετε να γίνει αποκοπή της εικόνας στο επιλεγμένο πλαίσιο;\n\nΠΡΟΣΟΧΗ: Η ανάλυση θα διαγραφεί.",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        
        if reply == QMessageBox.StandardButton.Yes:
            self.apply_crop(rect)
        else:
            try:
                self._announce_action_done("Αποκοπή: ακυρώθηκε")
            except Exception:
                pass
        
        # Cleanup
        try:
            self._safe_remove_scene_item(getattr(self, "crop_selection_item", None))
        except Exception:
            pass
        self.crop_selection_item = None
        
        self.crop_button.setChecked(False)
        self.toggle_crop_mode()
        try:
            if bool(getattr(self, "auto_pipeline_enabled", True)) and bool(getattr(self, "current_image_path", None)):
                QTimer.singleShot(200, self.run_pipeline_next_step)
        except Exception:
            pass

    def apply_crop(self, rect):
        if self.original_image_np is None: return
        
        x = int(rect.x())
        y = int(rect.y())
        w = int(rect.width())
        h = int(rect.height())
        
        # Clip to image bounds
        img_h, img_w = self.original_image_np.shape[:2]
        x = max(0, x)
        y = max(0, y)
        w = min(w, img_w - x)
        h = min(h, img_h - y)
        
        if w <= 0 or h <= 0: return

        # Crop numpy array
        cropped_img = self.original_image_np[y:y+h, x:x+w]
        
        # Save to file
        if self.current_image_path:
            dir_name = os.path.dirname(self.current_image_path)
            base_name = os.path.basename(self.current_image_path)
            name, ext = os.path.splitext(base_name)
            ext_lower = str(ext or "").lower()
            already_crop = ("_crop_" in str(name or "").lower()) or str(name or "").lower().endswith("_crop")
            if ext_lower == ".dcm":
                new_path = os.path.join(dir_name, f"{name}_crop.png")
            else:
                if already_crop:
                    new_path = self.current_image_path
                else:
                    new_path = os.path.join(dir_name, f"{name}_crop{ext}")
            
            try:
                img_to_save = Image.fromarray(cropped_img)
                final_ext = os.path.splitext(str(new_path))[1]
                tmp_path = str(new_path) + ".tmp" + str(final_ext or "")
                img_to_save.save(tmp_path)
                os.replace(tmp_path, new_path)
                
                # Update list
                self.load_images_from_directory()
                
                # Select the new image
                for i in range(self.image_list_widget.count()):
                    item = self.image_list_widget.item(i)
                    if item.data(Qt.ItemDataRole.UserRole) == new_path:
                        self.image_list_widget.setCurrentItem(item)
                        self.display_selected_image(item)
                        break
                        
                try:
                    self._announce_action_done(f"Αποκοπή: αποθηκεύτηκε {os.path.basename(new_path)}")
                except Exception:
                    pass
                try:
                    if bool(getattr(self, "auto_pipeline_enabled", True)):
                        QTimer.singleShot(250, self.run_pipeline_next_step)
                except Exception:
                    pass
            except Exception as e:
                try:
                    self._announce_action_failed(f"Αποκοπή: {e}")
                except Exception:
                    pass
                QMessageBox.critical(self, "Σφάλμα", f"Αποτυχία αποθήκευσης αποκοπής: {e}")

    def toggle_magic_wand_mode(self):
        try:
            if bool(getattr(self, "missing_cell_mode", False)):
                self._set_missing_cell_mode(False)
        except Exception:
            pass
        self.magic_wand_active = self.magic_wand_button.isChecked()
        try:
            self._announce_action_done("Μαγικό ραβδί: ενεργό" if bool(self.magic_wand_active) else "Μαγικό ραβδί: ανενεργό")
        except Exception:
            pass

    def _set_missing_cell_mode(self, active: bool):
        self.missing_cell_mode = bool(active)
        try:
            if hasattr(self, "missing_tooth_button") and self.missing_tooth_button:
                self.missing_tooth_button.blockSignals(True)
                self.missing_tooth_button.setChecked(bool(active))
                self.missing_tooth_button.blockSignals(False)
        except Exception:
            pass
        try:
            if self.missing_cell_mode:
                if hasattr(self, "view") and self.view:
                    self.view.setCursor(Qt.CursorShape.CrossCursor)
            else:
                if hasattr(self, "view") and self.view:
                    self.view.setCursor(Qt.CursorShape.ArrowCursor)
        except Exception:
            pass

    def toggle_missing_tooth_mode(self):
        active = False
        try:
            active = bool(self.missing_tooth_button.isChecked())
        except Exception:
            active = False
        if active:
            try:
                if hasattr(self, "crop_button") and self.crop_button and self.crop_button.isChecked():
                    self.crop_button.setChecked(False)
                    self.toggle_crop_mode()
            except Exception:
                pass
            try:
                if hasattr(self, "magic_wand_button") and self.magic_wand_button and self.magic_wand_button.isChecked():
                    self.magic_wand_button.setChecked(False)
                    self.toggle_magic_wand_mode()
            except Exception:
                pass
            try:
                if hasattr(self, "calibration_button") and self.calibration_button and self.calibration_button.isChecked():
                    self.calibration_button.setChecked(False)
                    self.toggle_calibration_mode()
            except Exception:
                pass
        self._set_missing_cell_mode(active)
        try:
            self._announce_action_done("Ελλείπον (κελί): ενεργό" if bool(active) else "Ελλείπον (κελί): ανενεργό")
        except Exception:
            pass

    def _magic_wand_segment(self, pos):
        # Placeholder
        pass

    def run_yolov8_segmentation(self):
        # Placeholder
        pass

    def toggle_jaw_lines(self):
        if not self.scene: return
        
        # Check if lines exist
        jaw = getattr(self, "jaw_separator_line", None)
        if self._is_scene_item_alive(jaw):
            try:
                new_vis = not bool(jaw.isVisible())
            except Exception:
                new_vis = True
            try:
                jaw.setVisible(bool(new_vis))
            except Exception:
                pass
            try:
                if bool(new_vis):
                    self._update_spee_lower_overlay()
                else:
                    it = getattr(self, "_spee_lower_overlay_item", None)
                    if it is not None:
                        it.setVisible(False)
            except Exception:
                pass
            try:
                vline = getattr(self, "vertical_separator_line", None)
                if self._is_scene_item_alive(vline):
                    vline.setVisible(bool(new_vis))
            except Exception:
                pass
            try:
                self._schedule_layout_save(0)
            except Exception:
                pass
            try:
                self._announce_action_done("Γραμμές: εμφανείς" if bool(new_vis) else "Γραμμές: κρυφές")
            except Exception:
                pass
        else:
            # Create and add lines
            rect = self.scene.sceneRect()
            if rect.isEmpty() and self.pixmap_item:
                rect = self.pixmap_item.boundingRect()
                
            width = rect.width()
            height = rect.height()
            
            # Horizontal Curve (defaults to center-ish)
            self.jaw_separator_line = ZoneSeparatorLine(width, height * 0.5, label="Jaw Separator", color=Qt.GlobalColor.cyan, on_change_callback=self._on_jaw_lines_changed)

            try:
                self.scene.addItem(self.jaw_separator_line)
            except Exception:
                self.jaw_separator_line = None
            
            # Vertical Line (center)
            self.vertical_separator_line = VerticalSeparatorLine(height, width * 0.5, on_change_callback=self._on_jaw_lines_changed)
            try:
                self.scene.addItem(self.vertical_separator_line)
            except Exception:
                self.vertical_separator_line = None
            # _update_spee_lower_overlay call removed

            try:
                self.apply_layout_lock()
            except Exception:
                pass
            try:
                if bool(getattr(self, "layout_locked", False)):
                    self._append_comm("Σύστημα", "Οι γραμμές είναι κλειδωμένες. Απενεργοποίησε το «Κλείδωμα» για να μετακινηθούν.")
            except Exception:
                pass
            try:
                self._schedule_layout_save(0)
            except Exception:
                pass
            try:
                self.recalculate_fdi()
            except Exception:
                pass
            try:
                vis = True
                try:
                    vis = bool(self.jaw_separator_line.isVisible()) if self.jaw_separator_line else True
                except Exception:
                    vis = True
                self._announce_action_done("Γραμμές: εμφανείς" if bool(vis) else "Γραμμές: κρυφές")
            except Exception:
                pass
    def _estimate_scale_from_items(self):
        """
        Estimates the pixel-to-mm scale based on the median width of existing detected teeth.
        Assumes average tooth width is ~8.0mm.
        Returns scale (px/mm) or None if not enough items.
        """
        try:
            widths = []
            for item in self.analysis_items:
                # We only care about RectItems that represent Teeth (usually have 2-digit text)
                if isinstance(item, EditableRectItem):
                     # Filter out huge boxes (zones) or tiny specks
                     w = item.rect().width()
                     if 10 < w < 200: # Reasonable range for a tooth in any resolution
                         widths.append(w)
            
            if len(widths) >= 3:
                median_w = np.median(widths)
                # Average tooth width ~8.0mm
                return median_w / 8.0
        except Exception:
            pass
        return None

    def _predict_manual_fdi(self, pos):
        """
        Predicts the FDI number for a manually added tooth at 'pos'.
        Uses ANATOMICAL WALKING from Midline to infer the number.
        """
        try:
            # 1. Get Reference Lines & Scene Info
            midline_x = 0
            scene_w = 1000
            scene_h = 500
            
            if self.pixmap_item:
                rect = self.pixmap_item.boundingRect()
                scene_w = rect.width()
                scene_h = rect.height()
                midline_x = scene_w / 2
            else:
                rect = self.scene.sceneRect()
                scene_w = rect.width()
                scene_h = rect.height()
                midline_x = scene_w / 2

            # A. Check Calibration Line (Magenta) - Absolute Center Axis
            calib_y_line = getattr(self, "calib_line_y", None)
            has_calib = False
            if self._is_scene_item_alive(calib_y_line) and calib_y_line.isVisible():
                try:
                    base_pos = calib_y_line.pos()
                    h1_pos = calib_y_line.h1.pos()
                    midline_x = (base_pos + h1_pos).x()
                    has_calib = True
                except:
                    try:
                        p1 = calib_y_line.mapToScene(calib_y_line.h1.pos())
                        midline_x = p1.x()
                        has_calib = True
                    except: pass
            
            # B. Check Manual Vertical Line (Blue) - if no Calib Line
            if not has_calib:
                manual_vert = getattr(self, "midline_item", None)
                if self._is_scene_item_alive(manual_vert) and manual_vert.isVisible():
                     midline_x = manual_vert.x()
                elif hasattr(self, "vertical_separator_line") and self._is_scene_item_alive(self.vertical_separator_line):
                    midline_x = self.vertical_separator_line.x()
                elif hasattr(self, "midline_line") and self._is_scene_item_alive(self.midline_line):
                     midline_x = self.midline_line.line().x1()

            x = pos.x()
            y = pos.y()

            # Helper to determine if a Y coordinate is in the upper jaw
            def get_is_upper(y_pos):
                # 1. Check Grid Lines (h_lines)
                h_lines = sorted([l.y() for l in (getattr(self, "grid_lines_h", None) or []) if l and l.scene() == self.scene])
                if len(h_lines) >= 3:
                    if y_pos < h_lines[1]: return True
                    else: return False
                elif len(h_lines) >= 1:
                    mid_y = h_lines[len(h_lines)//2]
                    return y_pos < mid_y

                # 2. Check zone_line_2 (Green Occlusal Separator)
                zl2 = getattr(self, "zone_line_2", None)
                if self._is_scene_item_alive(zl2) and zl2.isVisible():
                    return y_pos < zl2.y()

                # 3. Check Jaw Separator Line
                jaw_y_default = scene_h / 2
                if hasattr(self, "jaw_separator_line") and self._is_scene_item_alive(self.jaw_separator_line):
                    jaw_y_default = self.jaw_separator_line.y()
                return y_pos < jaw_y_default

            # Determine Upper/Lower & Left/Right
            is_upper = get_is_upper(y)
            is_left_side = x < midline_x # Image Left (Patient Right)
            
            # Determine Quadrant
            if is_upper:
                q = 1 if is_left_side else 2
            else:
                q = 4 if is_left_side else 3

            # --- SCALE ESTIMATION ---
            # Priority 1: Auto-Scale from existing items (Most robust to zoom/resolution quirks)
            scale = self._estimate_scale_from_items()
            
            # Priority 2: Explicit Calibration
            if not scale:
                scale = getattr(self, 'pixel_to_mm_scale_x', None)
            
            if not scale or scale <= 0:
                scale = getattr(self, 'pixel_to_mm_scale', None)
            
            if not scale or scale <= 0:
                 # Fallback: Estimate scale based on aspect ratio
                 ratio = scene_w / scene_h if scene_h > 0 else 2.0
                 if ratio < 1.6: 
                      real_width_mm = 40.0 # Intraoral approx 40mm
                 else:
                      real_width_mm = 250.0 # OPG approx 250mm
                      
                 if scene_w > 0: scale = scene_w / real_width_mm
                 else: scale = 1.0

            # --- ANATOMICAL WALKING FROM MIDLINE ---
            # Calculate distance from midline in MM
            dist_px = abs(x - midline_x)
            dist_mm = dist_px / scale
            
            # Define cumulative widths based on standard anatomy
            # We use the widths from _get_avg_tooth_dims logic
            
            # Standard Widths (Upper/General)
            # 1: 8.5, 2: 6.5, 3: 7.5, 4: 7.0, 5: 7.0, 6: 10.5, 7: 10.0, 8: 9.5
            widths_upper = [8.5, 6.5, 7.5, 7.0, 7.0, 10.5, 10.0, 9.5]
            
            # Lower Widths (Narrower Incisors)
            # 1: 5.5, 2: 6.0, 3: 7.0, 4: 7.0, 5: 7.5, 6: 10.5, 7: 10.0, 8: 9.5
            widths_lower = [5.5, 6.0, 7.0, 7.0, 7.5, 10.5, 10.0, 9.5]
            
            widths = widths_upper if is_upper else widths_lower
            
            current_dist = 0.0
            predicted_n = 1
            
            for i, w in enumerate(widths):
                # The tooth 'occupies' the range [current_dist, current_dist + w]
                # We check if our click falls within this range
                # However, for better "snapping" feeling, we check if we are closer to the center of this tooth
                # Center of tooth i (1-based index i+1) is at current_dist + w/2
                
                tooth_center = current_dist + (w / 2.0)
                
                # If we are within this tooth's "zone of influence"
                # (simple approach: just check if dist_mm is within the cumulative range)
                if dist_mm < (current_dist + w):
                    predicted_n = i + 1
                    break
                
                current_dist += w
                
                # If we passed the last tooth, just keep the last one (8) or increment if very far?
                # Let's cap at 8
                if i == 7: 
                    predicted_n = 8
            
            return f"{q}{predicted_n}"
            
        except Exception as e:
            print(f"Error predicting manual FDI: {e}")
            return "?"

    def _get_avg_tooth_dims(self, fdi: int):
        """
        Returns average (width_mm, height_mm) for a given FDI number.
        Based on standard dental anatomy (approximate).
        """
        try:
            fdi = int(fdi)
            n = fdi % 10  # 1-8
            
            # Widths (mm)
            widths = {
                1: 8.5, 2: 6.5, 3: 7.5, 4: 7.0, 5: 7.0, 6: 10.5, 7: 10.0, 8: 9.5
            }
            # Heights (mm) - Crown + Root (approximate visible on OPG)
            # Central Incisor: ~22-23
            # Lateral: ~22
            # Canine: ~27
            # Premolar: ~21
            # Molar: ~20-21
            heights = {
                1: 23.0, 2: 22.0, 3: 27.0, 4: 21.5, 5: 21.5, 6: 21.0, 7: 20.0, 8: 19.0
            }
            
            w = widths.get(n, 8.0)
            h = heights.get(n, 21.0)
            
            # Lower incisors are narrower
            if fdi >= 30 and fdi < 50:
                if n == 1: w = 5.5
                if n == 2: w = 6.0
                
            return w, h
        except Exception:
            return 8.0, 21.0

    def add_manual_tooth(self, pos):
        # Default fallback
        w, h = 40, 60
        
        # 1. Always attempt prediction first (fallback)
        fdi_text = "?"
        try:
             fdi_text = self._predict_manual_fdi(pos)
        except Exception:
             pass

        # Calculate dimensions based on FDI and scale
        # Try to get scale from items first (Auto-Scale)
        scale = self._estimate_scale_from_items()
        
        if not scale:
            scale = getattr(self, 'pixel_to_mm_scale', None)
            
        # If no calibration, try to estimate from image width (assume ~250mm width for OPG)
        if scale is None and self.pixmap_item:
            try:
                scene_w = self.pixmap_item.boundingRect().width()
                if scene_w > 0:
                    scale = scene_w / 250.0 # px/mm
            except: pass

        if fdi_text != "?" and str(fdi_text).isdigit() and scale:
             try:
                 w_mm, h_mm = self._get_avg_tooth_dims(int(fdi_text))
                 w = w_mm * scale
                 h = h_mm * scale
             except: pass
        
        # Center the box
        x = pos.x() - w/2
        y = pos.y() - h/2

        # FIX: STRICTLY RESPECT USER CLICK FOR MANUAL ADDITION
        # We purposely avoid any "smart" zone snapping here because if the underlying
        # grid/zones are incorrect (e.g. bad curve detection), the tooth will jump
        # to a wrong location. The user's click is the ground truth.
        
        suggested_fdi = fdi_text
        
        # 2. Grid Mode: Auto-detect FDI ONLY (Do NOT change position)
        if self.grid_active and self.grid_lines_h:
            # We use _snap_to_grid ONLY to get the suggested FDI, ignoring the returned x, y to prevent jumping
            # The user's click position (pos) is the ground truth.
            _, _, fdi_grid = self._snap_to_grid(pos, w, h)
            if fdi_grid != "?":
                fdi_text = fdi_grid
                suggested_fdi = fdi_text
        
        # Open Dialog for mandatory fields
        dialog = ToothDetailsDialog(self, fdi=fdi_text, mode="add", show_grid_bypass=True)
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return

        data = dialog.get_data()
        fdi_text = data["fdi"]
        statuses = data["statuses"]
        notes = data["notes"]
        timestamp = data["timestamp"]
        # FIX: Manual additions should default to bypassed (locked) unless user says otherwise
        # This prevents the auto-algorithm from changing the number later.
        user_bypass = data.get("bypass_grid", False)
        # If user changed the FDI from suggestion, it's definitely a manual override.
        # But even if they didn't, a manual addition implies "I want this here".
        # So we default to True for manual additions.
        bypass_grid = True 
        if "bypass_grid" in data and not user_bypass:
             # Only if user EXPLICITLY unchecked it (if that option exists), we might allow False.
             # But strictly, manual additions should be safe.
             bypass_grid = True
        
        # Override with explicit user choice if provided (assuming dialog handles it)
        if user_bypass:
            bypass_grid = True

        # Create without callback to avoid setup recursion
        rect = EditableRectItem(x=x, y=y, w=w, h=h)
        self.scene.addItem(rect)
        rect.set_statuses(statuses, notify=False)
        rect.set_notes(notes)
        rect.set_last_updated(timestamp)
        rect.set_bypass_grid(bypass_grid)
        try:
            rect.set_last_updated_by(data.get("updated_by"))
        except Exception:
            pass
        try:
            rect.set_implant(data.get("implant"))
        except Exception:
            pass
        self.apply_status_visuals_to_rect(rect)
        
        text = EditableTextItem(fdi_text, rect_item=rect)
        text.setDefaultTextColor(QColor("red"))
        self.scene.addItem(text)
        self.analysis_items.append(rect)
        self.analysis_items.append(text)
        self._apply_overlay_visibility(rect, text)
        self._position_label_for_rect(rect)
        
        # Attach callbacks
        rect.on_change_callback = self.debounced_recalculate_fdi
        text.on_change_callback = self.debounced_recalculate_fdi
        try:
            self._learn_grid_cell_label(rect, fdi_text)
        except Exception:
            pass
        
        self.on_annotation_modified()
        QMessageBox.information(self, "Επιτυχία", "Το νέο δόντι προστέθηκε επιτυχώς.")

    def add_condition_box(self, pos, status, color_name):
        return self.add_status_region(pos, status)
        
    def _snap_to_grid(self, pos, w, h):
        x = pos.x() - w/2
        y = pos.y() - h/2
        fdi_text = "?"
        
        # Prepare vertical lines
        v_lines_upper = []
        if hasattr(self, 'grid_lines_v_upper') and self.grid_lines_v_upper:
             v_lines_upper = sorted([l.x() for l in self.grid_lines_v_upper if l and l.scene() == self.scene])
        
        v_lines_lower = []
        if hasattr(self, 'grid_lines_v_lower') and self.grid_lines_v_lower:
             v_lines_lower = sorted([l.x() for l in self.grid_lines_v_lower if l and l.scene() == self.scene])

        # Fallback
        if not v_lines_upper and not v_lines_lower and hasattr(self, 'grid_lines_v') and self.grid_lines_v:
             v_lines_common = sorted([l.x() for l in self.grid_lines_v if l and l.scene() == self.scene])
             v_lines_upper = v_lines_common
             v_lines_lower = v_lines_common
             
        if not v_lines_upper and not v_lines_lower:
             return x, y, fdi_text
        
        # Fetch grid lines h
        h_lines = sorted([l.y() for l in (getattr(self, "grid_lines_h", None) or []) if l and l.scene() == self.scene])
        
        # Determine Zone
        zone_type = None
        y_top, y_bot = 0, 0
        v_lines = []
        
        if len(h_lines) >= 3:
            if h_lines[0] <= pos.y() <= h_lines[1]:
                zone_type = 'upper'
                y_top, y_bot = h_lines[0], h_lines[1]
                v_lines = v_lines_upper
            elif h_lines[1] <= pos.y() <= h_lines[2]:
                zone_type = 'lower'
                y_top, y_bot = h_lines[1], h_lines[2]
                v_lines = v_lines_lower
        elif len(h_lines) >= 2:
            if h_lines[0] <= pos.y() <= h_lines[-1]:
                zone_type = 'upper'
                y_top, y_bot = h_lines[0], h_lines[-1]
                v_lines = v_lines_upper
        
        if zone_type and v_lines:
            outer_bounds = []
            try:
                if zone_type == "upper":
                    outer_bounds = sorted([l.x() for l in (getattr(self, "grid_lines_v_outer_upper", None) or []) if l and l.scene() == self.scene])
                else:
                    outer_bounds = sorted([l.x() for l in (getattr(self, "grid_lines_v_outer_lower", None) or []) if l and l.scene() == self.scene])
            except Exception:
                outer_bounds = []
            left_bound = 0.0
            right_bound = 0.0
            try:
                if self.pixmap_item:
                    right_bound = float(self.pixmap_item.boundingRect().width())
                else:
                    right_bound = float(max(v_lines[-1] + 1.0, pos.x() + 1.0))
            except Exception:
                right_bound = float(max(v_lines[-1] + 1.0, pos.x() + 1.0))
            if len(outer_bounds) >= 2:
                try:
                    lb = float(outer_bounds[0])
                    rb = float(outer_bounds[-1])
                    if rb > lb:
                        left_bound = lb
                        right_bound = rb
                except Exception:
                    pass

            px = float(pos.x())
            if right_bound > left_bound:
                if px < left_bound:
                    px = left_bound
                elif px > right_bound:
                    px = right_bound

            # Determine Slot
            slot = 0
            for v_x in v_lines:
                if px > v_x:
                    slot += 1
            
            map_upper = [18, 17, 16, 15, 14, 13, 12, 11, 21, 22, 23, 24, 25, 26, 27, 28]
            map_lower = [48, 47, 46, 45, 44, 43, 42, 41, 31, 32, 33, 34, 35, 36, 37, 38]
            
            if 0 <= slot < 16:
                try:
                    cm = getattr(self, "grid_cell_label_map", None)
                    if isinstance(cm, dict):
                        override = self._normalize_fdi_label(cm.get(f"{zone_type}:{int(slot)}", ""))
                    else:
                        override = ""
                except Exception:
                    override = ""
                if override:
                    fdi_text = str(override)
                else:
                    if zone_type == 'upper':
                        fdi_text = str(map_upper[slot])
                    else:
                        fdi_text = str(map_lower[slot])
                
                # Center in Slot
                x_left = -10000
                x_right = 10000
                
                if slot == 0:
                    x_right = v_lines[0]
                    x_left = left_bound
                elif slot == len(v_lines): # Rightmost slot
                    x_left = v_lines[-1]
                    x_right = right_bound
                else:
                    # Fix: Ensure indices are within bounds for v_lines
                    # For slot N, we need v_lines[N-1] (left) and v_lines[N] (right)
                    # Example: Slot 1 (between 0 and 1) -> v_lines[0] and v_lines[1]
                    if slot > 0 and slot - 1 < len(v_lines):
                         x_left = v_lines[slot - 1]
                    if slot < len(v_lines):
                         x_right = v_lines[slot]

                if x_left > -5000 and x_right < 5000:
                    # center_x = (x_left + x_right) / 2
                    # center_y = (y_top + y_bot) / 2
                    # x = center_x - w/2
                    # y = center_y - h/2
                    pass # Keep original click position (user preference)
        
        return x, y, fdi_text

    def _snap_rect_item_to_grid_slot(self, rect_item):
        if not getattr(self, "grid_active", False):
            return False

        try:
            v_lines_upper = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v_upper", None) or []) if l and l.scene() == self.scene])
        except Exception:
            v_lines_upper = []

        try:
            v_lines_lower = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v_lower", None) or []) if l and l.scene() == self.scene])
        except Exception:
            v_lines_lower = []

        if not v_lines_upper and not v_lines_lower:
            try:
                v_common = sorted([float(l.x()) for l in (getattr(self, "grid_lines_v", None) or []) if l and l.scene() == self.scene])
            except Exception:
                v_common = []
            v_lines_upper = v_common
            v_lines_lower = v_common

        # Fetch grid lines h
        try:
            h_lines = sorted([float(l.y()) for l in (getattr(self, "grid_lines_h", None) or []) if l and l.scene() == self.scene])
        except Exception:
            h_lines = []

        if not h_lines or (not v_lines_upper and not v_lines_lower):
            return False

        try:
            rect = self.pixmap_item.boundingRect() if getattr(self, "pixmap_item", None) else self.scene.sceneRect()
            width_scene = float(rect.width() or 1.0)
        except Exception:
            width_scene = 1.0

        r = rect_item.rect()
        bw = float(r.width() or 1.0)
        bh = float(r.height() or 1.0)

        label = None
        try:
            label = rect_item.get_label_text() if hasattr(rect_item, "get_label_text") else None
            label = str(label or "").strip()
        except Exception:
            label = ""

        fdi_int = None
        if re.match(r"^\d{2}$", label):
            try:
                fdi_int = int(label)
            except Exception:
                fdi_int = None

        map_upper = [18, 17, 16, 15, 14, 13, 12, 11, 21, 22, 23, 24, 25, 26, 27, 28]
        map_lower = [48, 47, 46, 45, 44, 43, 42, 41, 31, 32, 33, 34, 35, 36, 37, 38]

        br = None
        try:
            br = rect_item.sceneBoundingRect()
        except Exception:
            br = None
        if br is None:
            br = QRectF(0, 0, 0, 0)
        center = br.center()

        zone_type = None
        if len(h_lines) >= 3:
            y_mid = float(h_lines[1])
            y_sep = y_mid
            try:
                j = getattr(self, "jaw_separator_line", None)
                if j is not None and j.scene() == self.scene and bool(j.isVisible()):
                    y_sep = float(j.get_y_at_x(float(center.x())))
            except Exception:
                y_sep = y_mid
            zone_type = "upper" if float(center.y()) <= float(y_sep) else "lower"
        elif len(h_lines) >= 2:
            if float(h_lines[0]) <= float(center.y()) <= float(h_lines[-1]):
                zone_type = "upper"

        cx = float(center.x())
        cy = float(center.y())

        if fdi_int is not None:
            q = int(fdi_int) // 10
            zone_type = "upper" if q in (1, 2) else "lower"
            v_lines = v_lines_upper if zone_type == "upper" else (v_lines_lower or v_lines_upper)
            mapping = map_upper if zone_type == "upper" else map_lower
            if v_lines and fdi_int in mapping:
                slot = int(mapping.index(fdi_int))
                left_b = float(v_lines[slot - 1]) if slot > 0 and (slot - 1) < len(v_lines) else 0.0
                right_b = float(v_lines[slot]) if slot < len(v_lines) else float(width_scene)
                cx = (left_b + right_b) / 2.0
                if len(h_lines) >= 3:
                    cy = (float(h_lines[0]) + float(h_lines[1])) / 2.0 if zone_type == "upper" else (float(h_lines[1]) + float(h_lines[2])) / 2.0
                elif len(h_lines) >= 2:
                    cy = (float(h_lines[0]) + float(h_lines[-1])) / 2.0

                try:
                    j = getattr(self, "jaw_separator_line", None)
                    if zone_type in ("upper", "lower") and j is not None and self._is_scene_item_alive(j):
                        sep_y = float(j.get_y_at_x(float(cx)))
                        pad = float(bh) * 0.55
                        if zone_type == "lower":
                            cy = max(float(cy), sep_y + pad)
                        else:
                            cy = min(float(cy), sep_y - pad)
                except Exception:
                    pass
            else:
                v_lines = v_lines_upper if zone_type == "upper" else (v_lines_lower or v_lines_upper)
                if v_lines:
                    slot = 0
                    for vx in v_lines:
                        if cx > vx:
                            slot += 1
                    left_b = float(v_lines[slot - 1]) if slot > 0 and (slot - 1) < len(v_lines) else 0.0
                    right_b = float(v_lines[slot]) if slot < len(v_lines) else float(width_scene)
                    cx = (left_b + right_b) / 2.0
        else:
            if zone_type is None:
                return False
            v_lines = v_lines_upper if zone_type == "upper" else (v_lines_lower or v_lines_upper)
            if not v_lines:
                return False
            slot = 0
            for vx in v_lines:
                if cx > vx:
                    slot += 1
            left_b = float(v_lines[slot - 1]) if slot > 0 and (slot - 1) < len(v_lines) else 0.0
            right_b = float(v_lines[slot]) if slot < len(v_lines) else float(width_scene)
            cx = (left_b + right_b) / 2.0
            if len(h_lines) >= 3:
                cy = (float(h_lines[0]) + float(h_lines[1])) / 2.0 if zone_type == "upper" else (float(h_lines[1]) + float(h_lines[2])) / 2.0
            elif len(h_lines) >= 2:
                cy = (float(h_lines[0]) + float(h_lines[-1])) / 2.0

        x = float(cx) - bw / 2.0
        y = float(cy) - bh / 2.0
        x = max(0.0, min(float(width_scene) - bw, x))
        try:
            if getattr(self, "pixmap_item", None):
                height_scene = float(self.pixmap_item.boundingRect().height() or 1.0)
            else:
                height_scene = float(self.scene.sceneRect().height() or 1.0)
        except Exception:
            height_scene = 1.0
        y = max(0.0, min(float(height_scene) - bh, y))

        try:
            # rect_item.setPos(QPointF(float(x) - float(r.x()), float(y) - float(r.y())))
            pass # Disable auto-snap to allow manual correction without jumping
        except Exception:
            return False
        return True

    def add_missing_tooth(self, pos, show_x: bool = True):
        status = "Ελλείπον"
        if not self.scene:
            return

        w, h = 40, 60
        x = pos.x() - w / 2
        y = pos.y() - h / 2
        
        # Auto-predict FDI based on click position
        try:
            fdi_text = self._predict_manual_fdi(pos)
        except Exception:
            fdi_text = "?"

        rect = EditableRectItem(x=x, y=y, w=w, h=h, on_change_callback=self.debounced_recalculate_fdi)
        self.scene.addItem(rect)
        try:
            rect.set_statuses([status], notify=False)
        except TypeError:
            rect.set_statuses([status])
        try:
            rect.set_last_updated(datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        except Exception:
            pass
        try:
            self.apply_status_visuals_to_rect(rect)
        except Exception:
            pass

        text_item = EditableTextItem(str(fdi_text or ""), rect_item=rect, on_change_callback=self.debounced_recalculate_fdi)
        text_item.setDefaultTextColor(QColor("red"))
        self.scene.addItem(text_item)
        self.analysis_items.append(rect)
        self.analysis_items.append(text_item)
        self._apply_overlay_visibility(rect, text_item)
        self._position_label_for_rect(rect)

        if bool(show_x):
            x_mark = QGraphicsTextItem("X", rect)
            font = QFont()
            font.setBold(True)
            font.setPointSize(18)
            x_mark.setFont(font)
            x_mark.setDefaultTextColor(QColor(220, 60, 60, 180))
            br = x_mark.boundingRect()
            r = rect.rect()
            x_mark.setPos(r.x() + (r.width() - br.width()) / 2, r.y() + (r.height() - br.height()) / 2)
            x_mark.setZValue(60)

        try:
            self.on_annotation_modified()
        except Exception:
            pass

    def toggle_calibration_mode(self):
        self.is_calibrating = self.calibration_button.isChecked()
        if self.is_calibrating:
            try:
                if bool(getattr(self, "missing_cell_mode", False)):
                    self._set_missing_cell_mode(False)
            except Exception:
                pass
            rect = None
            try:
                pi = getattr(self, "pixmap_item", None)
                if pi is not None:
                    rect = pi.mapToScene(pi.boundingRect()).boundingRect()
            except Exception:
                rect = None
            if rect is None:
                rect = self.view.mapToScene(self.view.viewport().rect()).boundingRect()
            center_x = rect.center().x()
            center_y = rect.center().y()
            width = min(float(rect.width()), float(rect.height())) / 4.0
            if width < 100:
                width = 100
            
            # Offset to avoid overlapping with center separators
            offset = 50
            try:
                offset = min(float(offset), max(12.0, float(rect.width()) * 0.08))
            except Exception:
                offset = 50

            def _clamp(v, lo, hi):
                try:
                    return min(max(float(v), float(lo)), float(hi))
                except Exception:
                    return v
            
            # X-Axis Line (Green)
            if not getattr(self, 'calib_line_x', None):
                yv = _clamp(center_y + offset, rect.top(), rect.bottom())
                x1 = _clamp(center_x - width, rect.left(), rect.right())
                x2 = _clamp(center_x + width, rect.left(), rect.right())
                self.calib_line_x = CalibrationLine(
                    x1, yv,
                    x2, yv,
                    self.apply_calibration, axis_type='x', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                self.scene.addItem(self.calib_line_x)
            
            # Y-Axis Line (Magenta)
            if not getattr(self, 'calib_line_y', None):
                # AUTOMATIC CALCULATION based on User's Zones
                xv = center_x
                
                # Y1: Start from Zone Line 1 (Sinus/Upper Jaw) center
                y1 = center_y - width # Default fallback
                zl1 = getattr(self, "zone_line_1", None)
                if self._is_scene_item_alive(zl1) and zl1.isVisible():
                     y1 = zl1.y()
                else:
                     y1 = rect.top() + (rect.height() * 0.2)
                     
                # Y2: End at Jaw Bottom (Black Void)
                y2 = center_y + width # Default fallback
                detected_bottom = self._detect_jaw_bottom(xv)
                if detected_bottom is not None:
                     y2 = detected_bottom
                else:
                     # Fallback if detection fails: bottom of image - 10%
                     y2 = rect.bottom() - (rect.height() * 0.1)

                self.calib_line_y = CalibrationLine(
                    xv, y1,
                    xv, y2,
                    self.apply_calibration, axis_type='y', on_change_callback=self._schedule_layout_save, viewer_widget=self)
                self.scene.addItem(self.calib_line_y)

            self.calib_line_x.setVisible(True)
            self.calib_line_y.setVisible(True)
            
            # Hide old single line if exists
            if self.calibration_line: self.calibration_line.setVisible(False)
            
            self.setCursor(Qt.CursorShape.ArrowCursor)
            
            QMessageBox.information(self, "Βαθμονόμηση 2 Αξόνων", 
                "Εμφανίστηκαν δύο άξονες βαθμονόμησης (Χ και Υ).\n"
                "1. Χρησιμοποιήστε την ΚΟΚΚΙΝΗ γραμμή για το πλάτος (Κόνδυλοι).\n"
                "2. Χρησιμοποιήστε την ΜΩΒ γραμμή για το ύψος.\n"
                "3. Κάντε διπλό κλικ σε κάθε γραμμή για να ορίσετε το μήκος.")
            try:
                self._schedule_layout_save(0)
            except Exception:
                pass
        else:
             if getattr(self, 'calib_line_x', None): self.calib_line_x.setVisible(False)
             if getattr(self, 'calib_line_y', None): self.calib_line_y.setVisible(False)
             if self.calibration_line: self.calibration_line.setVisible(False)
             self.setCursor(Qt.CursorShape.ArrowCursor)
             try:
                 self._schedule_layout_save(0)
             except Exception:
                 pass
        try:
            self._announce_action_done("Βαθμονόμηση: ενεργή" if bool(getattr(self, "is_calibrating", False)) else "Βαθμονόμηση: ανενεργή")
        except Exception:
            pass
             
     # Removed drag-drawing methods as they are replaced by handles logic
    def start_drawing_calibration(self, scene_pos):
        pass
        
    def update_drawing_calibration(self, scene_pos):
        pass
            
    def finish_drawing_calibration(self):
        pass

    def apply_calibration(self, ratio, axis_type='any'):
        if axis_type == 'x':
            self.pixel_to_mm_scale_x = ratio
        elif axis_type == 'y':
            self.pixel_to_mm_scale_y = ratio
        else:
            self.pixel_to_mm_scale_x = ratio
            self.pixel_to_mm_scale_y = ratio
            
        # Update main scale (average) for simple visual rulers
        if self.pixel_to_mm_scale_x and self.pixel_to_mm_scale_y:
             self.pixel_to_mm_scale = (self.pixel_to_mm_scale_x + self.pixel_to_mm_scale_y) / 2
        elif self.pixel_to_mm_scale_x:
             self.pixel_to_mm_scale = self.pixel_to_mm_scale_x
             if self.pixel_to_mm_scale_y is None: self.pixel_to_mm_scale_y = self.pixel_to_mm_scale_x
        elif self.pixel_to_mm_scale_y:
             self.pixel_to_mm_scale = self.pixel_to_mm_scale_y
             if self.pixel_to_mm_scale_x is None: self.pixel_to_mm_scale_x = self.pixel_to_mm_scale_y
        
        print(f"Calibrated {axis_type}: {ratio:.4f}")
        self.view.viewport().update()
        self.view.viewport().update()
        self.view.viewport().update()
        try:
            self._schedule_layout_save(0)
        except Exception:
            pass
        try:
            self._pipeline_set("calib", "Βαθμονόμηση: OK", self._pipeline_hint_for_step("lines"), progress=14, step_status_updates={"calib": "OK", "lines": "TODO"})
        except Exception:
            pass
        try:
            if bool(getattr(self, "auto_pipeline_enabled", True)) and bool(getattr(self, "current_image_path", None)):
                QTimer.singleShot(120, self.run_pipeline_next_step)
        except Exception:
            pass
